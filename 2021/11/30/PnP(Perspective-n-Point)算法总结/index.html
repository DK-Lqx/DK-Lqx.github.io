

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/browser_tab.jpeg">
  <link rel="icon" href="/img/browser_tab.jpeg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="在Robomaster中研究自瞄时，关于PNP四种算法的小小总结。">
  <meta name="author" content="lqx">
  <meta name="keywords" content="">
  <meta name="description" content="在Robomaster中研究自瞄时，关于PNP四种算法的小小总结。">
<meta property="og:type" content="article">
<meta property="og:title" content="PnP(Perspective-n-Point)问题：各种算法总结分析">
<meta property="og:url" content="http://example.com/2021/11/30/PnP(Perspective-n-Point)%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Robotics and Astronomy by lqx">
<meta property="og:description" content="在Robomaster中研究自瞄时，关于PNP四种算法的小小总结。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/PNP_summary/pnp_setting.png">
<meta property="article:published_time" content="2021-11-30T06:00:49.654Z">
<meta property="article:modified_time" content="2021-12-10T06:46:37.413Z">
<meta property="article:author" content="lqx">
<meta property="article:tag" content="Algorithum">
<meta property="article:tag" content="SLAM">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/PNP_summary/pnp_setting.png">
  
  <title>PnP(Perspective-n-Point)问题：各种算法总结分析 - Robotics and Astronomy by lqx</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>DK-L</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/PNP_summary/pnp_setting.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="PnP(Perspective-n-Point)问题：各种算法总结分析">
              
                PnP(Perspective-n-Point)问题：各种算法总结分析
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-11-30 14:00" pubdate>
        November 30, 2021 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      17k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      52 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">PnP(Perspective-n-Point)问题：各种算法总结分析</h1>
            
            <div class="markdown-body">
              <h2 id="1-本文简介"><a href="#1-本文简介" class="headerlink" title="1 本文简介"></a>1 本文简介</h2><h3 id="1-1-写作动机"><a href="#1-1-写作动机" class="headerlink" title="1.1 写作动机"></a>1.1 写作动机</h3><p>笔者近日在学习计算机视觉与SLAM的过程中，因面临确定物体位姿的需求，详细的学习了PnP(Perspective-n-Point)问题及其主流的四种解决算法（DLT、P3P、EPnP、BA）。在查阅网络资料学习的过程中，遇到的不少文章基本上只对其中的个别算法进行了简单介绍，且没有严格的数学推导，问题的描述和符号也不是很严格清晰，给学习带来了较多障碍。故萌生了写此文的想法，用严格统一的符号和表述详细的介绍PnP问题的四种解决算法，也算是学习过程中的一个小小的笔记。</p>
<p>本文同时发布于知乎，欢迎前往阅读和点赞：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/399140251">https://zhuanlan.zhihu.com/p/399140251</a> 。</p>
<p><img src="/img/PNP_summary/pnp_setting.png" srcset="/img/loading.gif" lazyload alt="pnp_setting"></p>
<h3 id="1-2-问题描述"><a href="#1-2-问题描述" class="headerlink" title="1.2 问题描述"></a>1.2 问题描述</h3><p>PnP(Perspective-n-Point)是求解3D到2D点对运动的方法，目的是求解相机坐标系相对世界坐标系的位姿。它描述了已知<script type="math/tex">n</script>个3D点的坐标(相对世界坐标系)以及这些点的像素坐标时，如何估计相机的位姿(即求解世界坐标系到相机坐标系的旋转矩阵<script type="math/tex">R</script>和平移向量<script type="math/tex">t</script>)。</p>
<p>用数学公式描述如下：</p>
<ul>
<li>基本公式： $$\omega \boldsymbol{p}=KP^C=K(R_{CW}\times P^W+t^C_{CW})$$ 其中:<ul>
<li><script type="math/tex">\boldsymbol{p}</script>为点在像素坐标系下的坐标</li>
<li><script type="math/tex">P^C</script>为点在相机坐标系下的坐标</li>
<li><script type="math/tex">P^W</script>为点在世界坐标系下的坐标</li>
<li><script type="math/tex">\omega</script>为点的深度</li>
<li><script type="math/tex">K</script>为相机的内参矩阵</li>
<li><script type="math/tex">R_{CW}</script>和<script type="math/tex">t^C_{CW}</script>为从世界坐标系到相机坐标系的位姿转换。</li>
</ul>
</li>
<li><strong>已知</strong>：<ul>
<li>所有<script type="math/tex">n</script>个点在<strong>世界坐标系</strong>下的坐标<script type="math/tex">P_1^W,P_2^W,...,P_n^W</script></li>
<li>这些点相应在<strong>像素坐标系</strong>下的坐标<script type="math/tex">\boldsymbol{p}_1,\boldsymbol{p}_2,...,\boldsymbol{p}_n</script></li>
<li>相机<strong>内参</strong>矩阵<script type="math/tex">K</script></li>
<li>注：由于是已知<script type="math/tex">n</script>个点的3D-2D对应关系，所以相应问题被称作PnP问题。</li>
</ul>
</li>
<li><strong>求解</strong>：<strong>相机坐标系相对于世界坐标系的位姿</strong>，即<script type="math/tex">P^C=R_{CW}\times P^W+\boldsymbol{t^C_{CW}}</script>中的<script type="math/tex">R_{CW}</script>和<script type="math/tex">\boldsymbol{t^C_{CW}}</script><ul>
<li><script type="math/tex">R_{CW}</script>是世界坐标系到相机坐标系的旋转矩阵，将同一个向量在世界坐标系下的表示转化为在相机坐标系下的表示</li>
<li><script type="math/tex">\boldsymbol{t^C_{CW}}</script>为相应的平移向量，从相机坐标系原点指向世界坐标系原点的向量，在相机坐标系下的表示。</li>
</ul>
</li>
<li>算法：直接线性变换(DLT)、P3P、EPnP、光束法平差(BA，Bundle Adjustment)。</li>
</ul>
<h3 id="1-3-符号介绍"><a href="#1-3-符号介绍" class="headerlink" title="1.3 符号介绍"></a>1.3 符号介绍</h3><p>本文中，一律用上标区别向量在不同坐标系下的表达：</p>
<ul>
<li><script type="math/tex">P^W=[X^W,Y^W,Z^W]^T</script>代表点在<strong>世界坐标系</strong>下的表示</li>
<li><script type="math/tex">P^C=[X^C,Y^C,Z^C]^T</script>代表点在<strong>相机坐标系</strong>下的表示</li>
<li><script type="math/tex">P^{'}=[X^C/Z^C,Y^C/Z^C,1]^T=[u_1,v_1,1]^T</script>代表点在<strong>相机归一化坐标系</strong>下的表示</li>
<li><script type="math/tex">\boldsymbol{p}=[u,v,1]^T</script>代表点在<strong>像素坐标系</strong>下的表示(投影到像素平面之后扩展为齐次坐标)</li>
</ul>
<p>上述坐标系间的转换关系如下：$$\omega \boldsymbol{p}=KP^C=K(R_{CW}\times P^W+t^C_{CW})$$</p>
<p>其中<script type="math/tex">\omega = Z^C</script>为点在相机坐标系下的深度。</p>
<p>展开：$$\omega \boldsymbol{p}=Z^C\begin{pmatrix}u\\v \\1\end{pmatrix} = \begin{pmatrix}f_x& s &c_x \\0&f_y  &c_y \\0 & 0 &1\end{pmatrix}\begin{pmatrix}X^C\\Y^C \\Z^C\end{pmatrix}
=\begin{pmatrix}f_x& s &c_x \\0&f_y  &c_y \\0 & 0 &1\end{pmatrix}\begin{pmatrix}r_{11}& r_{12} & r_{13} & t_1\\r_{21}& r_{22} & r_{23} & t_2\\r_{31}& r_{32} &r_{33}  & t_3\end{pmatrix}\begin{pmatrix}X^W\\Y^W \\Z^W\\1\end{pmatrix}=K[R|t] P^W$$</p>
<p>PnP就是在已知$n$个点的像素坐标$p_i$及其世界坐标系下的坐标$P^W_i$和相机的内参矩阵$K$的前提下，求解相机的位姿$R$和$t$。</p>
<h2 id="2-算法总结"><a href="#2-算法总结" class="headerlink" title="2 算法总结"></a>2 算法总结</h2><h3 id="2-1-直接线性变换（DLT，Direct-Linear-Transform）"><a href="#2-1-直接线性变换（DLT，Direct-Linear-Transform）" class="headerlink" title="2.1 直接线性变换（DLT，Direct  Linear  Transform）"></a>2.1 直接线性变换（DLT，Direct  Linear  Transform）</h3><p>为了通过一个点的像素坐标和世界坐标构建一个关于相机位姿参数的方程，我们可以先通过相机内参将像素坐标转换为相机归一化坐标，根据相应的归一化约束条件可以获得关于姿态参数的两个方程，为了求解$R$和$t$中一共的12个参数，我们至少需要6个点来构建方程。</p>
<p>根据关系<script type="math/tex">\omega \boldsymbol{p}=KP^C=K[R|t]P^W</script>，可得<script type="math/tex">\omega K^{-1} \boldsymbol{p}=\omega P^{'}=P^{C}=[R|t]P^W</script>。</p>
<p>最初，我们已知点的像素坐标：$$\begin{pmatrix}u\\v \\1\end{pmatrix}$$</p>
<p>将其左乘相机内参矩阵的逆<script type="math/tex">K^{-1}</script>可得点在相机归一化坐标系中的坐标： $$\begin{pmatrix}u_1\\v_1 \\1\end{pmatrix} =K^{-1}\begin{pmatrix}u\\v \\1\end{pmatrix}$$</p>
<p>相机归一化坐标系中的坐标乘以点相对于成像平面的深度<script type="math/tex">\omega=Z^C</script>可得点相对于相机坐标系的坐标：$$\omega\begin{pmatrix}u_1\\v_1 \\1\end{pmatrix} =P^C$$</p>
<p>根据<script type="math/tex">P^{C}=[R|t]P^W</script>，可构建等式:  $$\omega\begin{pmatrix}u_1\\v_1 \\1\end{pmatrix} =\begin{pmatrix}t_1& t_2 & t_3 & t_4\\t_5& t_6 & t_7 & t_8\\t_9& t_{10} &t_{11}  & t_{12}\end{pmatrix}\begin{pmatrix}X^W\\Y^W \\Z^W\\1\end{pmatrix}$$</p>
<p>利用最后一行把$\omega$消去，可得两个约束：$$u_1=\frac{t_1X_W+t_2Y_W+t_3Z_W+t_4}{t_9X_W+t_{10}Y_W+t_{11}Z_W+t_{12}}$$， $$v_1=\frac{t_5X_W+t_6Y_W+t_7Z_W+t_8}{t_9X_W+t_{10}Y_W+t_{11}Z_W+t_{12}}$$</p>
<p>为简化表示，定义增广矩阵$T=[R|t]$的行向量表示： $$\boldsymbol{t}_1=(t_1,t_2,t_3,t_4)^T， \boldsymbol{t}_2=(t_5,t_6,t_7,t_8)^T， \boldsymbol{t}_3=(t_9,t_{10},t_{11},t_{12})^T$$</p>
<p>所以说，有：   $$\boldsymbol{t_1^TP^W}-\boldsymbol{t_3^TP^W}u_1=0，\boldsymbol{t_2^TP^W}-\boldsymbol{t_3^TP^W}v_1=0$$</p>
<p>注意上式中：<script type="math/tex">\boldsymbol{t}</script>是待求的变量；<script type="math/tex">\boldsymbol{P^W},u_1,v_1</script>是已知量，分别为点在世界坐标系下的3D位置以及在相机归一化坐标系下的2D投影位置(可通过点的像素坐标左乘相机内参矩阵的逆得到)。可以看出，每个特征点提供了两个关于<script type="math/tex">\boldsymbol{t}</script>的线性约束。假设一共有<script type="math/tex">N</script>个特征点，则可列出如下线性方程组：    $$\begin{pmatrix}
 \boldsymbol{P_1^T}  & 0 & -u_1 \boldsymbol{P_1^T}\\
  0& \boldsymbol{P_1^T}  & -v_1 \boldsymbol{P_1^T}\\
  ...& ... & ...\\
  \boldsymbol{P_N^T}&  0&-u_N \boldsymbol{P_N^T} \\
  0&  \boldsymbol{P_N^T}&-v_N \boldsymbol{P_N^T}
\end{pmatrix} \begin{pmatrix}
 \boldsymbol{t_1} \\
 \boldsymbol{t_2}\\
\boldsymbol{t_3}
\end{pmatrix}=0$$  </p>
<p>记为:$$A\boldsymbol{t}=0$$</p>
<p>注意上式中点的坐标省去了上标<script type="math/tex">^W</script>，它们都是点在世界坐标系下的表示。</p>
<p>注意到<script type="math/tex">\boldsymbol{t}</script>一共有12维，最少通过6对匹配点即可实现增广矩阵<script type="math/tex">\boldsymbol{T=[R|t]}</script>的线性求解，这种方法称为DLT。当1匹配点的数量大于6对时，可以使用SVD等方法求超定方程的最小二乘解。针对SVD求超定方程的最小二乘解，说明如下：当匹配点数量大于6对时，可以获得一个在<script type="math/tex">|\boldsymbol{t}|=1</script>约束下的最小二乘解<script type="math/tex">\boldsymbol{t^*}=\underset{\boldsymbol{t}}{argmin}||A\boldsymbol{t}||</script>。具体的，令<script type="math/tex">A=UDV^T</script>，则最小二乘解<script type="math/tex">\boldsymbol{t^*}</script>为<script type="math/tex">V</script>的最后一列<script type="math/tex">\boldsymbol{t^v}</script>，这样求得的最小二乘解是没有尺度的，之后可以再利用SVD确定最优旋转矩阵近似以及相应的尺度，便可以确定最终的相机姿态<script type="math/tex">T=[R|t]</script>。关于这一部分的细节，可以看参考文献[3].</p>
<h3 id="2-2-P3P"><a href="#2-2-P3P" class="headerlink" title="2.2 P3P"></a>2.2 P3P</h3><p>P3P利用3个点的几何关系，通过三点已知的世界坐标系下的3D坐标以及相应点在相机归一化平面上投影的2D坐标，可以通过构建方程得到三个点在相机坐标系下的3D坐标，之后将问题转化为3D-3D的ICP问题，由于带有匹配信息的3D-3D位姿求解非常容易，所以这种方法是有效的。</p>
<p>上图中，我们记3D点为A,B,C，2D点为a,b,c(注意2D点为3D点在相机归一化平面上的投影)，我们需要通过一些几何关系构建方程得到OA、OB、OC，来得到3D点在相机坐标系下的坐标（其实就是获取归一化平面上2D点的深度信息）。</p>
<p>对于三组对应的三角形： $$\bigtriangleup Oab-\bigtriangleup OAB,\bigtriangleup Obc -\bigtriangleup OBC,\bigtriangleup Oac-\bigtriangleup OAC$$</p>
<p>由余弦定理：$$OA^2+OB^2-2OA\cdot OB\cdot cos(a,b)=AB^2$$ $$OB^2+OC^2-2OB\cdot OC\cdot cos(b,c)=BC^2$$ $$OA^2+OC^2-2OA\cdot OC\cdot cos(a,c)=AC^2$$</p>
<p>对以上三式全体除以<script type="math/tex">OC^2</script>，并记<script type="math/tex">x=OA/OC,y=OB/OC</script>，可得： $$x^2+y^2-2xy cos(a,b)=AB^2/OC^2$$ $$y^2+1^2-2y cos(b,c)=BC^2/OC^2$$ $$x^2+1^2-2x cos(a,c)=AC^2/OC^2$$</p>
<p>由上式中的后两式可知，若能解出$x,y$，则代入后两式中的任一式，即可得到<script type="math/tex">OC</script>，之后再由<script type="math/tex">x,y</script>计算出<script type="math/tex">OA,OB</script>，便可以知道三个点在相机坐标系下的坐标。</p>
<p>为求解出<script type="math/tex">x,y</script>，记<script type="math/tex">v=AB^2/OC^2,uv=BC^2/OC^2,wv=AC^2/OC^2</script>，有：$$x^2+y^2-2xy cos=v$$ $$y^2+1^2-2y cos=uv$$ $$x^2+1^2-2x cos=wv$$</p>
<p>将第一个式子中得到的<script type="math/tex">v</script>代入后两式，可得：$$(1-u)y^2-ux^2-cos(b,c)y+2uxycos(a,b)+1=0$$ $$(1-w)x^2-wy^2-cos(a,c)x+2wxycos(a,b)+1=0$$</p>
<p>上面两个方程中，由于我们知道点的相机归一化坐标，即2D投影位置，则三个余弦<script type="math/tex">cos(a,b),cos(b,c),cos(a,c)</script>是已知的。同时，<script type="math/tex">u=BC^2/AB^2,w=AC^2/AB^2</script>可以通过三个点在世界坐标系下的坐标算出。该式中只有<script type="math/tex">x,y</script>是未知的，随着相机的移动会发生改变。所以，该方程组是关于<script type="math/tex">x,y</script>的一个二元二次方程，求该方程的解析解需要用到吴消元法，这个解法在参考文献[4]里有详细介绍。该方程最多可能有四个解，我们可以使用验证点来计算最可能的解，得到<script type="math/tex">A,B,C</script>在相机坐标系下的3D坐标，之后使用ICP计算相机的位姿<script type="math/tex">R,t</script>。</p>
<p>P3P利用3个点的几何关系，通过三对点已知的世界坐标系下的3D坐标以及相应点在相机归一化平面上投影的2D坐标，可以通过构建方程得到三个点在相机坐标系下的3D坐标，之后将问题转化为3D-3D的ICP问题，由于带有匹配信息的3D-3D位姿求解非常容易，所以这种方法是有效的。</p>
<p>但P3P同样存在一些问题：</p>
<ul>
<li>P3P值利用3个点的信息，当给定的匹配点多于3组时，难以利用更多的信息。</li>
<li>如果3D点或2D点受到噪声影响，或者存在误匹配，则算法失效。</li>
</ul>
<h3 id="2-3-EPnP"><a href="#2-3-EPnP" class="headerlink" title="2.3 EPnP"></a>2.3 EPnP</h3><p>EPnP的思路和P3P差不多，相对P3P来说，EPnP利用更多的信息，用迭代的方式对相机位姿进行优化，以尽可能消除噪声的影响。但主体思路都是先得到相应点在相机坐标系下的坐标，将3D-2D问题转换为3D-3D问题，再利用ICP求解。</p>
<p>EPnP算法利用已知的<script type="math/tex">n</script>个3D点的世界坐标，通过PCA选择4个控制点(世界坐标已知)，建立新的局部坐标系，从而将3D点的世界坐标用新的控制点(世界坐标)表示出来。然后，利用相机投影模型和2D点像素坐标，建立关于控制点在相机坐标系下坐标的线性方程组，求解出4个控制点在相机坐标系下的坐标，进而求解出<script type="math/tex">n</script>个3D点在相机坐标系下的坐标。到了这里，我们已知<script type="math/tex">n</script>个3D点在世界坐标系下和相机坐标系下的坐标，问题转换为3D-3D问题，利用ICP求解即可。</p>
<p>在本节中:</p>
<ul>
<li>所有<script type="math/tex">n</script>个3D参考点在世界坐标系下的坐标分别为<script type="math/tex">\boldsymbol{p}^w_i,i=1,2,...,n</script></li>
<li>在相机坐标系下的坐标分别为<script type="math/tex">\boldsymbol{p}^c_i,i=1,2,...,n</script></li>
<li>我们选择的4个控制点在世界坐标系下的坐标分别为<script type="math/tex">\boldsymbol{c}^w_j,j=1,2,3,4</script> </li>
<li>4个控制点在相机坐标系下的坐标分别为<script type="math/tex">\boldsymbol{c}^c_j,j=1,2,3,4</script> </li>
</ul>
<p>EPnP将<script type="math/tex">n</script>个参考点中的每一个表示为4个控制点的加权和：</p>
<p>​                                                       $$\boldsymbol{p}^w_i=\sum_{j=1}^{4}\alpha _{ij}\boldsymbol{c}^w_j,\quad with \quad\sum_{j=1}^{4}\alpha _{ij}=1$$</p>
<p>同理，相机坐标系下也有：</p>
<p>​                                                       $$\boldsymbol{p}^c_i=\sum_{j=1}^{4}\alpha _{ij}\boldsymbol{c}^c_j,\quad with \quad\sum_{j=1}^{4}\alpha _{ij}=1$$</p>
<p><script type="math/tex">n</script>个参考点的世界坐标<script type="math/tex">\boldsymbol{p}^w_i</script>我们是已知的，四个参考点是我们人为选择的，其世界坐标<script type="math/tex">\boldsymbol{c}^w_j</script>可以认为是已知的，加权系数<script type="math/tex">\alpha_{ij}</script>可以利用参考点和控制点的世界坐标很方便的计算出来。那么唯一需要我们计算的未知量就是4个控制点在相机坐标系下的坐标，其可以根据相机投影模型和<script type="math/tex">n</script>个参考点的2D像素坐标构建线性方程组计算。之后我们便得到了<script type="math/tex">n</script>个参考点在世界坐标系和相机坐标系下的坐标，问题便被转化为ICP问题。</p>
<p>接下来我们依次解决上面一段所述EPnP算法框架中的细节问题：</p>
<ul>
<li>关系<script type="math/tex">\boldsymbol{p}^c_i=\sum_{j=1}^{4}\alpha _{ij}\boldsymbol{c}^c_j</script>为什么成立？</li>
<li>为什么控制点要选择4个？</li>
<li>4个控制点该如何选择？</li>
<li>4个控制点在相机坐标系下的坐标如何计算？</li>
</ul>
<p>由于 ：$$\boldsymbol{p}^c_i=\begin{pmatrix}R&\boldsymbol{t}\end{pmatrix}\begin{pmatrix}\boldsymbol{p}^w_i\\1\end{pmatrix}=\begin{pmatrix}R&\boldsymbol{t}\end{pmatrix}\begin{pmatrix}\sum_{j=1}^{4}\alpha_{ij}\boldsymbol{c}^w_j\\1\end{pmatrix}= \begin{pmatrix}R&\boldsymbol{t}\end{pmatrix}\begin{pmatrix}\sum_{j=1}^{4}\alpha_{ij}\boldsymbol{c}^w_j\\\sum_{j=1}^{4}\alpha _{ij}\end{pmatrix}=\sum_{j=1}^{4}\alpha _{ij}\begin{pmatrix}R&\boldsymbol{t}\end{pmatrix}\begin{pmatrix}\boldsymbol{c}^w_j\\1\end{pmatrix}=\sum_{j=1}^{4}\alpha _{ij}\boldsymbol{c}^c_j$$</p>
<p>因此关系<script type="math/tex">\boldsymbol{p}^c_i=\sum_{j=1}^{4}\alpha _{ij}\boldsymbol{c}^c_j</script>成立，在上面的推导过程中，我们用到了非常重要的约束条件<script type="math/tex">\sum_{j=1}^{4}\alpha _{ij}=1</script>。如果没有这个约束条件，上述推导将不成立，我们也无法得到相机坐标系下参考点和控制点的关系。</p>
<p>正是由于约束条件<script type="math/tex">\sum_{j=1}^{4}\alpha _{ij}=1</script>必须被精确的满足，我们在选择控制点时必须选择4个而不是3个。</p>
<p>假如我们仅选择3个控制点，那么我们可以列出方程：$$\boldsymbol{p}^w_i=\begin{pmatrix}X^W_i\\Y^W _i\\Z^W_i\end{pmatrix}=\begin{pmatrix}\boldsymbol{c}^w_1&\boldsymbol{c}^w_2 &\boldsymbol{c}^w_3\end{pmatrix}\begin{pmatrix}\alpha_{i1}\\\alpha_{i2}\\\alpha_{i3}\end{pmatrix}$$</p>
<p> 且 $$\sum_{j=1}^{3}\alpha _{ij}=1$$</p>
<p>一共三个未知量确有四个方程，这是一个超定方程组，只存在最小二乘意义上的解。换句话，在一般情形下，不存在精确满足4个方程的解。即约束不一定能被精确的满足。</p>
<p>在选择4个控制点的情形下：$$\begin{pmatrix}\boldsymbol{p}^w_i\\1\end{pmatrix}=\begin{pmatrix}X^W_i\\Y^W _i\\Z^W_i\\1\end{pmatrix}=\begin{pmatrix}\boldsymbol{c}^w_1&\boldsymbol{c}^w_2 &\boldsymbol{c}^w_3&\boldsymbol{c}^w_4\\1&1&1&1\end{pmatrix}\begin{pmatrix}\alpha_{i1}\\\alpha_{i2}\\\alpha_{i3}\\\alpha_{i4}\end{pmatrix}=C\begin{pmatrix}\alpha_{i1}\\\alpha_{i2}\\\alpha_{i3}\\\alpha_{i4}\end{pmatrix}$$</p>
<p>可以精确解出： $$\begin{pmatrix}\alpha_{i1}\\\alpha_{i2}\\\alpha_{i3}\\\alpha_{i4}\end{pmatrix}=C^{-1}\begin{pmatrix}\boldsymbol{p}^w_i\\1\end{pmatrix}$$</p>
<p>在选择控制点时，原则上只要矩阵<script type="math/tex">C</script>可逆即可，四个控制点不共面即可。参考文献[5]中给出了更加精细选择控制点的方法，可以参考。</p>
<p>之后我们进行最重要的一步，即计算4个控制点在相机坐标系下的坐标：</p>
<p>由相机模型，我们可以得到： $$\omega_i\begin{pmatrix}u_i\\v_i \\1\end{pmatrix}=\begin{pmatrix}f_x& 0 &c_x \\0&f_y  &c_y \\0 & 0 &1\end{pmatrix} \sum_{j=1}^{4}\alpha _{ij}\begin{pmatrix}x^c_j\\y^c_j \\z^c_j\end{pmatrix}$$</p>
<p>上式中有<script type="math/tex">\boldsymbol{c}^c_j=(x^c_j,y^c_j,z^c_j)^T</script>。我们可以得到两个线性方程：$$\sum_{j=1}^4\alpha _{ij}f_xx_j^c+\alpha _{ij}(c_x-u_i)z^c_j=0$$ $$\sum_{j=1}^4\alpha _{ij}f_yy_j^c+\alpha _{ij}(c_y-v_i)z^c_j=0$$</p>
<p>把所有<script type="math/tex">n</script>个点结合起来，可以得到关于4个控制点共12个坐标的线性方程组，解数值方程。最后还需要利用空间点在外参变换下，空间关系不改变的约束，即<script type="math/tex">||\boldsymbol{c}^w_i-\boldsymbol{c}^w_j||^2=||\boldsymbol{c}^c_i-\boldsymbol{c}^c_j||^2</script>，结合非线性优化来得到最终的控制点在相机坐标系下的坐标。</p>
<p>得到4个控制点在相机坐标系下的坐标之后，我们便可以计算<script type="math/tex">n</script>个参考点在相机坐标系下的坐标。有了<script type="math/tex">n</script>个3D参考点在相机坐标系和世界坐标系下的坐标之后，我们将问题转化为3D-3D问题，利用ICP求解即可。</p>
<h3 id="2-4-光束法平差（BA，Bundle-Adjustment）"><a href="#2-4-光束法平差（BA，Bundle-Adjustment）" class="headerlink" title="2.4 光束法平差（BA，Bundle Adjustment）"></a>2.4 光束法平差（BA，Bundle Adjustment）</h3><p>上面的方法都是线性的，我们还可以把PnP问题构建为一个关于重投影误差的非线性最小二乘问题。线性方法往往是通过将空间点的位置看做已知量，通过构建方程组求解相机位姿。而非线性优化则将相机位姿和空间点位置都看成优化变量，放在一起优化，这也是BA的另一个名字：捆集优化的由来(个人理解)。这种方法将相机位姿和三维点位置放在一起进行重投影误差最小化的优化，是一种整体的优化方法。</p>
<p>假设我们有n个三维空间点，其世界坐标系下的坐标为<script type="math/tex">\boldsymbol{P}^W_i=[X^W_i,Y^W_i,Z^W_i]^T(i=1,2,...,n)</script>，相应点在像素坐标系下的齐次坐标为<script type="math/tex">\boldsymbol{p}_i=[u_i,v_i,1]^T(i=1,2,...,n)</script>。假设相机位姿已知且观测点没有噪声，则两者之间存在以下关系：$$\omega_i\begin{pmatrix}u_i\\v_i \\1\end{pmatrix} =\boldsymbol{KT}\begin{pmatrix}X^W\\Y^W \\Z^W\\1\end{pmatrix}$$</p>
<p>其矩阵形式为： $$\omega_i \boldsymbol{p_i}=\boldsymbol{KTP}^W_i$$</p>
<p>上式中隐含了一次从齐次坐标到非齐次坐标的转换,其中<script type="math/tex">\omega_i</script>为点在相机坐标系下的深度，<script type="math/tex">K</script>为相机内参矩阵，<script type="math/tex">T</script>为世界坐标系到相机坐标系的变换矩阵。</p>
<p>但由于相机位姿未知以及观测点存在一定噪声误差，该式并不严格成立。因此，为了求解出最优的相机位姿，我们构建最小二乘问题，将<script type="math/tex">n</script>个观测点对应的误差求和，寻找最优的相机位姿，使得总的误差最小化：$$\boldsymbol{T^*}=\underset{\boldsymbol{T}}{argmin}\frac{1}{2}\sum_{i=1}^n||\boldsymbol{p_i}-\frac{1}{\omega_i }\boldsymbol{KTP}^W_i||^2$$</p>
<p>上式中的误差，是将<strong>观测</strong>到的像素坐标系下的投影坐标与通过相机位姿和3D点位置<strong>计算</strong>得到的像素坐标系下的投影坐标做差，称为重投影误差。一般来说，我们计算误差时使用非齐次坐标，即像素坐标系两个轴方向上的误差，故误差只有两维。在实际问题中，我们通过特征匹配得到了像素坐标系下的<script type="math/tex">\boldsymbol{p}_i</script>和世界坐标系下的<script type="math/tex">\boldsymbol{P}^W_i</script>是同一个空间点的两种不同表达形式，但是不知道相机位姿<script type="math/tex">T</script>，所以一开始观测到的像素坐标<script type="math/tex">\boldsymbol{p}_i</script>和通过位姿计算投影得到的计算值<script type="math/tex">\frac{1}{\omega_i }\boldsymbol{KTP}^W_i</script>并不重合，两者之间有一定的距离，我们通过调整相机位姿的估计值，使得这个距离变小。因为我们有很多对空间点的匹配关系，这个相机位姿估计值的调整需要同时考虑很多对点，这也就使得最后的效果是整体误差的缩小，而每一对点的误差都不会精确为0。</p>
<p>在调整相机位姿的估计值使得整体误差变小的过程中，最重要的是要知道误差相对于相机位姿的导数，知道了导数才能确定相机位姿估计值调整的方向，导数即误差项关于优化变量的导数，也就是线性化： $$\boldsymbol{e(x+\Delta x)\approx e(x)+J^T\Delta x}$$</p>
<p>其中的雅克比矩阵<script type="math/tex">\boldsymbol{J^T}</script>的解析形式是问题的关键。目前，<script type="math/tex">\boldsymbol{e}</script>为像素误差(2维)，<script type="math/tex">\boldsymbol{x}</script>为相机位姿(6维)，<script type="math/tex">\boldsymbol{J^T}</script>是一个<script type="math/tex">2\times 6</script>的矩阵。</p>
<p>之后将应用扰动模型来通过李代数求解误差相对于位姿的导数。由于旋转矩阵自身带有约束，作为优化变量会引入额外的约束，使问题变得困难。通过李群—李代数之间的转换关系，我们可以把位姿估计变成无约束的优化问题，简化求解方式。</p>
<p>记空间点在相机坐标系下的坐标为<script type="math/tex">P^C=[X^C,Y^C,Z^C]^T</script>，则有<script type="math/tex">\omega \boldsymbol{p}=KP^C</script>，利用相机模型可知：$$u_{cal}=f_x\frac{X^C}{Z^C}+c_x,v_{cal}=f_y\frac{Y^C}{Z^C}+c_y$$ </p>
<p>上式中的<script type="math/tex">u,v</script>均为根据相机位姿计算而来的像素坐标，通过下标表明。我们定义的误差为观测值减计算值(预测值)，即$$\boldsymbol{e}=\begin{pmatrix}u_{measure}-u_{calculate}\\v_{measure}-v_{calculate} \end{pmatrix}=\begin{pmatrix}u_{measure}-f_x\frac{X^C}{Z^C}-c_x\\v_{measure}-f_y\frac{Y^C}{Z^C}-c_y \end{pmatrix}$$</p>
<p>通过定义相机坐标系下坐标这一中间变量，我们可以很方便的通过链式法则求解误差的变化关于位姿扰动量的导数：$$\frac{\partial \boldsymbol{e}}{\partial \delta\boldsymbol{\xi}}=\frac{\partial \boldsymbol{e}}{\partial \boldsymbol{P}^C}\frac{\partial \boldsymbol{P}^C}{\partial \delta\boldsymbol{\xi}}$$ </p>
<p>上式中第一项是误差关于投影点的导数，根据上文相机模型中得到的关系，可得：$$\frac{\partial \boldsymbol{e}}{\partial \boldsymbol{P}^C}=-\begin{pmatrix}\frac{\partial u_{cal}}{\partial X^C}& \frac{\partial u_{cal}}{\partial Y^C} & \frac{\partial u_{cal}}{\partial Z^C} \\\frac{\partial v_{cal}}{\partial X^C}& \frac{\partial v_{cal}}{\partial Y^C} & \frac{\partial v_{cal}}{\partial Z^C}  \end{pmatrix}=-\begin{pmatrix}\frac{f_x}{Z^C}& 0 & -\frac{f_xX^C}{(Z^{C})^2}  \\0& \frac{f_y}{Z^C} & -\frac{f_yY^C}{(Z^{C})^2}  \end{pmatrix}$$</p>
<p>第二项为变换到相机坐标系后的点关于李代数的导数，可得：$$\frac{\partial \boldsymbol{P}^C}{\partial \delta\boldsymbol{\xi}}=\frac{\partial (\boldsymbol{TP}^W)}{\partial \delta\boldsymbol{\xi}}=(\boldsymbol{TP}^W)^{\odot}=\begin{pmatrix}\boldsymbol{I}& -(\boldsymbol{P}^C)^{\wedge }  \end{pmatrix}$$</p>
<p>注意我们采用的是非齐次坐标，所以上式中只保留了矩阵的前三维。</p>
<p>将上面两项相乘，就可以得到最终版<script type="math/tex">2\times 6</script> 的雅克比矩阵：$$\boldsymbol{J}^T=\frac{\partial \boldsymbol{e}}{\partial \delta\boldsymbol{\xi}}=-\begin{pmatrix}\frac{f_x}{Z^C}& 0 & -\frac{f_xX^C}{(Z^{C})^2} &-\frac{f_xY^CX^C}{(Z^{C})^2}&f_x+\frac{f_x(X^C)^2}{(Z^{C})^2}&-\frac{f_xY^C}{Z^C} \\0& \frac{f_y}{Z^C} & -\frac{f_yY^C}{(Z^{C})^2}  & -f_y-\frac{f_y(Y^C)^2}{(Z^{C})^2}&\frac{f_yY^CX^C}{(Z^{C})^2}&\frac{f_yX^C}{Z^C}\end{pmatrix}$$</p>
<p>上式中的雅克比描述了重投影误差关于相机位姿李代数的一阶变化关系。前面的负号是由于我们的误差是由观测值减计算值(预测值)定义的，如果反过来，将误差定义成“预测值减观测值”的形式，只需要去掉前面的负号即可。此外，如果李代数<script type="math/tex">se(3)</script>的定义方式是旋转在前，平移在后，则只需要将该矩阵的前3列与后3列对调即可。</p>
<p>除了优化相机位姿之外，我们还希望优化特征点的空间位置，因此还需要讨论误差<script type="math/tex">\boldsymbol{e}</script>关于空间点<script type="math/tex">\boldsymbol{P}^W</script>的导数，这个导数相对来说推导较为简单：$$\frac{\partial \boldsymbol{e}}{\partial \boldsymbol{P}^W}=\frac{\partial \boldsymbol{e}}{\partial \boldsymbol{P}^C}\frac{\partial \boldsymbol{P}^C}{\partial \boldsymbol{P}^W}$$</p>
<p>上式中第一项已经推出，推导第二项时，按照定义，有<script type="math/tex">\boldsymbol{P}^C=R\boldsymbol{P}^W+t</script>，则<script type="math/tex">\boldsymbol{P}^C</script>对<script type="math/tex">\boldsymbol{P}^W</script>求导之后只剩下<script type="math/tex">R</script>.</p>
<p>所以，我们得到误差向量关于空间点位置的导数为：$$\frac{\partial \boldsymbol{e}}{\partial \boldsymbol{P}^W}=-\begin{pmatrix}\frac{f_x}{Z^C}& 0 & -\frac{f_xX^C}{(Z^{C})^2}  \\0& \frac{f_y}{Z^C} & -\frac{f_yY^C}{(Z^{C})^2}  \end{pmatrix}\boldsymbol{R}$$</p>
<p>上面我们导出了重投影误差向量关于相机位姿与特征点位置的两个导数矩阵。这两个导数矩阵十分重要，能够在优化迭代调整相机位姿估计值的过程中，提供重中之重的梯度方向，指导优化的迭代。</p>
<p>下面是具体的优化迭代过程：</p>
<p>每一次迭代时，对于每一个空间点，先将空间点在世界坐标系下的坐标变换到相机坐标系下，在通过相机内参得到像素坐标的计算值，将像素坐标的观测值与计算值做差，得到误差向量<script type="math/tex">\boldsymbol{e}_i</script>，同时得到雅克比矩阵<script type="math/tex">\boldsymbol{J}^T_i</script>。对每个点计算出其对应的误差向量和雅克比矩阵之后，可以得到<script type="math/tex">\boldsymbol{H}=\sum_{i=1}^n\boldsymbol{J}_i\boldsymbol{J}^T_i</script>，<script type="math/tex">\boldsymbol{b}=-\sum_{i=1}^n\boldsymbol{J}_i\boldsymbol{e}_i</script>，通过解线性方程组<script type="math/tex">\boldsymbol{H}\boldsymbol{\Delta x}=\boldsymbol{b}</script>，得到位姿的变化量<script type="math/tex">\boldsymbol{\Delta x}</script>，则变化之后的位姿为：<script type="math/tex">\xi ^{'}=exp(\boldsymbol{\Delta x})\xi</script>，如此不断迭代，当<script type="math/tex">\boldsymbol{\Delta x}</script>范数足够小时停止迭代。</p>
<p>下面是高翔老师在《视觉SLAM14讲》中提供的手写Gauss-Newton法进行位姿估计的相关代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bundleAdjustmentGaussNewton</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-keyword">const</span> VecVector3d &amp;points_3d,</span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-keyword">const</span> VecVector2d &amp;points_2d,</span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-keyword">const</span> Mat &amp;K,</span></span><br><span class="hljs-params"><span class="hljs-function">  Sophus::SE3d &amp;pose)</span></span><br><span class="hljs-function">  </span>&#123;  <span class="hljs-comment">//传入空间点点，空间点像素坐标，内参; 初始pose,此程序中初始pose为0;</span><br>  <span class="hljs-keyword">typedef</span> Eigen::Matrix&lt;<span class="hljs-keyword">double</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>&gt; Vector6d;<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> iterations = <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">double</span> cost = <span class="hljs-number">0</span>, lastCost = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">double</span> fx = K.at&lt;<span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">double</span> fy = K.at&lt;<span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">double</span> cx = K.at&lt;<span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">double</span> cy = K.at&lt;<span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>      <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> iter = <span class="hljs-number">0</span>; iter &lt; iterations; iter++) &#123;  <span class="hljs-comment">//进行迭代</span><br>    Eigen::Matrix&lt;<span class="hljs-keyword">double</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>&gt; H = Eigen::Matrix&lt;<span class="hljs-keyword">double</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>&gt;::<span class="hljs-built_in">Zero</span>();<br>    Vector6d b = Vector6d::<span class="hljs-built_in">Zero</span>();<br>    cost = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// compute cost</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; points_3d.<span class="hljs-built_in">size</span>(); i++) &#123;<br>      Eigen::Vector3d pc = pose * points_3d[i];<span class="hljs-comment">//得到空间点在相机坐标系下的坐标</span><br>      <span class="hljs-comment">// Vector6d se3 = pose.log();</span><br>      <span class="hljs-comment">// cout&lt;&lt;&quot;se3 = &quot;&lt;&lt;se3.transpose()&lt;&lt;endl;一开始se3为0,三四次迭代后趋于稳定</span><br>      <span class="hljs-keyword">double</span> inv_z = <span class="hljs-number">1.0</span> / pc[<span class="hljs-number">2</span>];<br>      <span class="hljs-keyword">double</span> inv_z2 = inv_z * inv_z;<br>      <span class="hljs-function">Eigen::Vector2d <span class="hljs-title">proj</span> <span class="hljs-params">(fx * pc[<span class="hljs-number">0</span>] / pc[<span class="hljs-number">2</span>] + cx, fy * pc[<span class="hljs-number">1</span>] / pc[<span class="hljs-number">2</span>] + cy)</span></span>;<span class="hljs-comment">//P点像素坐标的投影计算值</span><br>      Eigen::Vector2d e = points_2d[i] - proj;<span class="hljs-comment">//作差，得到差值;是观测值-预测值！</span><br>      cost += e.<span class="hljs-built_in">squaredNorm</span>();<span class="hljs-comment">//误差的二范数的平方</span><br>      Eigen::Matrix&lt;<span class="hljs-keyword">double</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>&gt; J;<span class="hljs-comment">//2*6的雅克比矩阵，即误差相对于位姿求导，通过导数可以知道有了误差以后我们应该往哪个方向去优化</span><br>      J &lt;&lt; -fx * inv_z,<br>        <span class="hljs-number">0</span>,<br>        fx * pc[<span class="hljs-number">0</span>] * inv_z2,<br>        fx * pc[<span class="hljs-number">0</span>] * pc[<span class="hljs-number">1</span>] * inv_z2,<br>        -fx - fx * pc[<span class="hljs-number">0</span>] * pc[<span class="hljs-number">0</span>] * inv_z2,<br>        fx * pc[<span class="hljs-number">1</span>] * inv_z,<br>        <span class="hljs-number">0</span>,<br>        -fy * inv_z,<br>        fy * pc[<span class="hljs-number">1</span>] * inv_z,<br>        fy + fy * pc[<span class="hljs-number">1</span>] * pc[<span class="hljs-number">1</span>] * inv_z2,<br>        -fy * pc[<span class="hljs-number">0</span>] * pc[<span class="hljs-number">1</span>] * inv_z2,<br>        -fy * pc[<span class="hljs-number">0</span>] * inv_z;<br>      H += J.<span class="hljs-built_in">transpose</span>() * J;<span class="hljs-comment">//高斯牛顿方法，H*dx=b</span><br>      b += -J.<span class="hljs-built_in">transpose</span>() * e;<br>    &#125;<br>    Vector6d dx;<br>    dx = H.<span class="hljs-built_in">ldlt</span>().<span class="hljs-built_in">solve</span>(b);<span class="hljs-comment">//对H做LDLT分解，并求解dx</span><br>    cout &lt;&lt;<span class="hljs-string">&quot;dx:&quot;</span> &lt;&lt; endl &lt;&lt; dx &lt;&lt;endl;<br>    cout &lt;&lt;<span class="hljs-string">&quot;dx.norm():&quot;</span> &lt;&lt; endl &lt;&lt; dx.<span class="hljs-built_in">norm</span>() &lt;&lt;endl;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isnan</span>(dx[<span class="hljs-number">0</span>])) &#123;<br>      cout &lt;&lt; <span class="hljs-string">&quot;result is nan!&quot;</span> &lt;&lt; endl;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (iter &gt; <span class="hljs-number">0</span> &amp;&amp; cost &gt;= lastCost) &#123;<br>      <span class="hljs-comment">// cost increase, update is not good//发散的情况</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;cost: &quot;</span> &lt;&lt; cost &lt;&lt; <span class="hljs-string">&quot;, last cost: &quot;</span> &lt;&lt; lastCost &lt;&lt; endl;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// update your estimation</span><br>    pose = Sophus::SE3d::<span class="hljs-built_in">exp</span>(dx) * pose;<br>    lastCost = cost;<br>    cout &lt;&lt; <span class="hljs-string">&quot;iteration &quot;</span> &lt;&lt; iter &lt;&lt; <span class="hljs-string">&quot; cost=&quot;</span> &lt;&lt; cout.<span class="hljs-built_in">precision</span>(<span class="hljs-number">12</span>) &lt;&lt; cost &lt;&lt; endl;<br>    <span class="hljs-keyword">if</span> (dx.<span class="hljs-built_in">norm</span>() &lt; <span class="hljs-number">1e-6</span>) &#123;<br>      <span class="hljs-comment">// converge 当dx&lt;1e-6时停止迭代</span><br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  cout &lt;&lt; <span class="hljs-string">&quot;pose by g-n: \n&quot;</span> &lt;&lt; pose.<span class="hljs-built_in">matrix</span>() &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-5-四种算法总结"><a href="#2-5-四种算法总结" class="headerlink" title="2.5 四种算法总结"></a>2.5 四种算法总结</h3><p>每种算法用一句话概括：</p>
<ul>
<li>DLT：根据<script type="math/tex">n</script>个点的世界坐标和相机归一化平面坐标，最后一行用于消去深度，得到<script type="math/tex">2n</script>个约束方程，利用SVD求解超定方程并得到位姿矩阵的估计。</li>
<li>P3P：根据3个点的世界坐标和相机归一化平面坐标，利用余弦定理几何关系，得到3个点的相机坐标，将问题转化为3D-3D位姿估计并利用ICP求解，最后还需要一对点用于验证。</li>
<li>EPnP：根据<script type="math/tex">n</script>个点的世界坐标选择4个控制点并计算加权系数，通过相机模型和<script type="math/tex">n</script>个点的像素坐标求解4个控制点在相机坐标系下的坐标，进而得到<script type="math/tex">n</script>个点在相机坐标系下的坐标，将问题转化为3D-3D位姿估计并利用ICP求解。</li>
<li>BA：根据对应点的重投影误差构建非线性优化问题，利用李代数得到误差关于位姿的导数以指导优化方向，不断迭代求得所有对应点重投影误差之和最小的位姿估计。</li>
</ul>
<h2 id="3-一些数学"><a href="#3-一些数学" class="headerlink" title="3 一些数学"></a>3 一些数学</h2><h3 id="3-1-动机引入"><a href="#3-1-动机引入" class="headerlink" title="3.1 动机引入"></a>3.1 动机引入</h3><p>在计算机视觉中进行相机的位姿估计时，无论是2D-2D，3D-2D还是3D-3D，大多都有线性和非线性两种解法。线性的求解大多利用线性代数作为工具，其中最主要的还是<strong>SVD</strong>(奇异值分解)；非线性优化则大多需要求解误差关于位姿的导数，这时利用<strong>李代数</strong>将位姿估计变成无约束的优化问题，可以方便问题的求解。因此，在理解了算法的大致思想和工程应用之后，还是有必要在数学方面进行更加深入的学习和理解。</p>
<h3 id="3-2-关于SVD的一些理解"><a href="#3-2-关于SVD的一些理解" class="headerlink" title="3.2 关于SVD的一些理解"></a>3.2 关于SVD的一些理解</h3><h3 id="3-3-关于李群李代数的一些理解"><a href="#3-3-关于李群李代数的一些理解" class="headerlink" title="3.3 关于李群李代数的一些理解"></a>3.3 关于李群李代数的一些理解</h3><h3 id="3-4-关于g2o与图优化"><a href="#3-4-关于g2o与图优化" class="headerlink" title="3.4 关于g2o与图优化"></a>3.4 关于g2o与图优化</h3><h2 id="4-参考文献"><a href="#4-参考文献" class="headerlink" title="4 参考文献"></a>4 参考文献</h2><p>[1]《视觉SLAM14讲》</p>
<p>[2]《计算机视觉中的多视图几何》</p>
<p>[3] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/58648937?edition=yidianzixun">https://zhuanlan.zhihu.com/p/58648937?edition=yidianzixun</a> (一篇关于DLT的很详细的文章)</p>
<p>[4]<a target="_blank" rel="noopener" href="https://www.cnblogs.com/mafuqiang/p/8302663.html">https://www.cnblogs.com/mafuqiang/p/8302663.html</a> (详细介绍了很多P3P求解中的细节)</p>
<p>[5]<a target="_blank" rel="noopener" href="https://blog.csdn.net/jessecw79/article/details/82945918">https://blog.csdn.net/jessecw79/article/details/82945918</a> (关于EPnP的一篇很详细的文章)</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Algorithum/">Algorithum</a>
                    
                      <a class="hover-with-bg" href="/tags/SLAM/">SLAM</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/12/01/%E5%85%A8%E7%8A%B6%E6%80%81%E5%8F%8D%E9%A6%88%E6%8E%A7%E5%88%B6%E7%8E%87LQR%E5%9C%A8%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E6%96%B9%E9%9D%A2%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">LQR最优控制在电机控制方面的实际应用</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  










  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
