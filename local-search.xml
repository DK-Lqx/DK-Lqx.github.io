<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>非线性规划学习笔记：An Overview</title>
    <link href="/2021/12/10/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_An_Overveiw/"/>
    <url>/2021/12/10/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_An_Overveiw/</url>
    
    <content type="html"><![CDATA[<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h2><p>最近快到期末了，认真的看了一下翟桥柱老师的运筹学课件，老师的课件做的详实且富有启发性。在阅读的时候不仅让我建立起了很多直观上的感受，并且跟随老师的步伐完成了大部分定理的证明。完成证明的时候深深感受到了数学这门学科的精妙，线性代数和多元函数微积分理论的优美，以及自己数学功底依然很薄弱的这个事实。遗憾的是，运筹学这门课的学时实在过于短暂，导致翟老师没有机会给我们讲解更多优美的算法和理论。为了对最优化理论有更加全面的理解，建立对于Optimization这门课程的整体认知，我又去看了《最优化导论》这本教材，其中介绍了更多的算法，并包括了更多定理证明的细节。在看这本书的时候，一些精妙的观点常常让我有醍醐灌顶之感，大部分精妙的数学证明又让我拍案叫绝，在同线性代数和多元函数微积分作斗争的时候，我仿佛又回到了大一那段沉迷数学的快乐时光，现在想来，我已经很久没有享受过陶醉于数学之美的那种快感了。感谢Optimization这门学科，让我没有捷径可走，只能直面数学，感受数学之美。最近埋头苦学最优化理论，看了很多书和论文，便想着写这一系列的学习笔记，总结一些自己的感悟，记录一些数学。</p><p>为什么题目叫非线性规划呢，是因为非线性规划不仅是Optimization最优化理论的核心，也在机器人学里得到了大量的应用，比如说trajectory optimization问题中的direct collocation method就是将积分离散化并转化为一个非线性规划得到求解。而且相对于线性规划来说，非线性规划更加困难也更加富有挑战性，常常要根据具体问题的特点选择不同的算法，因此对于不同问题和算法的特点都要有详细的了解，并且这种详细了解最好是数学的而非直觉的(因为要发论文的话数学一定要好…..)。</p><p>补充一点，优化理论真的是太重要了，在我感兴趣的领域内，微观和宏观经济学大量使用了最优化理论来解决资源配置和政策优化问题；机器人学中轨迹规划和最优控制都用到了非线性规划和动态规划等工具；机器学习和神经网络的基础更是非线性优化理论。因此，在我大三的时候写下这篇最优化理论学习笔记，就像最优化理论阐述的一样，希望能作为一个好的初始点，作为一个好的迭代起点，在之后学习最优化理论的优化迭代中，还有更加高级的数学理论等着我去学习，还要更加深入的学习凸优化、数值优化、随机优化等理论，并在经济学和机器人学等学科中去应用，去实践。前路漫漫，加油吧！</p><p>在这放上几本我正在看或者以后一定会看的优化领域的好书镇楼，也算激励一下自己：</p><center class="half">    <img src="/img/NLP/好书1.jpg" width="80"/>    <img src="/img/NLP/好书2.jpeg" width="120"/>    <img src="/img/NLP/好书3.jpg" width="80"/>    <img src="/img/NLP/好书4.jpg" width="90"/>    <img src="/img/NLP/好书5.jpg" width="90"/></center><h2 id="2-问题描述"><a href="#2-问题描述" class="headerlink" title="2 问题描述"></a>2 问题描述</h2><p>一般的非线性规划问题可以描述为：$$\min \ \  f(\boldsymbol{x})$$ $$ s.t. \ \ \ \ \ g_i(\boldsymbol{x})\le0\ , i=1,2,\cdot\cdot\cdot,p$$ $$ \ \ \ \ \ \ \ \ \ \ \ \ h_i(\boldsymbol{x})=0\ , i=1,2,\cdot\cdot\cdot,m$$ $$ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \boldsymbol{x}\in \mathbb{R}^n$$</p><p>其中，函数$f:\mathbb{R}^n\to\mathbb{R}$称为目标函数或价值函数，该优化问题的含义为寻找合适的<script type="math/tex">\boldsymbol{x}</script>，使函数$f(\boldsymbol{x})$达到最小。<script type="math/tex">\boldsymbol{x}</script>是一个<script type="math/tex">n</script>维向量，通常称为决策向量，其需要同时满足等式约束<script type="math/tex">h_i(\boldsymbol{x})=0\ , i=1,2,\cdot\cdot\cdot,m</script>和不等式约束<script type="math/tex">g_i(\boldsymbol{x})\le0\ , i=1,2,\cdot\cdot\cdot,p</script>。</p><p>约束可以写成向量形式：                           $$\boldsymbol{g}(\boldsymbol{x})\le\boldsymbol{0} \ , \ \boldsymbol{h}(\boldsymbol{x})=\boldsymbol{0}$$</p><p>其中：                                                   $$\boldsymbol{h}:\mathbb{R}^n\to\mathbb{R}^m \ , \ \boldsymbol{g}:\mathbb{R}^n\to\mathbb{R}^p$$</p><p>研究和学习的过程的总是从特殊到一般的过程，因此我们不会在一开始就直面这么复杂的问题，而是要循序渐进，从最简单的情形开始研究，逐渐改变目标函数和约束的形式，最终得到最一般问题的求解方法。其中，每一种问题都有独特的结构和特色，利用这些结构和特色就可以发展出针对相应问题的最优算法。</p><p>故事的起点，是无约束或者集合约束优化问题：$$\min  \ \ \ \ \ f(\boldsymbol{x})$$ $$ s.t. \ \ \ \ \boldsymbol{x}\in \Omega$$</p><p>其中约束集合<script type="math/tex">\Omega</script>是<script type="math/tex">n</script>维实数空间<script type="math/tex">\mathbb{R}^n</script>的一个子集。约束<script type="math/tex">\boldsymbol{x}\in \Omega</script>称为集合约束，上面提到的一般形式的约束集合<script type="math/tex">\Omega=\{ \boldsymbol{x}:\boldsymbol{g}(\boldsymbol{x})\le\boldsymbol{0} \ , \ \boldsymbol{h}(\boldsymbol{x})=\boldsymbol{0}\}</script>称为函数约束。由于集合约束比较简单，而且有一些很好的性质，所以有大量的算法都是针对于集合约束形式的，在一开始我们会先研究集合约束和无约束优化问题，这是一个很好的起点，后面更加复杂问题的算法很多也是基于无约束优化问题的算法进行改进。我们会先探讨局部极小点对应的必要条件和充分条件，以及在迭代过程中很重要的一维搜索算法，并讨论梯度方法、牛顿法、共轭方向法、拟牛顿法等多种求解算法，这些算法各有特色，使用时应根据问题的特点进行选择。</p><p>之后我们会研究有约束优化问题：$$\min \ \  f(\boldsymbol{x})$$ $$ s.t. \ \ \ \ \ g_i(\boldsymbol{x})\le0\ , i=1,2,\cdot\cdot\cdot,p$$ $$ \ \ \ \ \ \ \ \ \ \ \ \ h_i(\boldsymbol{x})=0\ , i=1,2,\cdot\cdot\cdot,m$$ $$ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \boldsymbol{x}\in \mathbb{R}^n$$</p><p>本着循序渐进的原则，我们会先研究仅含等式约束的优化问题，展示局部极小点的一阶必要条件(拉格朗日条件)，以及二阶必要条件和充分条件。之后来到同时含义等式约束和不等式约束的优化问题，展示局部极小点的一阶必要条件(KKT条件)，以及二阶必要条件和充分条件。并研究相关的求解算法：投影法、拉格朗日法、罚函数法等。</p><h2 id="3-核心问题"><a href="#3-核心问题" class="headerlink" title="3 核心问题"></a>3 核心问题</h2><h3 id="3-1-算法框架"><a href="#3-1-算法框架" class="headerlink" title="3.1 算法框架"></a>3.1 算法框架</h3><p>在求解非线性规划的问题中，我们没有办法直接根据局部极小点的必要条件进行求解，因为那样就相当于直接求解大规模的非线性方程组，我们必须将问题转化为有限次运算可以解决的问题。所以说，我们必须放弃求解析解的想法，转而求解数值最优解。</p><p>一种朴实的想法如下：</p><p>我们先选择<script type="math/tex">\mathbb{R}^n</script>中的一个点作为起始点，然后依据某种迭代准则选取一个可以使目标函数下降的方向，沿着这个方向走一定的距离，到达一个新的位置，接着重复上述过程，选择一个下降方向，朝着这个方向走一定的距离以使目标函数下降，如此往复，直到满足停止准则（如局部极小点的必要条件得到满足），停止迭代，即认为得到了最优点。</p><p>用数学公式表述如下：$$\boldsymbol{x}^{(0)}\to \boldsymbol{x}^{(1)}\to \boldsymbol{x}^{(2)}\to \cdot\cdot\cdot\cdot\cdot\to\boldsymbol{x}^{(K)}$$</p><p>在从一个点迭代到下一个点的过程中，基本上所有非线性优化算法都采用相同的迭代框架：$$\boldsymbol{x}^{(k+1)}=\boldsymbol{x}^{(k)}+t_k\boldsymbol{p}^{(k)}$$</p><p>从上式中可以看出，在学习算法的过程中我们比较关心的问题有两个：</p><ul><li>搜索方向<script type="math/tex">\boldsymbol{p}^{(k)}</script>的确定：为不同算法讨论的核心问题</li><li>搜索步长<script type="math/tex">t_k</script>的确定：采用一维搜索算法得到解决</li></ul><p>求解非线性规划的迭代下降算法框架为：</p><ul><li><p>Step1：   产生初始点<script type="math/tex">\boldsymbol{x}^{(0)}\in\Omega</script>或<script type="math/tex">\boldsymbol{x}^{(0)}\in\mathbb{R}^n</script>，初始化<script type="math/tex">k=0</script></p></li><li><p>Step2：   由<script type="math/tex">\boldsymbol{x}^{(k)}</script>产生<script type="math/tex">\boldsymbol{x}^{(k+1)}</script>，并令<script type="math/tex">k:=k+1</script></p><p>​                  一般<script type="math/tex">\boldsymbol{x}^{(k+1)}=\boldsymbol{x}^{(k)}+t_k\boldsymbol{p}^{(k)}</script></p><p>​                  核心为构造<script type="math/tex">\boldsymbol{p}^{(k)}</script>并选择合适的<script type="math/tex">t_k</script></p></li><li><p>Step3：判断<script type="math/tex">\boldsymbol{x}^{(k)}</script>是否可接受，是则停止迭代，否则转Step2</p></li></ul><h3 id="3-2-关键问题"><a href="#3-2-关键问题" class="headerlink" title="3.2 关键问题"></a>3.2 关键问题</h3><p>翟老师在课上总结了非线性规划的六个关键问题，总结的简直太好了，只有把一个算法的这六个问题搞懂了，才算是真正弄懂了这个算法。故摘录如下，在接下来的文章中也是按照这个顺序一一总结各个算法的相应特色。</p><p>在研究和学习非线性规划时面临的六个关键问题如下：</p><ul><li>(局部)最优解有哪些性质？如何判定？</li><li>什么样的全局性质可以使得寻找全局最优解比较容易？</li><li>怎样构造(可行的)下降方向<script type="math/tex">\boldsymbol{p}^{(k)}</script>？</li><li>怎样确定步长<script type="math/tex">t_k</script>？</li><li>怎样确定初始点<script type="math/tex">\boldsymbol{x}^{(0)}</script>？</li><li>算法的终止准则？</li></ul><p>下面会从这六个方面入手总结各个算法的特点。</p><h2 id="4-局部最优解的性质"><a href="#4-局部最优解的性质" class="headerlink" title="4 局部最优解的性质"></a><strong>4 局部最优解的性质</strong></h2><h3 id="4-1-无约束优化"><a href="#4-1-无约束优化" class="headerlink" title="4.1 无约束优化"></a>4.1 无约束优化</h3><p>回顾一下，无约束优化和集合约束的问题为：$$\min  \ \ \ \ \ f(\boldsymbol{x})$$ $$ s.t. \ \ \ \ \boldsymbol{x}\in \Omega$$</p><h4 id="4-1-1-一阶必要条件"><a href="#4-1-1-一阶必要条件" class="headerlink" title="4.1.1 一阶必要条件"></a>4.1.1 一阶必要条件</h4><p>假设局部极小点位于在约束集<script type="math/tex">\Omega</script>的内部，则极小点满足的一阶必要条件为：$$\nabla f(\boldsymbol{x}^*)=\boldsymbol{0}$$</p><h4 id="4-1-2-二阶必要条件"><a href="#4-1-2-二阶必要条件" class="headerlink" title="4.1.2 二阶必要条件"></a>4.1.2 二阶必要条件</h4><p>假设局部极小点位于在约束集<script type="math/tex">\Omega</script>的内部，则极小点满足的二阶必要条件为：$$\nabla f(\boldsymbol{x}^*)=\boldsymbol{0}$$   $$\nabla^2 f(\boldsymbol{x}^*)\ge0$$</p><p>即<script type="math/tex">f(\boldsymbol{x})</script>的Hessian矩阵<script type="math/tex">\nabla^2 f(\boldsymbol{x})</script>在<script type="math/tex">\boldsymbol{x}^*</script>处是半正定的。</p><h4 id="4-1-3-二阶充分条件"><a href="#4-1-3-二阶充分条件" class="headerlink" title="4.1.3 二阶充分条件"></a>4.1.3 二阶充分条件</h4><p>若<script type="math/tex">\boldsymbol{x}^*</script>是约束集的一个内点，且同时满足：$$\nabla f(\boldsymbol{x}^*)=\boldsymbol{0}$$ $$\nabla^2 f(\boldsymbol{x}^*)>0$$  </p><p>即<script type="math/tex">\boldsymbol{x}^*</script>处<script type="math/tex">f(\boldsymbol{x})</script>的梯度为0且Hessian矩阵为正定，则<script type="math/tex">\boldsymbol{x}^*</script>是函数<script type="math/tex">f</script>的一个严格局部极小点。                                         </p><h3 id="4-2-等式约束"><a href="#4-2-等式约束" class="headerlink" title="4.2 等式约束"></a>4.2 等式约束</h3><p>本节将研究以下形式约束问题局部极小点对应的条件：</p><p>​                                                                         $$\min  \ \ \ \ \ \ \ \ f(\boldsymbol{x})$${% raw %}{% endraw %}<script type="math/tex">s.t. \ \ \ \ \boldsymbol{h}(\boldsymbol{x})=\boldsymbol{0}</script></p><p>在讨论含有等式约束的优化问题时，有一个很重要的概念叫做正则点，在正则点处，所有等式约束的梯度向量线性无关，即<script type="math/tex">\nabla h_1(\boldsymbol{x}),\nabla h_2(\boldsymbol{x}),...,\nabla h_m(\boldsymbol{x})</script>线性无关。</p><p>接下来还要用到切线空间和法线空间的概念，定义如下：</p><p>在曲面<script type="math/tex">S=\{\boldsymbol{x}\in \mathbb{R}^n,\boldsymbol{h}(\boldsymbol{x})=\boldsymbol{0}\}</script>中：</p><ul><li><p>点<script type="math/tex">\boldsymbol{x}^*</script>处的切线空间为集合<script type="math/tex">T(\boldsymbol{x}^*)=\{\boldsymbol{y}:D\boldsymbol{h}(\boldsymbol{x}^*)\boldsymbol{y}=\boldsymbol{0}\}</script>，为矩阵<script type="math/tex">D\boldsymbol{h}(\boldsymbol{x}^*)</script>的零空间。</p></li><li><p>点<script type="math/tex">\boldsymbol{x}^*</script>处的法线空间为集合<script type="math/tex">N(\boldsymbol{x}^*)=\{\boldsymbol{x}\in \mathbb{R}^n:\boldsymbol{x}=D\boldsymbol{h}(\boldsymbol{x}^*)^T\boldsymbol{z},\boldsymbol{z}\in \mathbb{R}^m\}</script>，为矩阵<script type="math/tex">D\boldsymbol{h}(\boldsymbol{x}^*)^T</script>的值域。</p></li></ul><p>可以证明，切线空间和法线空间互为正交补。</p><h4 id="4-2-1-一阶必要条件-拉格朗日定理"><a href="#4-2-1-一阶必要条件-拉格朗日定理" class="headerlink" title="4.2.1 一阶必要条件(拉格朗日定理)"></a>4.2.1 一阶必要条件(拉格朗日定理)</h4><p>拉格朗日定理可表述如下：</p><p>若<script type="math/tex">\boldsymbol{x}^*</script>是<script type="math/tex">f:\mathbb{R}^n\to\mathbb{R}</script>的局部极小点(或极大点)，约束条件为<script type="math/tex">\boldsymbol{h}(\boldsymbol{x})=\boldsymbol{0}</script>，<script type="math/tex">\boldsymbol{h}:\mathbb{R}^n\to\mathbb{R}^m,m\le n</script>。如果<script type="math/tex">\boldsymbol{x}^*</script>是正则点，那么存在<script type="math/tex">\boldsymbol{\lambda}^*\in\mathbb{R}^m</script>，使得：$$Df(\boldsymbol{x}^*)+{\boldsymbol{\lambda}^*}^TD\boldsymbol{h}(\boldsymbol{x}^*)=\boldsymbol{0}^T$$</p><p>其中：</p><ul><li>第一项中<script type="math/tex">Df(\boldsymbol{x})</script>为函数<script type="math/tex">f</script>的一阶导数：<script type="math/tex">Df=[\frac{\partial{f}}{\partial{x_1}},\frac{\partial{f}}{\partial{x_2}},...,\frac{\partial{f}}{\partial{x_n}}]</script>，刚好为梯度<script type="math/tex">\nabla f(\boldsymbol{x})</script>的转置。</li><li>第二项中<script type="math/tex">D\boldsymbol{h}(\boldsymbol{x})</script>为向量值函数<script type="math/tex">\boldsymbol{h}(\boldsymbol{x})</script>的雅克比矩阵：$$D\boldsymbol{h}(\boldsymbol{x})=\begin{bmatrix}Dh_1(\boldsymbol{x})\\ ...\\Dh_m(\boldsymbol{x})\end{bmatrix}=\begin{bmatrix}\nabla h_1(\boldsymbol{x})^T\\ ...\\\nabla h_m(\boldsymbol{x})^T\end{bmatrix}$$</li></ul><p>将上式展开，就会发现：$$\nabla f(\boldsymbol{x}^*)^T = -\begin{bmatrix} \lambda_1 & ... &\lambda_m \end{bmatrix} \begin{bmatrix}\nabla h_1(\boldsymbol{x}^*)^T\\ ...\\\nabla h_m(\boldsymbol{x}^*)^T\end{bmatrix}$$</p><p>拉格朗日定理表明，如果<script type="math/tex">\boldsymbol{x}^*</script>是极值点，那么目标函数<script type="math/tex">f</script>在该点处梯度可以表示为关于约束函数在该点梯度的线性组合。</p><p>证明是构造性的，证明<script type="math/tex">\nabla f(\boldsymbol{x}^*)</script>位于法线空间中即可。</p><p>拉格朗日定理的几何解释如下图所示：</p><p><img src="/img/NLP/拉格朗日几何.jpg" alt="拉格朗日几何" style="zoom:25%;" /></p><p>为了便于描述，引入拉格朗日函数：<script type="math/tex">l(\boldsymbol{x},\boldsymbol{\lambda})=f(\boldsymbol{x})+\boldsymbol{\lambda}^T\boldsymbol{h}(\boldsymbol{x})</script></p><p>则一阶必要条件可以重新表述为：$$D_xl(\boldsymbol{x}^*,\boldsymbol{\lambda}^*)=\boldsymbol{0}^T$$ $$D_{\lambda}l(\boldsymbol{x}^*,\boldsymbol{\lambda}^*)=\boldsymbol{0}^T$$</p><h4 id="4-2-2-二阶必要条件"><a href="#4-2-2-二阶必要条件" class="headerlink" title="4.2.2 二阶必要条件"></a>4.2.2 二阶必要条件</h4><p>记<script type="math/tex">\boldsymbol{L}(\boldsymbol{x},\boldsymbol{\lambda})</script>是<script type="math/tex">l(\boldsymbol{x},\boldsymbol{\lambda})</script>关于<script type="math/tex">\boldsymbol{x}</script>的Hessian矩阵：$$\boldsymbol{L}(\boldsymbol{x},\boldsymbol{\lambda})=\nabla^2 f(\boldsymbol{x})+\lambda_1\nabla^2 h_1(\boldsymbol{x})+...+\lambda_m\nabla^2 h_m(\boldsymbol{x})$$</p><p>若<script type="math/tex">\boldsymbol{x}^*</script>是<script type="math/tex">f:\mathbb{R}^n\to\mathbb{R}</script>的局部极小点，且<script type="math/tex">\boldsymbol{x}^*</script>为正则点，则存在<script type="math/tex">\boldsymbol{\lambda}^*\in\mathbb{R}^m</script>，使得：</p><p>1、                                                        <script type="math/tex">Df(\boldsymbol{x}^*)+{\boldsymbol{\lambda}^*}^TD\boldsymbol{h}(\boldsymbol{x}^*)=\boldsymbol{0}^T</script></p><p>2、                                      对于所有<script type="math/tex">\boldsymbol{y}\in T(\boldsymbol{x}^*)</script>，都有<script type="math/tex">\boldsymbol{y}^T\boldsymbol{L}(\boldsymbol{x}^*,\boldsymbol{\lambda}^*)\boldsymbol{y}\ge0</script>                         </p><h4 id="4-2-3-二阶充分条件"><a href="#4-2-3-二阶充分条件" class="headerlink" title="4.2.3 二阶充分条件"></a>4.2.3 二阶充分条件</h4><p>如果存在<script type="math/tex">\boldsymbol{x}^*\in\mathbb{R}^n</script>和<script type="math/tex">\boldsymbol{\lambda}^*\in\mathbb{R}^m</script>，使得：</p><p>1、                                                     <script type="math/tex">Df(\boldsymbol{x}^*)+{\boldsymbol{\lambda}^*}^TD\boldsymbol{h}(\boldsymbol{x}^*)=\boldsymbol{0}^T</script></p><p>2、                                      对于所有<script type="math/tex">\boldsymbol{y}\in T(\boldsymbol{x}^*)</script>，<script type="math/tex">\boldsymbol{y}\ne\boldsymbol{0}</script>，都有<script type="math/tex">\boldsymbol{y}^T\boldsymbol{L}(\boldsymbol{x}^*,\boldsymbol{\lambda}^*)\boldsymbol{y}>0</script>     </p><p>那么<script type="math/tex">\boldsymbol{x}^*</script>是<script type="math/tex">f</script>在约束条件<script type="math/tex">\boldsymbol{h}(\boldsymbol{x})=\boldsymbol{0}</script>下的严格局部极小点。    </p><h3 id="4-3-等式和不等式约束"><a href="#4-3-等式和不等式约束" class="headerlink" title="4.3 等式和不等式约束"></a>4.3 等式和不等式约束</h3><p>本节将研究以下形式约束问题局部极小点对应的条件：$$\min  \ \ \ \ \ \ \ \ f(\boldsymbol{x})$$   $$ s.t. \ \ \ \ \boldsymbol{h}(\boldsymbol{x})=\boldsymbol{0}$$  $$ \ \ \ \ \ \ \ \ \ \ \ \boldsymbol{g}(\boldsymbol{x})\le\boldsymbol{0}$$</p><p>在讨论含不等式约束的优化问题时，一个很重要的概念是起作用约束和不起作用约束。若对于一个不等式约束<script type="math/tex">g_j(\boldsymbol{x})\le0</script>，如果在<script type="math/tex">\boldsymbol{x}^*</script>处<script type="math/tex">g_j(\boldsymbol{x^*})=0</script>，那么称该约束是<script type="math/tex">\boldsymbol{x}^*</script>处的起作用约束；如果在<script type="math/tex">\boldsymbol{x}^*</script>处<script type="math/tex">g_j(\boldsymbol{x^*})<0</script>，那么称该约束是<script type="math/tex">\boldsymbol{x}^*</script>处的不起作用约束。</p><p>为了区分起作用约束和不起作用约束，用<script type="math/tex">J(\boldsymbol{x^*})</script>表示起作用不等式约束的下标集：$$J(\boldsymbol{x^*})=\{j:g_j(\boldsymbol{x^*})=0\}$$</p><p>同样的，在含不等式约束优化问题中，正则点的概念同样重要。在<script type="math/tex">\boldsymbol{x^*}</script>满足约束的前提下，如果向量集<script type="math/tex">\nabla h_i(\boldsymbol{x^*}),\nabla g_j(\boldsymbol{x^*}),1\le i\le m,j\in J(\boldsymbol{x^*})</script>是线性无关的，那么则称<script type="math/tex">\boldsymbol{x^*}</script>是一个正则点。</p><h4 id="4-3-1-一阶必要条件-KKT条件"><a href="#4-3-1-一阶必要条件-KKT条件" class="headerlink" title="4.3.1 一阶必要条件(KKT条件)"></a>4.3.1 一阶必要条件(KKT条件)</h4><p>若<script type="math/tex">\boldsymbol{x}^*</script>是<script type="math/tex">f:\mathbb{R}^n\to\mathbb{R}</script>的局部极小点，约束条件为<script type="math/tex">\boldsymbol{h}(\boldsymbol{x})=\boldsymbol{0},\boldsymbol{g}(\boldsymbol{x})\le\boldsymbol{0}</script>。如果<script type="math/tex">\boldsymbol{x}^*</script>是正则点，那么存在<script type="math/tex">\boldsymbol{\lambda}^*\in\mathbb{R}^m</script>和<script type="math/tex">\boldsymbol{\mu}^*\in\mathbb{R}^p</script>，使得：</p><p>1、                                                                            $$\boldsymbol{\mu}^*\ge0$$</p><p>2、                                               $$Df(\boldsymbol{x}^*)+{\boldsymbol{\lambda}^*}^TD\boldsymbol{h}(\boldsymbol{x}^*)+{\boldsymbol{\mu}^*}^TD\boldsymbol{g}(\boldsymbol{x}^*)=\boldsymbol{0}^T$$</p><p>3、                                                                      $${\boldsymbol{\mu}^*}^T\boldsymbol{g}(\boldsymbol{x}^*)=0$$</p><p>上面三个条件被称为KKT条件（Karush-Kuhn-Tucker条件）。</p><p>KKT条件的几何解释如下图所示：</p><p><img src="/img/NLP/KKT几何.jpg" alt="KKT几何" style="zoom:25%;" /></p><h4 id="4-3-2-二阶必要条件"><a href="#4-3-2-二阶必要条件" class="headerlink" title="4.3.2 二阶必要条件"></a>4.3.2 二阶必要条件</h4><p>类似的，定义<script type="math/tex">\boldsymbol{L}(\boldsymbol{x},\boldsymbol{\lambda},\boldsymbol{\mu})</script>： $$\boldsymbol{L}(\boldsymbol{x},\boldsymbol{\lambda},\boldsymbol{\mu})=\nabla^2 f(\boldsymbol{x})+\lambda_1\nabla^2 h_1(\boldsymbol{x})+...+\lambda_m\nabla^2 h_m(\boldsymbol{x})+\mu_1\nabla^2 g_1(\boldsymbol{x})+...+\mu_p\nabla^2 g_p(\boldsymbol{x})$$</p><p>并用<script type="math/tex">T(\boldsymbol{x}^*)=\{\boldsymbol{y}\in\mathbb{R}^n:D\boldsymbol{h}(\boldsymbol{x}^*)\boldsymbol{y}=\boldsymbol{0},Dg_j(\boldsymbol{x}^*)\boldsymbol{y}=\boldsymbol{0},j\in J(\boldsymbol{x}^*)\}</script>代表起作用约束所定义曲面的切线空间。</p><p>则二阶必要条件为：</p><p>若<script type="math/tex">\boldsymbol{x}^*</script>是<script type="math/tex">f:\mathbb{R}^n\to\mathbb{R}</script>的局部极小点，且<script type="math/tex">\boldsymbol{x}^*</script>为正则点，则存在<script type="math/tex">\boldsymbol{\lambda}^*\in\mathbb{R}^m，\boldsymbol{\mu}^*\in\mathbb{R}^p</script>，使得：</p><p>1、                             <script type="math/tex">\boldsymbol{\mu}^*\ge0,Df(\boldsymbol{x}^*)+{\boldsymbol{\lambda}^*}^TD\boldsymbol{h}(\boldsymbol{x}^*)+{\boldsymbol{\mu}^*}^TD\boldsymbol{g}(\boldsymbol{x}^*)=\boldsymbol{0}^T,{\boldsymbol{\mu}^*}^T\boldsymbol{g}(\boldsymbol{x}^*)=0</script></p><p>2、                                       对于所有<script type="math/tex">\boldsymbol{y}\in T(\boldsymbol{x}^*)</script>，都有<script type="math/tex">\boldsymbol{y}^T\boldsymbol{L}(\boldsymbol{x}^*,\boldsymbol{\lambda}^*,\boldsymbol{\mu}^*)\boldsymbol{y}\ge0</script>              </p><h4 id="4-3-3-二阶充分条件"><a href="#4-3-3-二阶充分条件" class="headerlink" title="4.3.3 二阶充分条件"></a>4.3.3 二阶充分条件</h4><p>如果<script type="math/tex">\boldsymbol{x}^*\in\mathbb{R}^n</script>是一个可行点，存在<script type="math/tex">\boldsymbol{\lambda}^*\in\mathbb{R}^m</script>和<script type="math/tex">\boldsymbol{\mu}^*\in\mathbb{R}^p</script>，使得：</p><p>1、                             <script type="math/tex">\boldsymbol{\mu}^*\ge0,Df(\boldsymbol{x}^*)+{\boldsymbol{\lambda}^*}^TD\boldsymbol{h}(\boldsymbol{x}^*)+{\boldsymbol{\mu}^*}^TD\boldsymbol{g}(\boldsymbol{x}^*)=\boldsymbol{0}^T,{\boldsymbol{\mu}^*}^T\boldsymbol{g}(\boldsymbol{x}^*)=0</script></p><p>2、                                       对于所有<script type="math/tex">\boldsymbol{y}\in \widetilde{T}(\boldsymbol{x}^*)</script>，<script type="math/tex">\boldsymbol{y}\ne\boldsymbol{0}</script>，都有<script type="math/tex">\boldsymbol{y}^T\boldsymbol{L}(\boldsymbol{x}^*,\boldsymbol{\lambda}^*,\boldsymbol{\mu}^*)\boldsymbol{y}>0</script>             </p><p>那么<script type="math/tex">\boldsymbol{x}^*</script>是<script type="math/tex">f</script>在约束条件<script type="math/tex">\boldsymbol{h}(\boldsymbol{x})=\boldsymbol{0},\boldsymbol{g}(\boldsymbol{x})\le\boldsymbol{0}</script>下的严格局部极小点。   </p><p>其中，<script type="math/tex">\widetilde{T}(\boldsymbol{x}^*)=\{\boldsymbol{y}\in\mathbb{R}^n:D\boldsymbol{h}(\boldsymbol{x}^*)\boldsymbol{y}=\boldsymbol{0},Dg_j(\boldsymbol{x}^*)\boldsymbol{y}=\boldsymbol{0},j\in \widetilde{J}(\boldsymbol{x}^*,\boldsymbol{\mu}^*)\}</script></p><p>上式中，<script type="math/tex">\widetilde{J}(\boldsymbol{x}^*,\boldsymbol{\mu}^*)=\{i:g_i(\boldsymbol{x}^*=0,\mu_i^*>0\}</script></p><h2 id="5-全局性质：凸性Convexity"><a href="#5-全局性质：凸性Convexity" class="headerlink" title="5 全局性质：凸性Convexity"></a><strong>5 全局性质：凸性Convexity</strong></h2><h3 id="5-1-为什么研究凸优化"><a href="#5-1-为什么研究凸优化" class="headerlink" title="5.1 为什么研究凸优化"></a>5.1 为什么研究凸优化</h3><p>在实际中，我们经常会碰到目标函数是凸函数、约束集是凸集的优化问题，这类问题称为凸优化问题或者凸规划。线性规划、二次规划（目标函数为二次型函数、约束方程为线性方程）等实际中大量出现的问题都属于凸优化的范畴。而且凸优化问题有两个很好的性质：</p><ul><li>局部极小点就是全局极小点</li><li>极小点的一阶必要条件同时是凸优化问题的充分条件</li></ul><p>这些性质为求解凸优化问题带来了很大的方便，因此很有必要研究一下凸优化问题。</p><p>下面先来讨论几个很能体现凸优化问题特色的定理：</p><ul><li><p>定理一：已知<script type="math/tex">f:\Omega\to\mathbb{R}</script>是定义在凸集<script type="math/tex">\Omega\subset\mathbb{R}^n</script>上的凸函数，集合<script type="math/tex">\Omega</script>中某一点是<script type="math/tex">f</script>的全局极小点，当且仅当它是<script type="math/tex">f</script>的局部极小点。</p></li><li><p>定理二：如果<script type="math/tex">f:\Omega\to\mathbb{R}</script>是定义在凸集<script type="math/tex">\Omega\subset\mathbb{R}^n</script>上的凸函数，若存在<script type="math/tex">\boldsymbol{x}^*\in\Omega</script>，使得：$$\nabla f(\boldsymbol{x}^*)=\boldsymbol{0}$$</p><p>则<script type="math/tex">\boldsymbol{x}^*</script>是<script type="math/tex">f</script>在<script type="math/tex">\Omega</script>上的全局极小点。这说明集合约束对应的凸优化问题中一阶必要条件就是全局极小的充分条件。</p></li><li><p>定理三：如果<script type="math/tex">f:\Omega\to\mathbb{R}</script>是定义在凸集<script type="math/tex">\Omega=\{\boldsymbol{x}\in \mathbb{R}^n,\boldsymbol{h}(\boldsymbol{x})=\boldsymbol{0}\}</script>上的凸函数，且<script type="math/tex">\Omega</script>是凸集。假设存在<script type="math/tex">\boldsymbol{\lambda}^*\in\mathbb{R}^m</script>，使得：$$Df(\boldsymbol{x}^*)+{\boldsymbol{\lambda}^*}^TD\boldsymbol{h}(\boldsymbol{x}^*)=\boldsymbol{0}^T$$</p><p>则<script type="math/tex">\boldsymbol{x}^*</script>是<script type="math/tex">f</script>在<script type="math/tex">\Omega</script>上的全局极小点。这说明等式约束对应的凸优化问题中拉格朗日条件就是全局极小的充分条件。</p></li><li><p>定理四：如果<script type="math/tex">f:\Omega\to\mathbb{R}</script>是定义在凸集<script type="math/tex">\Omega=\{\boldsymbol{x}\in \mathbb{R}^n,\boldsymbol{h}(\boldsymbol{x})=\boldsymbol{0},\boldsymbol{g}(\boldsymbol{x})\le\boldsymbol{0}\}</script>上的凸函数，且<script type="math/tex">\Omega</script>是凸集。假设存在<script type="math/tex">\boldsymbol{\lambda}^*\in\mathbb{R}^m</script>和<script type="math/tex">\boldsymbol{\mu}^*\in\mathbb{R}^p</script>，使得：$$\boldsymbol{\mu}^*\ge0$$ $$Df(\boldsymbol{x}^*)+{\boldsymbol{\lambda}^*}^TD\boldsymbol{h}(\boldsymbol{x}^*)+{\boldsymbol{\mu}^*}^TD\boldsymbol{g}(\boldsymbol{x}^*)=\boldsymbol{0}^T$$ $${\boldsymbol{\mu}^*}^T\boldsymbol{g}(\boldsymbol{x}^*)=0$$</p><p>则<script type="math/tex">\boldsymbol{x}^*</script>是<script type="math/tex">f</script>在<script type="math/tex">\Omega</script>上的全局极小点。这说明不等式约束对应的凸优化问题中KKT条件就是全局极小的充分条件。</p></li></ul><h3 id="5-2-基本定义与性质"><a href="#5-2-基本定义与性质" class="headerlink" title="5.2 基本定义与性质"></a>5.2 基本定义与性质</h3><p>几个基本的定义如下：</p><ul><li><p>凸集：若对于所有的<script type="math/tex">\boldsymbol{u},\boldsymbol{v}\in\Theta</script>，<script type="math/tex">\boldsymbol{u}</script>和<script type="math/tex">\boldsymbol{v}</script>之间的线段<script type="math/tex">\alpha\boldsymbol{u}+(1-\alpha)\boldsymbol{v},\alpha\in[0,1]</script>都位于<script type="math/tex">\Theta</script>内，称<script type="math/tex">\Theta\in\mathbb{R}^n</script>为凸集。</p></li><li><p>凸函数：对于定义在凸集<script type="math/tex">\Omega\in\mathbb{R}^n</script>上的函数<script type="math/tex">f:\Omega\to\mathbb{R}</script>，则函数<script type="math/tex">f</script>是凸函数当且仅当对于任意<script type="math/tex">\boldsymbol{x},\boldsymbol{y}\in\Omega,\boldsymbol{x}\ne\boldsymbol{y}</script>和<script type="math/tex">\alpha\in(0,1)</script>，都有： $$f(\alpha\boldsymbol{x}+(1-\alpha)\boldsymbol{y})\le \alpha f(\boldsymbol{x})+(1-\alpha)f(\boldsymbol{y})$$</p><p>​               </p></li></ul><p>凸函数比较重要的性质总结如下：</p><ul><li>若干凸函数的线性组合还是凸函数。</li><li>凸函数的定义域必为凸集。</li><li>函数<script type="math/tex">f</script>是凸函数当且仅当对于任意<script type="math/tex">\boldsymbol{x},\boldsymbol{y}\in\Omega</script>，有<script type="math/tex">f(\boldsymbol{y})\ge f(\boldsymbol{x})+Df(\boldsymbol{x})(\boldsymbol{y}-\boldsymbol{x})</script>。几何意义为凸函数的图像总是在其线性近似函数的上方。</li><li>二次型函数<script type="math/tex">f(\boldsymbol{x})=\boldsymbol{x}^TQ\boldsymbol{x},Q=Q^T</script>是凸函数当且仅当矩阵<script type="math/tex">Q</script>半正定。</li><li>函数<script type="math/tex">f</script>是凸函数当且仅当<script type="math/tex">f</script>的Hessian矩阵半正定，即<script type="math/tex">\nabla^2 f(\boldsymbol{x}^*)\ge0</script>。</li></ul><h3 id="5-3-半定规划"><a href="#5-3-半定规划" class="headerlink" title="5.3 半定规划"></a>5.3 半定规划</h3><p>半定规划是凸优化的一个分支，求解的是线性矩阵不等式约束下的线性目标函数的极小值。线性矩阵不等式约束定义了一个凸集，要求在该可行集上使得目标函数达到极小值。</p><h2 id="6-确定步长：一维搜索方法"><a href="#6-确定步长：一维搜索方法" class="headerlink" title="6 确定步长：一维搜索方法"></a><strong>6 确定步长：一维搜索方法</strong></h2><h3 id="6-1-why-Line-Search？"><a href="#6-1-why-Line-Search？" class="headerlink" title="6.1 why Line Search？"></a>6.1 why Line Search？</h3><p>在上面我们提到，非线性规划中每一步迭代都使用如下的公式确定每一次迭代的方向和步长：$$\boldsymbol{x}^{(k+1)}=\boldsymbol{x}^{(k)}+t_k\boldsymbol{p}^{(k)}$$</p><p>其中<script type="math/tex">\boldsymbol{p}^{(k)}</script>为搜索方向，是下一大节主要讨论的问题，在这里我们认为每一次迭代的搜索方向<script type="math/tex">\boldsymbol{p}^{(k)}</script>是已知的。在每一次迭代的过程中，我们肯定都希望结果相较前一次有所改善，也就是希望每一次迭代都能使目标函数值有所下降，即<script type="math/tex">f(\boldsymbol{x}^{(k+1)})<f(\boldsymbol{x}^{(k)})</script>，甚至是下降的最多。而我们现在唯一可以调整的参量就是搜索步长<script type="math/tex">t_k</script>，在<script type="math/tex">\boldsymbol{p}^{(k)}</script>和<script type="math/tex">\boldsymbol{x}^{(k)}</script>都确定的情况下，<script type="math/tex">f(\boldsymbol{x}^{(k+1)})</script>只与<script type="math/tex">t_k</script>的取值有关，是关于<script type="math/tex">t_k</script>的一元函数。一个很直观的想法就是找出使得<script type="math/tex">f(\boldsymbol{x}^{(k+1)})</script>最小的<script type="math/tex">t_k</script>，即：$$t_k=\underset{t_k>0}{argmin}\ \ f(\boldsymbol{x}^{(k)}+t_k\boldsymbol{p}^{(k)})$$</p><p><img src="/img/NLP/LS_in_NLP.jpg" alt="LS_in_NLP" style="zoom:25%;" /></p><p>如图所示，一维搜索方法的主要目的就是：</p><p>找到使得<script type="math/tex">f(\boldsymbol{x}^{(k+1)})=f(\boldsymbol{x}^{(k)}+t_k\boldsymbol{p}^{(k)})=\phi(t_k)</script>有所下降甚至是取极小值的<script type="math/tex">t_k</script>，进而确定每一次迭代步长。</p><h3 id="6-2-六点说明"><a href="#6-2-六点说明" class="headerlink" title="6.2 六点说明"></a>6.2 六点说明</h3><ol><li><p>适用范围：一维搜索问题可用于解决一元函数极小化和非线性规划中每一次迭代步长的确定。</p></li><li><p>一维搜索方法及本质：</p><ul><li>仍具有一般非线性规划问题的结构，因为需要极小化的函数<script type="math/tex">f(\boldsymbol{x}^{(k)}+t_k\boldsymbol{p}^{(k)})</script>大部分是非线性的</li><li>非线性规划的迭代下降算法本质是把<script type="math/tex">n</script>维问题化为一系列一维问题</li><li>一维搜索问题仍采用迭代(下降)算法</li><li>搜索方向可正可负，产生一系列试探点列：<script type="math/tex">t_0,t_1,...,t_K</script></li></ul></li><li><p>几个概念：</p><ul><li><p>全局最优解、局部最优解、满意解：字面意思</p></li><li><p>单谷函数：区间<script type="math/tex">[a,b]</script>的单谷函数<script type="math/tex">\phi(t)</script>：<script type="math/tex">\exist\ t^*\in[a,b]</script>，使<script type="math/tex">\phi(t)</script>在<script type="math/tex">[a,t^*]</script>严格递减，且在<script type="math/tex">[t^*,b]</script>严格递增。</p><p>​                   注意单谷函数和凸函数是两个概念。</p></li></ul></li><li><p>精确一维搜索与非精确一维搜索：</p><ul><li>精确一维搜索：试探点列<script type="math/tex">\{t_l\}_{l=0}^{+\infty}</script>满足<script type="math/tex">\underset{l\to +\infty}{\lim}t_l=t^*</script>，即可以精确的找到极小点对应的<script type="math/tex">t</script></li><li>非精确一维搜索：不能保证试探点列收敛到任意局部极小值，但可以保证目标函数值有一定的下降</li><li>实际应用中均仅执行有限步试探</li></ul></li><li><p>划界问题：如何确定初始搜索区间？即：确定<script type="math/tex">[a,b]</script>或<script type="math/tex">t_{max}</script>。有专门的划界算法解决该问题。</p></li><li><p>常用一维搜索算法总结：</p><p><img src="/img/NLP/LS.png" alt="LS" style="zoom:30%;" /></p></li><li><p>总体评价：</p><ul><li>当用于求解非线性规划中定步长子问题时，非精确一维搜索效果要明显好于精确一维搜索。</li><li>各种非精确一维搜索方法之间差别不大。</li></ul></li></ol><h3 id="6-3-精确一维搜索"><a href="#6-3-精确一维搜索" class="headerlink" title="6.3 精确一维搜索"></a>6.3 精确一维搜索</h3><p>精确一维搜索致力于寻找目标函数的局部或全局最优解，主要有两种思路：</p><ul><li>区间压缩算法：通过不断缩小包含极小点的区间长度，进而找到一个极小点最够好的近似。主要包括黄金分割法、斐波那契数列法、二分法等。</li><li>通过求解近似函数的极小点迭代求解：主要代表有牛顿法，每次迭代都将原函数的二次近似函数的极小点作为下一个迭代点，使目标函数值不断下降，最终找到极小点。</li></ul><p>下面依次介绍这四种算法。</p><h4 id="6-3-1-牛顿法"><a href="#6-3-1-牛顿法" class="headerlink" title="6.3.1 牛顿法"></a>6.3.1 牛顿法</h4><p>牛顿法的思想很简单，就是在当前迭代点处使用一个二次函数去近似目标函数，然后使用这个二次函数的极小点作为下一个迭代点，不断去逼近原函数的极小点。</p><p><img src="/img/NLP/LS_Newton.jpg" alt="LS_Newton" style="zoom:25%;" /></p><p>如上图所示，我们在迭代点<script type="math/tex">x^{(k)}</script>处用二次函数<script type="math/tex">q(x)</script>近似原来的目标函数<script type="math/tex">f(x)</script>，进而将二次函数<script type="math/tex">q(x)</script>的极小点作为下一个迭代点<script type="math/tex">x^{(k+1)}</script>，可以看到<script type="math/tex">x^{(k+1)}</script>处目标函数值比<script type="math/tex">x^{(k)}</script>处的目标函数值要小，如此循环往复，不断迭代，最终可以找到目标函数<script type="math/tex">f(x)</script>的极小点。</p><p>我们现在的目标是求一元单值函数<script type="math/tex">f(x)</script>在区间上的极小点，使用牛顿法求解时要求<script type="math/tex">f(x)</script>连续二阶可微，即迭代点<script type="math/tex">x^{(k)}</script>处的<script type="math/tex">f(x^{(k)})</script>、<script type="math/tex">f'(x^{(k)})</script>和<script type="math/tex">f''(x^{(k)})</script>均可求得。</p><p>在迭代点<script type="math/tex">x^{(k)}</script>处对目标函数<script type="math/tex">f(x)</script>做Taylor展开，保留前两项，可得<script type="math/tex">f(x)</script>在<script type="math/tex">x^{(k)}</script>处的二阶近似：$$q(x)=f(x^{(k)})+f'(x^{(k)})(x-x^{(k)})+\frac{1}{2}f''(x^{(k)})(x-x^{(k)})^2$$</p><p>求<script type="math/tex">q(x)</script>的极小点，即求<script type="math/tex">q'(x)=0</script>，可得：$$q'(x)=f'(x^{(k)})+f''(x^{(k)})(x-x^{(k)})=0$$</p><p>则下一个迭代点<script type="math/tex">x^{(k+1)}</script>作为<script type="math/tex">q(x)</script>的极小点，即为上式的解，有：$$x^{(k+1)}=x^{(k)}-\frac{f'(x^{(k)})}{f''(x^{(k)})}$$</p><p>上式即为牛顿法的迭代公式，不断产生试探点列直到找到极小值。</p><p>需要注意的是，当<script type="math/tex">f''(x)>0</script>对于区间内所有的<script type="math/tex">x</script>都成立时，牛顿法能够正常运行。如果在某些点处<script type="math/tex">f''(x)<0</script>，牛顿法可能收敛到极大点，如下图所示：</p><p><img src="/img/NLP/LS_Nerton_max.jpg" alt="LS_Nerton_max" style="zoom:25%;" /></p><h4 id="6-3-2-二分法"><a href="#6-3-2-二分法" class="headerlink" title="6.3.2 二分法"></a>6.3.2 二分法</h4><p>二分法的思想非常简单，仅使用了目标函数的一阶导数来压缩区间。二分法要求目标函数<script type="math/tex">f</script>在初始区间<script type="math/tex">[a,b]</script>为单谷函数。二分法的过程如下：</p><p>首先确定初始区间的中点作为第一个迭代点<script type="math/tex">x^{(0)}=(a+b)/2</script>。然后计算函数<script type="math/tex">f</script>在<script type="math/tex">x^{(0)}</script>处的一阶导数<script type="math/tex">f'(x^{(0)})</script>。如果一阶导数<script type="math/tex">f'(x^{(0)})>0</script>，说明极小点位于<script type="math/tex">x^{(0)}</script>的左侧，也就是意味着极小点所在的区间可以压缩为<script type="math/tex">[a,x^{(0)}]</script>；反之，如果一阶导数<script type="math/tex">f'(x^{(0)})<0</script>，说明极小点位于<script type="math/tex">x^{(0)}</script>的右侧，也就是意味着极小点所在的区间可以压缩为<script type="math/tex">[x^{(0)},b]</script>。最后，如果<script type="math/tex">f'(x^{(0)})=0</script>，说明<script type="math/tex">x^{(0)}</script>就是极小点，搜索停止。</p><p>按照上述方式，之后每次迭代中都可以得到一个新的区间，然后再根据区间中点处一阶导数的符号进一步将区间压缩为左半区间或右半区间。所以说，在每次迭代中，区间的压缩比为<script type="math/tex">\frac{1}{2}</script>。因此在<script type="math/tex">N</script>次迭代后整个区间的压缩比为<script type="math/tex">(\frac{1}{2})^N</script>，接下来可以看到，这一总压缩比比黄金分割法和斐波那契数列法的总压缩比都要小。</p><h4 id="6-3-3-黄金分割法"><a href="#6-3-3-黄金分割法" class="headerlink" title="6.3.3 黄金分割法"></a>6.3.3 黄金分割法</h4><p>黄金分割法和接下来要讨论的斐波那契数列法都属于区间压缩算法，翟乔柱老师的PPT中有如下论述：</p><p><img src="/img/NLP/LS_区间压缩.jpg" alt="LS_区间压缩" style="zoom:25%;" /></p><p>区间压缩算法的核心就在于如何确定<script type="math/tex">t_{l+1}</script>，主要有两种思路：</p><ul><li>保持区间缩小比：即为本小节要讨论的黄金分割法</li><li>使最终区间最短：即为下一小节要讨论的斐波那契数列法</li></ul><p>先来讨论黄金分割法，这里直接放上翟桥柱老师的课件：</p><center class="half">    <img src="/img/NLP/LS_黄金分割法1.jpg" width="300"/>    <img src="/img/NLP/LS_黄金分割法2.jpg" width="300"/></center><p>注意黄金分割法的三个核心前提为：</p><ul><li>对称压缩：<script type="math/tex">a_1-a_0=b_0-b_1=\rho(b_0-a_0)</script>，其中<script type="math/tex">\rho<\frac{1}{2}</script></li><li>每一步压缩比相同：<script type="math/tex">\rho</script>在每一步中不变，为一常数</li><li>每次迭代只需计算一个试探点处的目标函数值：若当前迭代选择了右边区间作为下一次的区间，则下一次迭代时左边的试探点应和这一次右边的试探点重合；反之亦然。</li></ul><p><img src="/img/NLP/LS_黄金分割法rou.jpg" alt="LS_黄金分割法rou" style="zoom:25%;" /></p><p>如上图所示，假设区间<script type="math/tex">[a_0,b_0]</script>的长度为1，则<script type="math/tex">[a_0,a_1]</script>和<script type="math/tex">[b_1,b_0]</script>的长度均为<script type="math/tex">\rho</script>，若选择了区间<script type="math/tex">[a_0,b_1]</script>作为下一次迭代的初始区间，则区间长度为<script type="math/tex">1-\rho</script>，现在要求<script type="math/tex">a_1</script>和<script type="math/tex">b_2</script>重合，以减少一次试探点处目标函数值的计算。由于<script type="math/tex">[b_2,b_1]</script>的长度为<script type="math/tex">\rho(b_1-a_0)=\rho(1-\rho)</script>，<script type="math/tex">[a_1,b_1]</script>的长度为<script type="math/tex">1-(a_1-a_0)-(b_0-b_1)=1-2\rho</script>。所以说有：$$\rho(1-\rho)=1-2\rho$$</p><p>可以解得：                                                              $$\rho=\frac{3-\sqrt{5}}{2}$$</p><p>可以看到，黄金分割法的区间压缩比为<script type="math/tex">1-\rho=0.618</script>，经过<script type="math/tex">N</script>次迭代压缩之后，极小点所在区间长度将压缩到初始区间长度的<script type="math/tex">(0.618)^N</script>，为黄金分割法的总压缩比。</p><h4 id="6-3-4-斐波那契数列法"><a href="#6-3-4-斐波那契数列法" class="headerlink" title="6.3.4 斐波那契数列法"></a>6.3.4 斐波那契数列法</h4><p>在黄金分割法压缩区间的过程中，每一步的压缩比始终不变。如果允许在区间压缩迭代的每一步对压缩比进行动态的调整，并将总压缩比最小作为优化的目标，就得到了斐波那契数列法。</p><p>斐波那契数列法和黄金分割法有类似的前提，只是允许每一步的压缩比可以动态调整：</p><ul><li><p>对称压缩：<script type="math/tex">a_{k+1}-a_k=b_k-b_{k+1}=\rho_k(b_k-a_k)</script>，其中<script type="math/tex">\rho_k<\frac{1}{2}</script></p></li><li><p>每次迭代只需计算一个试探点处的目标函数值：<script type="math/tex">\rho_{k+1}(1-\rho_{k})=1-2\rho_{k}</script>，即满足约束：<script type="math/tex">\rho_{k+1}=1-\frac{\rho_k}{1-\rho_k}</script></p><p><img src="/img/NLP/LS_斐波那契数列法rou.jpg" alt="LS_斐波那契数列法rou" style="zoom:20%;" /></p></li></ul><p>存在很多组序列<script type="math/tex">\rho_1,\rho_2,...</script>可以满足上述需求，一个合理的想法是，我们要找到一组满足上述要求的序列<script type="math/tex">\rho_1,\rho_2,...</script>，使得<script type="math/tex">N</script>次压缩的总压缩比<script type="math/tex">(1-\rho_1)(1-\rho_2)\cdot\cdot\cdot\cdot(1-\rho_N)</script>最小。</p><p>这可以使用下面的有约束优化问题来描述：</p><p>​                                                   $$minimize  \ \ \ \ \ \ \ \ (1-\rho_1)(1-\rho_2)\cdot\cdot\cdot\cdot(1-\rho_N)$$   $$ subject \ to  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \rho_{k+1}=1-\frac{\rho_k}{1-\rho_k}$$   $$ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 0\le\rho_k\le\frac{1}{2}$$              </p><p>上述优化问题的解为：$$\rho_1=1-\frac{F_N}{F_{N+1}}\ ,\ \rho_2=1-\frac{F_{N-1}}{F_{N}}\ , \ ...\ , \ \rho_N=1-\frac{F_1}{F_{2}}$$</p><p>其中<script type="math/tex">F_n</script>为斐波那契数列的第<script type="math/tex">n</script>项，这也是为什么其被称作斐波那契数列法。</p><p>斐波那契数列的总压缩比为<script type="math/tex">\frac{1}{F_{N+1}}</script>。</p><p>翟桥柱老师的课件中提供了一种很有启发性的思路，摘录如下：</p><center class="half">    <img src="/img/NLP/LS_斐波那契数列2.jpg" width="300"/>    <img src="/img/NLP/LS_斐波那契数列法1.jpg" width="300"/></center><h3 id="6-4-非精确一维搜索"><a href="#6-4-非精确一维搜索" class="headerlink" title="6.4 非精确一维搜索"></a>6.4 非精确一维搜索</h3><p>在用于非线性规划定步长子问题时，精确的一维搜索通常存在一些问题：</p><ul><li>精确的求解极小点需要非常大的计算量，甚至在某些情况下极小点根本不存在</li><li>应该将更多的计算资源配置在多维优化算法而不是追求高精度的一维搜索上</li></ul><p>这些缺点意味着应该为一维搜索算法设计合适的停止条件，当步长为满意步长时即停止搜索；并使得即使一维搜索结果精度偏低，仍然能够保证目标函数值在两次迭代中得到足够程度的下降，一个基本的理念是：步长不要太小也不要太大。因此，非精确一维搜索应运而生。</p><p>非精确一维搜索方法并不试图寻找一维搜索问题的全局或局部最优解，而是致力于获得一个可以是目标函数下降的满意解。因此，非精确一维搜索主要包含两个结构要素：</p><ul><li>满意步长的判别准则：主要有三种常用的满意步长准则，Goldstein准则、Armijo准则和Wolfe准则</li><li>获得满意步长的方法：具体根据每种满意步长准则都有响应的算法</li></ul><h4 id="6-4-1-Goldstein准则"><a href="#6-4-1-Goldstein准则" class="headerlink" title="6.4.1 Goldstein准则"></a>6.4.1 Goldstein准则</h4><p><img src="/img/NLP/LS_Goldstein.jpg" alt="LS_Goldstein" style="zoom:20%;" /></p><h4 id="6-4-2-Armijo准则"><a href="#6-4-2-Armijo准则" class="headerlink" title="6.4.2 Armijo准则"></a>6.4.2 Armijo准则</h4><p><img src="/img/NLP/LS_Armijo.jpg" alt="LS_Armijo" style="zoom:20%;" /></p><h4 id="6-4-3-Wolfe准则"><a href="#6-4-3-Wolfe准则" class="headerlink" title="6.4.3 Wolfe准则"></a>6.4.3 Wolfe准则</h4><p><img src="/img/NLP/LS_Wolfe.jpg" alt="LS_Wolfe" style="zoom:20%;" /></p><h4 id="6-4-4-非精确一维搜索算法"><a href="#6-4-4-非精确一维搜索算法" class="headerlink" title="6.4.4 非精确一维搜索算法"></a>6.4.4 非精确一维搜索算法</h4><p>包括Goldstein准则定步长算法、Armijo划界法等等。</p><h2 id="7-搜索方向：算法的核心"><a href="#7-搜索方向：算法的核心" class="headerlink" title="7 搜索方向：算法的核心"></a><strong>7 搜索方向：算法的核心</strong></h2><h3 id="7-1-无约束优化"><a href="#7-1-无约束优化" class="headerlink" title="7.1 无约束优化"></a>7.1 无约束优化</h3><p>无约束优化问题主要算法的特点如下：</p><p><img src="/img/NLP/无约束优化问题概览.jpg" alt="无约束优化问题概览" style="zoom:28%;" /></p><p>上图中的算法都会在下面得到介绍。</p><h4 id="7-1-1-梯度方法"><a href="#7-1-1-梯度方法" class="headerlink" title="7.1.1 梯度方法"></a>7.1.1 梯度方法</h4><h5 id="7-1-1-1-梯度方法概述"><a href="#7-1-1-1-梯度方法概述" class="headerlink" title="7.1.1.1 梯度方法概述"></a>7.1.1.1 梯度方法概述</h5><p>梯度方法主要基于关于梯度和下降方向的这样几个事实：</p><ul><li>与负梯度方向夹角小于90°的方向是下降方向</li><li>负梯度方向是最容易获得的下降方向，也是函数值下降最快的方向</li><li>可以用当前搜索点的梯度是否接近于0作为搜索的终止准则之一</li></ul><p>则梯度方法选择负梯度方向<script type="math/tex">-\nabla f(\boldsymbol{x}^{(k)})</script>作为每次迭代时的搜索方向，迭代方程如下式，其中步长<script type="math/tex">\alpha_k>0</script>： $$\boldsymbol{x}^{(k+1)}=\boldsymbol{x}^{(k)}-\alpha_k\nabla f(\boldsymbol{x}^{(k)})$$</p><p>在搜索过程中，目标函数的梯度值不断变化。可以设定很小的步长，每次迭代都重新计算梯度，也可以设置很大的步长。前者的工作量非常大，后者则容易在极小点附近产生锯齿状的收敛路径，优势在于梯度的计算次数少一些。</p><p>梯度方法包括很多种具体的算法，区别主要在每一次步长<script type="math/tex">\alpha_k</script>的选取上：</p><ul><li>最速下降法：采用精确一维搜索找到最优的步长：<script type="math/tex">\alpha_k=\underset{\alpha_k>0}{argmin}\ \ f(\boldsymbol{x}^{(k)}-\alpha_k\nabla f(\boldsymbol{x}^{(k)})</script></li><li>步长固定梯度法：每次迭代的步长固定为一个常数<script type="math/tex">\alpha</script></li><li>BB方法：<script type="math/tex">\alpha_k=\frac{(\boldsymbol{s}^{(k)})^T\boldsymbol{s}^{(k)}}{(\boldsymbol{s}^{(k)})^T\boldsymbol{y}^{(k)}}</script>，其中<script type="math/tex">\boldsymbol{s}^{(k)}=\boldsymbol{x}^{(k)}-\boldsymbol{x}^{(k-1)},\boldsymbol{y}^{(k)}=\nabla f(\boldsymbol{x}^{(k)})-\nabla f(\boldsymbol{x}^{(k-1)})</script>，该步长是对Hessian矩阵的一个近似，可以认为是伪二阶方法，通常结合一维搜索使用。</li></ul><h5 id="7-1-1-2-最速下降法"><a href="#7-1-1-2-最速下降法" class="headerlink" title="7.1.1.2 最速下降法"></a>7.1.1.2 最速下降法</h5><p>接下来主要讨论一下最速下降法的特点：</p><p>最速下降法的核心理念为：在每次迭代中选择合适的步长，使目标函数值能够得到最大程度的减小，即在每次迭代中都选择<script type="math/tex">\alpha_k=\underset{\alpha_k>0}{argmin}\ \ f(\boldsymbol{x}^{(k)}-\alpha_k\nabla f(\boldsymbol{x}^{(k)})</script>，即采用精确一维搜索确定每一步的步长。</p><p>由于在每一步都采用精确一维搜索得到了使得目标函数下降最多的步长，在最速下降法中有一个很有意思的结论：</p><p><strong>最速下降法的相邻搜索方向是正交的。</strong>如下图所示：</p><p><img src="/img/NLP/最速下降法搜索方向正交.jpg" alt="最速下降法搜索方向正交" style="zoom:25%;" /></p><p>这个结论通过步长的选择方法<script type="math/tex">\alpha_k=\underset{\alpha_k>0}{argmin}\ \ f(\boldsymbol{x}^{(k)}-\alpha_k\nabla f(\boldsymbol{x}^{(k)})</script>可以很容易的得到：</p><p>注意到<script type="math/tex">\alpha_k</script>是函数<script type="math/tex">\phi(\alpha)=f(\boldsymbol{x}^{(k)}-\alpha\nabla f(\boldsymbol{x}^{(k)})</script>的极小点，利用局部极小点的必要条件和求导的链式法则，有：$$\frac{d\phi_k(\alpha_k)}{d\alpha_k}=(\nabla f(\boldsymbol{x}^{(k)}-\alpha_k\nabla f(\boldsymbol{x}^{(k)}))^T(-\nabla f(\boldsymbol{x}^{(k)}))=-(\nabla f(\boldsymbol{x}^{(k+1)})^T(\nabla f(\boldsymbol{x}^{(k)}))=0$$</p><p>可以看到<script type="math/tex">\nabla f(\boldsymbol{x}^{(k)})</script>和<script type="math/tex">\nabla f(\boldsymbol{x}^{(k+1)})</script>内积为0，即两次搜索方向相互正交。</p><p>相邻搜索方向正交是一个非常不好的特性，因为搜索并不是直接冲着极小值去的，而是一个”拉锯”的现象，被称作Zigzag现象，可能收敛很慢。在上运筹学课程时，老师提出了一个思考题：不用精确一维搜索，是否有助于避免Zigzag现象？通过上面证明，可以很轻松的给出回答，相邻方向正交这个结论严格依赖于<script type="math/tex">\alpha_k</script>是函数<script type="math/tex">\phi(\alpha)=f(\boldsymbol{x}^{(k)}-\alpha\nabla f(\boldsymbol{x}^{(k)})</script>的极小点这个条件，如果不采用精确一维搜索，则<script type="math/tex">\nabla f(\boldsymbol{x}^{(k)})</script>和<script type="math/tex">\nabla f(\boldsymbol{x}^{(k+1)})</script>的内积不为0，相邻搜索方向也就不正交，有助于避免Zigzag现象。</p><h5 id="7-1-1-3-梯度方法的收敛性和收敛率"><a href="#7-1-1-3-梯度方法的收敛性和收敛率" class="headerlink" title="7.1.1.3 梯度方法的收敛性和收敛率"></a>7.1.1.3 梯度方法的收敛性和收敛率</h5><p>为了分析算法的收敛特性，需要将目标函数设定为二次型函数：$$f(\boldsymbol{x})=\boldsymbol{x}^TQ\boldsymbol{x}-\boldsymbol{b}^T\boldsymbol{x}$$</p><p>首先展示两个关于梯度方法收敛性的结论：</p><ul><li>对于最速下降法，对于任意的初始点<script type="math/tex">\boldsymbol{x}^{(0)}</script>，都有<script type="math/tex">\boldsymbol{x}^{(k)}\to\boldsymbol{x}^*</script></li><li>对于步长固定梯度法，当且仅当步长<script type="math/tex">0<\alpha<\frac{2}{\lambda_{max}(Q)}</script>时，有<script type="math/tex">\boldsymbol{x}^{(k)}\to\boldsymbol{x}^*</script></li></ul><p>即在目标函数是二次型函数时，最速下降法始终时全局收敛的，而步长固定梯度法只有在步长较小时才有全局收敛的特性，这让我想到了在神经网络中学习率较小时有助于收敛这一事实。</p><p>讨论完了算法的收敛性，接下来展示一下收敛的速度，及收敛率的概念：</p><ul><li><p>对于最速下降法，有结论：<script type="math/tex">f(\boldsymbol{x}^{(k+1)})\le (\frac{\lambda_{max}(Q)-\lambda_{min}(Q)}{\lambda_{max}(Q)+\lambda_{min}(Q)})^2 f(\boldsymbol{x}^{(k)})</script>。</p><p>所以说，当矩阵<script type="math/tex">Q</script>的最大特征值和最小特征值相差很大时收敛很慢。</p><p>从下图中也可以看出，左图中最大特征值和最小特征值相等，收敛很快；右图中最大特征值和最小特征值相差很大，最速下降法收敛很慢。</p><center class="half">    <img src="/img/NLP/最速下降法收敛率1.jpg" width="200"/>    <img src="/img/NLP/最速下降法收敛率2.jpg" width="300"/></center></li><li><p>最速下降法在最坏情况下的收敛阶数为1。</p></li></ul><h4 id="7-1-2-牛顿法"><a href="#7-1-2-牛顿法" class="headerlink" title="7.1.2 牛顿法"></a>7.1.2 牛顿法</h4><h5 id="7-1-2-1-牛顿法引言"><a href="#7-1-2-1-牛顿法引言" class="headerlink" title="7.1.2.1 牛顿法引言"></a>7.1.2.1 牛顿法引言</h5><p>在确定搜索方向时，最速下降法只用到了目标函数的一阶导数也即梯度。这种方式并非非常高效，可能收敛较慢，如果能在迭代方法中引入高阶导数，效率可能会优于最速下降法。牛顿法就是如此，同时使用一阶和二阶导数来确定搜索方向。当初始点与目标函数极小点足够接近时，牛顿法的效率确实优于最速下降法。</p><p>牛顿法的大体思路为：</p><p><img src="/img/NLP/Newton_mthd.jpg" alt="Newton_mthd" style="zoom:30%;" /></p><p>如上图所示，给定一个迭代点之后，首先构造一个二次型函数，其与目标函数在该点处的一阶和二阶导数相等，以此作为目标函数的近似表达式，之后求该二次型函数的极小点，作为下一次迭代的起始点。</p><p>将函数<script type="math/tex">f(\boldsymbol{x})</script>在点<script type="math/tex">\boldsymbol{x}^{(k)}</script>处进行Taylor展开，保留两项：$$f(\boldsymbol{x})\approx f(\boldsymbol{x}^{(k)})+(\boldsymbol{x}-\boldsymbol{x}^{(k)})^T\boldsymbol{g}^{(k)}+\frac{1}{2}(\boldsymbol{x}-\boldsymbol{x}^{(k)})^T\boldsymbol{F}(\boldsymbol{x}^{(k)})(\boldsymbol{x}-\boldsymbol{x}^{(k)})=q(\boldsymbol{x})$$</p><p>其中，<script type="math/tex">\boldsymbol{g}^{(k)}=\nabla f(\boldsymbol{x}^{(k)})</script>，<script type="math/tex">\boldsymbol{F}(\boldsymbol{x}^{(k)})=\nabla ^2f(\boldsymbol{x}^{(k)})</script>。</p><p>为求得函数<script type="math/tex">q(\boldsymbol{x})</script>的极小点，将局部极小点的一阶必要条件应用到函数<script type="math/tex">q(\boldsymbol{x})</script>：$$\nabla q(\boldsymbol{x})=\boldsymbol{g}^{(k)}+\boldsymbol{F}(\boldsymbol{x}^{(k)})(\boldsymbol{x}-\boldsymbol{x}^{(k)})=\boldsymbol{0}$$</p><p>如果<script type="math/tex">\boldsymbol{F}(\boldsymbol{x}^{(k)})>0</script>，则函数<script type="math/tex">q(\boldsymbol{x})</script>的极小点为： $$\boldsymbol{x}^{(k+1)}=\boldsymbol{x}^{(k)}-\boldsymbol{F}(\boldsymbol{x}^{(k)})^{-1}\boldsymbol{g}^{(k)}$$</p><p>这就是最基础的牛顿法的迭代公式。</p><p>由于在实际中我们从来不会直接对矩阵求逆，所以在一次迭代中，牛顿法可以分成两步：</p><ul><li>求解<script type="math/tex">\boldsymbol{F}(\boldsymbol{x}^{(k)})\boldsymbol{d}^{(k)}=-\boldsymbol{g}^{(k)}</script>，得到<script type="math/tex">\boldsymbol{d}^{(k)}</script></li><li>确定下一个迭代点<script type="math/tex">\boldsymbol{x}^{(k+1)}=\boldsymbol{x}^{(k)}+\boldsymbol{d}^{(k)}</script></li></ul><p>第一步需要求解一个<script type="math/tex">n</script>维的线性非齐次方程组，所以在之后会设计更加高效的算法提高牛顿法的实用程度。</p><h5 id="7-1-2-2-牛顿法性质分析"><a href="#7-1-2-2-牛顿法性质分析" class="headerlink" title="7.1.2.2 牛顿法性质分析"></a>7.1.2.2 牛顿法性质分析</h5><p>最基本的牛顿法存在的最大问题是，当目标函数的Hessian矩阵<script type="math/tex">\boldsymbol{F}(\boldsymbol{x}^{(k)})</script>非正定时，牛顿法确定的搜索方向并不一定是目标函数值下降的方向。甚至在某些情况，比如说初始点远离目标函数极小点时，即使Hessian矩阵正定，牛顿法也不具有下降特性。但牛顿法的优势是，如果初始点离极小点比较近，那么牛顿法将表现出相当好的收敛性。</p><p>对于牛顿法的收敛性，有以下两个结论：</p><ul><li>目标函数为二次型函数时，对于任意初始点，牛顿法的收敛阶数为<script type="math/tex">\infty</script></li><li>对于一般形式的目标函数，对于所有与极小点足够接近的初始点，牛顿法能够正常运行，且收敛率至少为<script type="math/tex">2</script></li></ul><p>但是，如果初始点离极小点较远，则牛顿法不一定收敛。而且在求解最小化问题时，该方法不一定具有下降特性。幸运的是，可以对牛顿法做一些修正，使其保持下降特性。</p><p>下面的定理说明了这一点是可行的：</p><p>一个重要定理：对于迭代点<script type="math/tex">\boldsymbol{x}^{(k)}</script>，若Hessian矩阵<script type="math/tex">\boldsymbol{F}(\boldsymbol{x}^{(k)})</script>正定，牛顿法确定的方向<script type="math/tex">-\boldsymbol{F}(\boldsymbol{x}^{(k)})^{-1}\boldsymbol{g}^{(k)}</script>是下降方向。</p><p>所以我们可以对原始的迭代公式做如下修正： $$\boldsymbol{x}^{(k+1)}=\boldsymbol{x}^{(k)}-\alpha_k\boldsymbol{F}(\boldsymbol{x}^{(k)})^{-1}\boldsymbol{g}^{(k)}$$</p><p>其中：$$\alpha_k=\underset{\alpha_k\ge 0}{argmin}\ \ f(\boldsymbol{x}^{(k)}-\alpha_k\boldsymbol{F}(\boldsymbol{x}^{(k)})^{-1}\boldsymbol{g}^{(k)})$$</p><p>也就是每次迭代时都在方向<script type="math/tex">-\boldsymbol{F}(\boldsymbol{x}^{(k)})^{-1}\boldsymbol{g}^{(k)}</script>上开展一次步长，由此确定每次搜素的步长，以保证牛顿法在每次迭代时具有下降特性。</p><h5 id="7-1-2-3-牛顿法的Levenberg-Marquardt修正"><a href="#7-1-2-3-牛顿法的Levenberg-Marquardt修正" class="headerlink" title="7.1.2.3 牛顿法的Levenberg-Marquardt修正"></a>7.1.2.3 牛顿法的Levenberg-Marquardt修正</h5><p>如果在迭代过程中Hessian矩阵不正定，则牛顿法确定的方向<script type="math/tex">-\boldsymbol{F}(\boldsymbol{x}^{(k)})^{-1}\boldsymbol{g}^{(k)}</script>不一定是下降方向。所以为了解决Hessian矩阵可能不正定的问题，可以进行如下的Levenberg-Marquardt修正： $$\boldsymbol{x}^{(k+1)}=\boldsymbol{x}^{(k)}-\alpha_k(\boldsymbol{F}(\boldsymbol{x}^{(k)})+\mu_k\boldsymbol{I})^{-1}\boldsymbol{g}^{(k)}$$</p><p>可以证明，只要<script type="math/tex">\mu_k</script>足够大，总可以保证矩阵<script type="math/tex">\boldsymbol{F}(\boldsymbol{x}^{(k)})+\mu_k\boldsymbol{I}</script>的特征值均为正数，即矩阵<script type="math/tex">\boldsymbol{F}(\boldsymbol{x}^{(k)})+\mu_k\boldsymbol{I}</script>正定，此时可以保证搜索方向<script type="math/tex">-(\boldsymbol{F}(\boldsymbol{x}^{(k)})+\mu_k\boldsymbol{I})^{-1}\boldsymbol{g}^{(k)}</script>是一个下降方向。在此方向上引入一次一维搜索，就可以保证每次迭代中目标函数的下降特性。</p><p>令<script type="math/tex">\mu_k\to 0</script>，牛顿法的Levenberg-Marquardt修正就可以逐步接近牛顿法；令<script type="math/tex">\mu_k\to\infty</script>，Levenberg-Marquardt修正又会表现出步长较小时梯度方法的特性。实际应用中，一开始可以为<script type="math/tex">\mu_k</script>选择较小的值，然后逐渐缓慢增加，直到出现下降特性，即<script type="math/tex">f(\boldsymbol{x}^{(k+1)})<f(\boldsymbol{x}^{(k)})</script>。</p><h4 id="7-1-3-共轭方向法"><a href="#7-1-3-共轭方向法" class="headerlink" title="7.1.3 共轭方向法"></a>7.1.3 共轭方向法</h4><h5 id="7-1-3-1-共轭方向法引言"><a href="#7-1-3-1-共轭方向法引言" class="headerlink" title="7.1.3.1 共轭方向法引言"></a>7.1.3.1 共轭方向法引言</h5><p>从上面可以看到，牛顿法收敛速度较快，但是每一次迭代都需要求解一个<script type="math/tex">n</script>维线性方程组，需要的计算量和计算时间很长，共轭方法可以仅利用Hessian矩阵的部分信息确定每一次的搜索方向，计算速度大大提高。从计算效率来看，共轭方向法位于最速下降法和牛顿法之间。</p><p>共轭方向法具有以下特点：</p><ul><li>对于<script type="math/tex">n</script>维二次型问题，可以在<script type="math/tex">n</script>步之内得到结果。</li><li>作为共轭方向法的典型代表，共轭梯度法不需要计算Hessian矩阵。</li><li>不需要储存<script type="math/tex">n\times n</script>的矩阵，也不需要对其求逆。</li></ul><p>对于不同的迭代算法，影响其效率的关键因素为每次迭代的搜索方向。</p><p>共轭方向法之所以重要是由于有以下性质存在：</p><p>对于一个<script type="math/tex">n</script>变量的二次型函数<script type="math/tex">f(\boldsymbol{x})=\boldsymbol{x}^TQ\boldsymbol{x}-\boldsymbol{b}^T\boldsymbol{x},Q=Q^T>0</script>来说，最好的搜索方向为共轭方向。</p><p>一些基本定义为：</p><p>共轭方向的定义为：如果<script type="math/tex">\mathbb{R}^n</script>中的两个方向<script type="math/tex">\boldsymbol{d}^{(1)}</script>和<script type="math/tex">\boldsymbol{d}^{(2)}</script>满足<script type="math/tex">{\boldsymbol{d}^{(1)}}^T Q\boldsymbol{d}^{(2)}</script>，则称它们关于<script type="math/tex">Q</script>是共轭的。</p><p>如果一组方向向量中，任意两个不同的向量都关于<script type="math/tex">Q</script>共轭，则称这向量组关于<script type="math/tex">Q</script>共轭，且这些向量线性无关。</p><h5 id="7-1-3-2-基本的共轭方向法"><a href="#7-1-3-2-基本的共轭方向法" class="headerlink" title="7.1.3.2 基本的共轭方向法"></a>7.1.3.2 基本的共轭方向法</h5><p>最基本的共轭方向法是针对<script type="math/tex">n</script>维二次型函数的最小化问题： $$f(\boldsymbol{x})=\boldsymbol{x}^TQ\boldsymbol{x}-\boldsymbol{b}^T\boldsymbol{x},Q=Q^T>0$$</p><p>则算法具体为：</p><p>给定初始点和一组关于<script type="math/tex">Q</script>共轭的方向<script type="math/tex">\boldsymbol{d}^{(0)},\boldsymbol{d}^{(1)},...,\boldsymbol{d}^{(n-1)}</script>，迭代公式为：$$\boldsymbol{g}^{(k)}=\nabla f(\boldsymbol{x}^{(k)})=Q\boldsymbol{x}^{(k)}-\boldsymbol{b}$$ $$\alpha_k=-\frac{{\boldsymbol{g}^{(k)}}^T\boldsymbol{d}^{(k)}}{{\boldsymbol{d}^{(k)}}^TQ\boldsymbol{d}^{(k)}}$$ $$\boldsymbol{x}^{(k+1)}=\boldsymbol{x}^{(k)}+\alpha_k\boldsymbol{d}^{(k)}$$</p><p>上述基本的共轭方向法有一些很有意思的性质：</p><ul><li><p>对于任意的初始点，基本的共轭方向算法都能在<script type="math/tex">n</script>次迭代之内收敛到唯一的全局极小点。</p></li><li><p>对于所有的<script type="math/tex">k</script>，都有： $${\boldsymbol{g}^{(k+1)}}^T\boldsymbol{d}^{(k)}=0$$</p><p>这意味着对于每一次迭代时的步长<script type="math/tex">\alpha_k</script>都有： $$\alpha_k={argmin}\ \ f(\boldsymbol{x}^{(k)}+\alpha_k\boldsymbol{d}^{(k)})$$</p><p>还有更一般的结论：对于所有<script type="math/tex">0\le k\le n-1,0\le i \le k</script>，都有： $${\boldsymbol{g}^{(k+1)}}^T\boldsymbol{d}^{(i)}=0$$</p><p>这意味着向量<script type="math/tex">\boldsymbol{g}^{(k)}</script>正交于由向量<script type="math/tex">\boldsymbol{d}^{(0)},\boldsymbol{d}^{(1)},...,\boldsymbol{d}^{(k)}</script>张成的子空间中的任意向量，如下图所示：</p><p><img src="/img/NLP/共轭梯度法_垂直于子空间.jpg" alt="共轭梯度法_垂直于子空间" style="zoom:25%;" /></p><p>可以看出，向量<script type="math/tex">\boldsymbol{g}^{(k)}</script>正交于由向量<script type="math/tex">\boldsymbol{d}^{(0)},\boldsymbol{d}^{(1)},...,\boldsymbol{d}^{(k)}</script>张成的子空间 。  </p></li><li><p>迭代时函数值<script type="math/tex">f(\boldsymbol{x}^{(k+1)})</script>不仅能满足<script type="math/tex">f(\boldsymbol{x}^{(k+1)})=\min_{\alpha_k} f(\boldsymbol{x}^{(k)}+\alpha_k\boldsymbol{d}^{(k)})</script>，还能满足：$$f(\boldsymbol{x}^{(k+1)})=\underset{\alpha_0,...,\alpha_k}{\min }f(\boldsymbol{x}^{(0)}+\sum_{i=0}^k\alpha_i\boldsymbol{d}^{(i)})$$</p><p>这说明<script type="math/tex">f(\boldsymbol{x}^{(k+1)})</script>是目标函数在子空间<script type="math/tex">span[\boldsymbol{d}^{(0)},\boldsymbol{d}^{(1)},...,\boldsymbol{d}^{(k)}]</script>中的极小值。随着迭代不断进行，<script type="math/tex">k</script>不断增大，子空间<script type="math/tex">span[\boldsymbol{d}^{(0)},\boldsymbol{d}^{(1)},...,\boldsymbol{d}^{(k)}]</script>不断扩张，直到充满整个<script type="math/tex">\mathbb{R}^n</script>（由共轭方向的定义，<script type="math/tex">\boldsymbol{d}^{(0)},\boldsymbol{d}^{(1)},...,\boldsymbol{d}^{(n)}</script>是线性无关的）。所以说，最多迭代<script type="math/tex">n</script>次，不断扩张的子空间即可包含原目标函数的极小点。这也就是为什么对于<script type="math/tex">n</script>维二次型问题，共轭方向法可以在<script type="math/tex">n</script>步之内得到结果。</p></li></ul><h5 id="7-1-3-3-共轭梯度法"><a href="#7-1-3-3-共轭梯度法" class="headerlink" title="7.1.3.3 共轭梯度法"></a>7.1.3.3 共轭梯度法</h5><p>基本的共轭方向法效率很高，但是前提是必须事先给定一组<script type="math/tex">Q</script>共轭方向。在共轭梯度法中，不需要提前给定<script type="math/tex">Q</script>共轭方向，而是随着迭代的进行不断产生<script type="math/tex">Q</script>共轭方向。在每次迭代中，利用上一个搜索方向和目标函数在当前点的梯度向量之间的线性组合构造一个新方向，使之与前面已经产生的搜索方向组成<script type="math/tex">Q</script>共轭方向。</p><p><strong>二次型问题中的共轭梯度法：</strong>  $$f(\boldsymbol{x})=\boldsymbol{x}^TQ\boldsymbol{x}-\boldsymbol{b}^T\boldsymbol{x},Q=Q^T>0$$</p><p>初始点为<script type="math/tex">\boldsymbol{x}^{(0)}</script>，第一次迭代时搜素方向采用最速下降法的方向：   $$\boldsymbol{d}^{(0)}=-\boldsymbol{g}^{(0)}$$</p><p>产生第一个迭代点：                  $$\boldsymbol{x}^{(1)}=\boldsymbol{x}^{(0)}+\alpha_0\boldsymbol{d}^{(0)}$$</p><p>其中步长为：  $$\alpha_0=\underset{\alpha_0\ge 0}{argmin}\ \ f(\boldsymbol{x}^{(0)}+\alpha_0\boldsymbol{d}^{(0)})=\alpha_k=-\frac{{\boldsymbol{g}^{(0)}}^T\boldsymbol{d}^{(0)}}{{\boldsymbol{d}^{(0)}}^TQ\boldsymbol{d}^{(0)}}$$</p><p>之后在第<script type="math/tex">k+1</script>次迭代时，可将搜索方向<script type="math/tex">\boldsymbol{d}^{(k+1)}</script>写为当前的梯度<script type="math/tex">\boldsymbol{g}^{(k+1)}</script>和上一次搜索方向<script type="math/tex">\boldsymbol{d}^{(k)}</script>之间的线性组合：$$\boldsymbol{d}^{(k+1)}=-\boldsymbol{g}^{(k+1)}+\beta_k\boldsymbol{d}^{(k)}$$</p><p>按照如下方式选择<script type="math/tex">\beta_k</script>，可以使每次的搜索方向和之前搜索方向组成的向量组组成<script type="math/tex">Q</script>共轭方向：  $$\beta_k=-\frac{{\boldsymbol{g}^{(k+1)}}^TQ\boldsymbol{d}^{(k)}}{{\boldsymbol{d}^{(k)}}^TQ\boldsymbol{d}^{(k)}}$$</p><p><strong>非二次型问题中的共轭梯度法：</strong></p><p>在实际中，我们还会遇到目标函数为非二次型函数的优化问题，如果将二次型函数<script type="math/tex">f(\boldsymbol{x})=\boldsymbol{x}^TQ\boldsymbol{x}-\boldsymbol{b}^T\boldsymbol{x}</script>视为目标函数Taylor展开式的二阶近似，就可以将共轭梯度法推广至一般的非线性目标函数。如果展开点离目标函数极小点较近，则二次型函数可以提供很好的近似。</p><p>在二次型问题中，目标函数的Hessian矩阵<script type="math/tex">Q</script>为常数矩阵，但是对于一般的非线性函数，每次迭代时都必须重新计算Hessian矩阵，需要非常大的计算量。因此在将共轭梯度法推广到非二次型问题的时候，核心就在于消除每次迭代中求Hessian矩阵的环节，即利用当前迭代点的函数值和梯度值的组合代替计算公式中的Hessian矩阵。</p><p>二次型问题中，Hessian矩阵<script type="math/tex">Q</script>只出现在<script type="math/tex">\alpha_k</script>和<script type="math/tex">\beta_k</script>的计算过程中。由于<script type="math/tex">\alpha_k</script>可以由一维搜索过程替代，因此只需要从<script type="math/tex">\beta_k</script>的计算过程中去掉<script type="math/tex">Q</script>即可。利用数学上的转换，可以使得<script type="math/tex">\beta_k</script>的计算只需用到当前迭代点的函数值和梯度值。</p><p>主要包含三种修正方式：</p><ul><li><p>Hestenes-Stiefel公式： $$\beta_k=\frac{{\boldsymbol{g}^{(k+1)}}^T[\boldsymbol{g}^{(k+1)}-\boldsymbol{g}^{(k)}]}{{\boldsymbol{d}^{(k)}}^T[\boldsymbol{g}^{(k+1)}-\boldsymbol{g}^{(k)}]}$$</p></li><li><p>Polak-Ribiere公式：$$\beta_k=\frac{{\boldsymbol{g}^{(k+1)}}^T[\boldsymbol{g}^{(k+1)}-\boldsymbol{g}^{(k)}]}{{\boldsymbol{g}^{(k)}}^T\boldsymbol{g}^{(k)}}$$</p></li><li><p>Fletcher-Reeves公式：      $$\beta_k=\frac{{\boldsymbol{g}^{(k+1)}}^T\boldsymbol{g}^{(k+1)}}{{\boldsymbol{g}^{(k)}}^T\boldsymbol{g}^{(k)}}$$</p></li></ul><p>对于二次型问题，这三个公式是等价的。但是当目标函数为一般的非线性函数时，这三者并不一致。</p><p>对于非二次型问题，共轭梯度法通常不会在<script type="math/tex">n</script>步之内收敛到极小点，随着迭代的进行，搜索方向将不再是<script type="math/tex">Q</script>共轭方向。因此一般会在每经过几次迭代后都重新将搜索方向初始化为目标函数梯度的负方向，然后继续搜索直到满足停止准则。并且对于非二次型问题，精确的一维搜索非常重要。</p><h4 id="7-1-4-拟牛顿法"><a href="#7-1-4-拟牛顿法" class="headerlink" title="7.1.4 拟牛顿法"></a>7.1.4 拟牛顿法</h4><h5 id="7-1-4-1-拟牛顿法引言"><a href="#7-1-4-1-拟牛顿法引言" class="headerlink" title="7.1.4.1 拟牛顿法引言"></a>7.1.4.1 拟牛顿法引言</h5><p>在牛顿法中，每一次迭代时的搜索方向为<script type="math/tex">-\boldsymbol{F}(\boldsymbol{x}^{(k)})^{-1}\boldsymbol{g}^{(k)}</script>，为了避免求Hessian矩阵的逆或者求解<script type="math/tex">n</script>维线性方程组，可以通过设计<script type="math/tex">\boldsymbol{F}(\boldsymbol{x}^{(k)})^{-1}</script>的近似矩阵<script type="math/tex">H_k</script>来代替<script type="math/tex">\boldsymbol{F}(\boldsymbol{x}^{(k)})^{-1}</script>，这就是拟牛顿法的基本思路。<script type="math/tex">\boldsymbol{F}(\boldsymbol{x}^{(k)})^{-1}</script>的近似矩阵<script type="math/tex">H_k</script>随着迭代不断更新，使其拥有<script type="math/tex">\boldsymbol{F}(\boldsymbol{x}^{(k)})^{-1}</script>的部分性质。</p><p>为了使每一次迭代时目标函数值是下降的，即迭代方向<script type="math/tex">-H_k\boldsymbol{g}^{(k)}</script>是下降方向，需要使近似矩阵<script type="math/tex">H_k</script>是正定的。</p><p>在拟牛顿法中，构造Hessian矩阵逆矩阵的近似矩阵时，只需要用到目标函数值和梯度。</p><h5 id="7-1-4-2-Hessian矩阵逆矩阵的近似性质"><a href="#7-1-4-2-Hessian矩阵逆矩阵的近似性质" class="headerlink" title="7.1.4.2 Hessian矩阵逆矩阵的近似性质"></a>7.1.4.2 Hessian矩阵逆矩阵的近似性质</h5><p>我们用<script type="math/tex">H_k</script>表示Hessian矩阵逆矩阵<script type="math/tex">\boldsymbol{F}(\boldsymbol{x}^{(k)})^{-1}</script>的近似矩阵，在每一次迭代时，我们都会得到一个近似矩阵，因此我们实际上要求解一系列的近似矩阵<script type="math/tex">H_0,H_1,H_2,...</script>。首先我们要讨论这些近似矩阵应该满足的条件，这是拟牛顿法的基础。</p><p>当目标为二次型函数时，近似矩阵必须满足： $$H_{k+1}\Delta \boldsymbol{g}^{(i)}=\Delta \boldsymbol{x}^{(i)},0\le i\le k$$</p><p>其中，<script type="math/tex">\Delta \boldsymbol{g}^{(i)}=\boldsymbol{g}^{(i+1)}- \boldsymbol{g}^{(i)},\Delta \boldsymbol{x}^{(i)}=\boldsymbol{x}^{(i+1)}- \boldsymbol{x}^{(i)}</script>。</p><h5 id="7-1-4-3-具体算法"><a href="#7-1-4-3-具体算法" class="headerlink" title="7.1.4.3 具体算法"></a>7.1.4.3 具体算法</h5><p>下图是基于秩1修正公式的拟牛顿法迭代框架：</p><p><img src="/img/NLP/拟牛顿法模板.jpg" alt="拟牛顿法模板" style="zoom:15%;" /></p><p>所有的拟牛顿法的迭代框架都是类似的，区别仅在于从<script type="math/tex">H_k</script>到<script type="math/tex">H_{k+1}</script>的更新公式不同。</p><p>在这里主要讨论三种更新方式：</p><ul><li><p><strong>秩1修正公式：</strong> $$H_{k+1}=H_k+\frac{(\Delta \boldsymbol{x}^{(k)}-H_k\boldsymbol{g}^{(k)})(\Delta \boldsymbol{x}^{(k)}-H_k\boldsymbol{g}^{(k)})^T}{{\Delta \boldsymbol{g}^{(k)}}^T(\Delta \boldsymbol{x}^{(k)}-H_k\boldsymbol{g}^{(k)})}$$</p><p>秩1算法的主要缺点有两个：</p><ul><li>该算法产生的矩阵<script type="math/tex">H_{k+1}</script>不一定是正定的。</li></ul></li><li><p>如果<script type="math/tex">{\Delta \boldsymbol{g}^{(k)}}^T(\Delta \boldsymbol{x}^{(k)}-H_k\boldsymbol{g}^{(k)})</script>接近于0，计算<script type="math/tex">H_{k+1}</script>可能会有一些困难。</p></li><li><p><strong>DFP算法：</strong>$$H_{k+1}=H_k+\frac{\Delta \boldsymbol{x}^{(k)}{\Delta \boldsymbol{x}^{(k)}}^T}{{\Delta \boldsymbol{x}^{(k)}}^T\Delta \boldsymbol{g}^{(k)}}-\frac{[H_k\Delta \boldsymbol{g}^{(k)}]{[H_k\Delta \boldsymbol{g}^{(k)}]}^T}{{\Delta \boldsymbol{g}^{(k)}}^TH_k\Delta \boldsymbol{g}^{(k)}}$$</p><p>DPF算法可以使得矩阵<script type="math/tex">H_{k+1}</script>保持正定。但是，当处理一些规模较大的非二次型问题时，DFP有时会被卡住，迭代无法开展，主要是因为矩阵<script type="math/tex">H_k</script>接近成为奇异矩阵。</p></li><li><p><strong>BFGS算法：</strong>   $$H_{k+1}=H_k+(1-\frac{{\Delta \boldsymbol{g}^{(k)}}^TH_k{\Delta \boldsymbol{g}^{(k)}}}{{\Delta \boldsymbol{g}^{(k)}}^T\Delta \boldsymbol{x}^{(k)}})\frac{\Delta \boldsymbol{x}^{(k)}{\Delta \boldsymbol{x}^{(k)}}^T}{{\Delta \boldsymbol{x}^{(k)}}^T\Delta \boldsymbol{g}^{(k)}}-\frac{H_k\Delta \boldsymbol{g}^{(k)}{\Delta \boldsymbol{x}^{(k)}}^T+{(H_k\Delta \boldsymbol{g}^{(k)}{\Delta \boldsymbol{x}^{(k)}}^T)}^T}{{\Delta \boldsymbol{g}^{(k)}}^T\Delta \boldsymbol{x}^{(k)}}$$</p><p>BFGS算法能够使得近似矩阵<script type="math/tex">H_k</script>一直保持正定。并且在迭代过程中一维搜索的精度不高时，BFGS算法仍然比较稳健。                                            </p></li></ul><h4 id="7-1-5-信赖域法"><a href="#7-1-5-信赖域法" class="headerlink" title="7.1.5 信赖域法"></a>7.1.5 信赖域法</h4><p>这里直接给出《最优化：建模、算法与理论》中关于信赖域法的描述：</p><p>信赖域法的框架为：</p><center class="half">    <img src="/img/NLP/信赖域法框架1.jpg" width="200"/>    <img src="/img/NLP/信赖域法框架2.jpg" width="225"/></center><p>具体算法为：</p><p><img src="/img/NLP/信赖域法算法.jpg" style="zoom:30%;" /></p><h3 id="7-2-约束优化"><a href="#7-2-约束优化" class="headerlink" title="7.2 约束优化"></a>7.2 约束优化</h3><p>约束优化的内容非常丰富，不同的问题往往有不同的特点，我们需要根据每一种问题的具体特点设计最适合该问题的算法。约束优化中，没有万能算法，只要是合适问题的算法就是好算法，我们不能用算法去套问题，而是要结合每一个问题的特色找到最适合该问题的算法。常用的约束优化问题及算法如下图所示：</p><p><img src="/img/NLP/约束优化概览.jpg" alt="约束优化概览" style="zoom:23%;" /></p><p>接下来简要介绍几种常用的约束优化算法。</p><h4 id="7-2-1-投影方向法"><a href="#7-2-1-投影方向法" class="headerlink" title="7.2.1 投影方向法"></a>7.2.1 投影方向法</h4><p>投影方向法的思想很简单，就是将无约束优化问题中计算出的新的迭代点投影到约束集中，让每一次产生的迭代点都满足约束条件。</p><p>无约束优化问题的迭代公式为： $$\boldsymbol{x}^{(k+1)}=\boldsymbol{x}^{(k)}+\alpha_k\boldsymbol{d}^{(k)}$$</p><p>但是新产生的迭代点<script type="math/tex">\boldsymbol{x}^{(k+1)}</script>可能不满足问题的约束条件，即点<script type="math/tex">\boldsymbol{x}^{(k+1)}</script>可能不在约束集<script type="math/tex">\Omega</script>中。因此，一种简单的改进方式就是引入投影。如果<script type="math/tex">\boldsymbol{x}^{(k)}+\alpha_k\boldsymbol{d}^{(k)}</script>在<script type="math/tex">\Omega</script>内，那么就令新的迭代点<script type="math/tex">\boldsymbol{x}^{(k+1)}</script>等于<script type="math/tex">\boldsymbol{x}^{(k)}+\alpha_k\boldsymbol{d}^{(k)}</script>；否则，如果<script type="math/tex">\boldsymbol{x}^{(k)}+\alpha_k\boldsymbol{d}^{(k)}</script>不在<script type="math/tex">\Omega</script>内，应该将其投影到<script type="math/tex">\Omega</script>中，并令投影结果作为新的迭代点<script type="math/tex">\boldsymbol{x}^{(k+1)}</script>。</p><p>如果记<script type="math/tex">\boldsymbol{\Pi}</script>为投影算子，称点<script type="math/tex">\boldsymbol{\Pi}[\boldsymbol{x}]</script>为点<script type="math/tex">\boldsymbol{x}</script>在<script type="math/tex">\Omega</script>上的投影。</p><p>利用投影算子，则改进后的迭代过程为：$$\boldsymbol{x}^{(k+1)}=\boldsymbol{\Pi}[\boldsymbol{x}^{(k)}+\alpha_k\boldsymbol{d}^{(k)}]$$</p><p>对于闭凸集而言，投影算子有如下的定义： $$\boldsymbol{\Pi}[\boldsymbol{x}]=\underset{\boldsymbol{z}\in\Omega}{argmin}\ \ {||\boldsymbol{z}-\boldsymbol{x}||}$$</p><p>意味着<script type="math/tex">\boldsymbol{\Pi}[\boldsymbol{x}]</script>为<script type="math/tex">\Omega</script>中”最接近”<script type="math/tex">\boldsymbol{x}</script>的点。</p><h4 id="7-2-2-拉格朗日法"><a href="#7-2-2-拉格朗日法" class="headerlink" title="7.2.2 拉格朗日法"></a>7.2.2 拉格朗日法</h4><p>基于拉格朗日函数的求解方法的基本思路是利用梯度法在更新决策变量的同时更新拉格朗日乘子向量。</p><ul><li><p>针对<strong>仅含等式约束</strong>优化问题的拉格朗日法： $$\boldsymbol{x}^{(k+1)}=\boldsymbol{x}^{(k)}-\alpha_k(\nabla f(\boldsymbol{x}^{(k)})+D\boldsymbol{h}(\boldsymbol{x}^{(k)})^T{\boldsymbol{\lambda}^{(k)}})$$  $$\boldsymbol{\lambda}^{(k+1)}=\boldsymbol{\lambda}^{(k)}+\beta_k\boldsymbol{h}(\boldsymbol{x}^{(k)})$$</p><p>可以看出，<script type="math/tex">\boldsymbol{x}^{(k)}</script>的更新方程是一种使得拉格朗日函数关于自变量<script type="math/tex">\boldsymbol{x}</script>极小化的梯度算法；<script type="math/tex">\boldsymbol{\lambda}^{(k)}</script>的更新方程也是一种梯度方程，使得拉格朗日函数关于自变量<script type="math/tex">\boldsymbol{\lambda}</script>极大化。</p></li><li><p>针对<strong>含不等式约束</strong>优化问题的拉格朗日法：$$\boldsymbol{x}^{(k+1)}=\boldsymbol{x}^{(k)}-\alpha_k(\nabla f(\boldsymbol{x}^{(k)})+D\boldsymbol{g}(\boldsymbol{x}^{(k)})^T{\boldsymbol{\mu}^{(k)}})$$   $$\boldsymbol{\mu}^{(k+1)}=\max\{\boldsymbol{\mu}^{(k)}+\beta_k\boldsymbol{g}(\boldsymbol{x}^{(k)}),0\}$$</p><p>和上面一样，<script type="math/tex">\boldsymbol{x}^{(k)}</script>的更新方程是一种梯度法，使得拉格朗日函数关于自变量<script type="math/tex">\boldsymbol{x}</script>极小化；<script type="math/tex">\boldsymbol{\mu}^{(k)}</script>的更新方程是一种投影梯度法，使得拉格朗日函数关于自变量<script type="math/tex">\boldsymbol{\mu}</script>极大化。</p></li></ul><h4 id="7-2-3-罚函数法"><a href="#7-2-3-罚函数法" class="headerlink" title="7.2.3 罚函数法"></a>7.2.3 罚函数法</h4><p>罚函数法通过引入罚函数的概念，将有约束优化问题转化为无约束优化问题进行求解。</p><p>即将原始的约束优化问题： $$\min  \ \ \ \ \ f(\boldsymbol{x})$$   $$ s.t. \ \ \ \ \boldsymbol{x}\in \Omega$$</p><p>转化为下述无约束优化问题：   $$\min  \ \ \ \ \ f(\boldsymbol{x})+\gamma P(\boldsymbol{x})$$</p><p>其中<script type="math/tex">P(\boldsymbol{x})</script>称为罚函数。罚函数的主要作用在于对可行集之外的点进行惩罚。</p><h2 id="8-初始点的选取"><a href="#8-初始点的选取" class="headerlink" title="8 初始点的选取"></a><strong>8 初始点的选取</strong></h2><p>在非线性规划中，如何选取一个好的初始点更像是一个工程问题而非数学问题。在非凸优化问题中，迭代算法很有可能陷入一个局部最优解而无法找到全局最优解。因此，工程上一个常见的做法是，随机在全局选取很多个点作为初始点开始优化算法的迭代过程，如果有很多个初始点最终收敛到同一个点，那么这个点很有可能就是全局最小点。或者也可以在所有的最终收敛点中选择目标函数值最小的一个。在一篇关于轨迹优化的入门论文中，通常是从一个满足动力学约束的显而易见的轨迹开始迭代，最终得到一个所需动力最小的最优轨迹。</p><h2 id="9-终止准则"><a href="#9-终止准则" class="headerlink" title="9 终止准则"></a><strong>9 终止准则</strong></h2><p>一般而言，可以利用局部极小点的一阶必要条件作为终止准则，比如说无约束优化和集合优化问题可以用梯度为0作为迭代的终止条件，等式优化问题可以使用拉格朗日条件作为终止条件，而含有不等式约束的优化问题可以使用KKT条件。</p><p>但是在实际应用中，采用数值计算方法很难恰好得到梯度为0的结果。所以一种很实用的停止准则是采用梯度的范数<script type="math/tex">||\nabla f(\boldsymbol{x}^{(k)})||</script>，如果梯度的范数小于某个预设的阈值，则迭代停止。此外，还可以计算两个相邻迭代点对应的目标函数值之差的绝对值<script type="math/tex">|f(\boldsymbol{x}^{(k+1)})-f(\boldsymbol{x}^{(k)})|</script>，如果小于某个阈值，则迭代停止。还有一种停止规则是计算相邻两个迭代点差值的范数<script type="math/tex">||\boldsymbol{x}^{(k+1)}-\boldsymbol{x}^{(k)}||</script>，如果小于某个阈值，则迭代停止。</p><p>针对无约束优化和集合优化问题，总结如下：</p><ul><li>绝对的停止准则一般有：<ul><li>梯度的范数：<script type="math/tex">||\nabla f(\boldsymbol{x}^{(k)})||<\varepsilon</script></li><li>相邻迭代点对应的目标函数值之差的绝对值：<script type="math/tex">|f(\boldsymbol{x}^{(k+1)})-f(\boldsymbol{x}^{(k)})|<\varepsilon</script></li><li>相邻两个迭代点差值的范数：<script type="math/tex">||\boldsymbol{x}^{(k+1)}-\boldsymbol{x}^{(k)}||<\varepsilon</script></li></ul></li><li>上述停止规则还可以改为相对值：<ul><li>相对的相邻迭代点对应的目标函数值之差的绝对值：<script type="math/tex">\frac{|f(\boldsymbol{x}^{(k+1)})-f(\boldsymbol{x}^{(k)})|}{|f(\boldsymbol{x}^{(k)})|}<\varepsilon</script></li><li>相对的相邻两个迭代点差值的范数：<script type="math/tex">\frac{||\boldsymbol{x}^{(k+1)}-\boldsymbol{x}^{(k)}||}{||\boldsymbol{x}^{(k)}||}<\varepsilon</script></li></ul></li><li>为了避免相对停止规则的分母过小，可以做如下修改：<ul><li>目标函数之差：<script type="math/tex">\frac{|f(\boldsymbol{x}^{(k+1)})-f(\boldsymbol{x}^{(k)})|}{max\{1,|f(\boldsymbol{x}^{(k)})|\}}<\varepsilon</script></li><li>迭代点差值的范数：<script type="math/tex">\frac{||\boldsymbol{x}^{(k+1)}-\boldsymbol{x}^{(k)}||}{max\{1,||\boldsymbol{x}^{(k)}||\}}<\varepsilon</script></li></ul></li></ul><h2 id="10-参考资料"><a href="#10-参考资料" class="headerlink" title="10 参考资料"></a>10 参考资料</h2><p>[1] 《最优化导论》 (非常好的一本入门书)</p><p>[2]  西安交通大学运筹学课程翟桥柱老师的课件 (老师的课件简直太好了！)</p><p>[3] 《最优化：建模、算法与理论》关于最优化理论更为全面、深入的介绍</p>]]></content>
    
    
    
    <tags>
      
      <tag>Math</tag>
      
      <tag>Optimization</tag>
      
      <tag>Nonlinear Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>四旋翼飞控整体框架介绍：建模、状态估计和控制</title>
    <link href="/2021/12/04/%E5%9B%9B%E6%97%8B%E7%BF%BC%E9%A3%9E%E6%8E%A7%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/"/>
    <url>/2021/12/04/%E5%9B%9B%E6%97%8B%E7%BF%BC%E9%A3%9E%E6%8E%A7%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="1-写在前面"><a href="#1-写在前面" class="headerlink" title="1 写在前面"></a>1 写在前面</h2><p>由于最近在做的一个大创项目中要用到四旋翼，便研究了一下关于四旋翼的相关理论，学着学着，萌生了记录一下整体框架的想法，以防之后遗忘。本文主要介绍四旋翼飞控的整体框架，从旋转表示法到动态模型的建立，再从状态估计到控制算法。四旋翼包含的理论和知识涵盖甚广，在一篇文章中包含所有的详细推导是不切实际的，因此本文的写作目的主要是：记录一下每个模块中的主要知识点和思想，以及不同模块之间的联系和交叉应用，达到心中“既有树木，又有森林”的效果。</p><p>四旋翼主要包括以下模块：</p><ul><li>旋转表示法：欧拉角、旋转矩阵、四元数、轴-角表示法</li><li>动态模型：运动学模型、动力学模型（牛顿第二定律—平移运动、欧拉方程—旋转运动）</li><li>状态估计：测量模型（加速度计、陀螺仪、磁力计）、状态估计（互补滤波、卡尔曼滤波、Mahony滤波等）</li><li>控制算法：位置控制、姿态控制、控制算法（PID）</li></ul><p>接下来会对以上模块分别进行介绍。</p><h2 id="2-旋转表示法"><a href="#2-旋转表示法" class="headerlink" title="2 旋转表示法"></a>2 旋转表示法</h2><h3 id="2-1-动机-motivation"><a href="#2-1-动机-motivation" class="headerlink" title="2.1 动机(motivation)"></a>2.1 动机(motivation)</h3><p>旋转表示法是之后建立动态模型、确定状态估计方程、明确控制算法的基础，非常重要。之所以旋转表示法有如此重要的地位，是因为在之后的系统动态模型和控制模型中，都要在不同的坐标系之间进行转换，而搭起不同坐标系之间桥梁的就是坐标系之间的相对旋转，描述这种旋转就需要用到旋转表示法的知识。</p><p>比如说，在系统的运动学模型和动力学模型中，同时包含有机体坐标系和地球固连坐标系。一方面，希望在地球固连坐标系下表示位置和速度，方便飞手的控制且与GPS的测量一致；同时我们希望在机体坐标系下表示拉力和力矩，这样不仅非常直观，且各种传感器的测量值也在机体坐标系下表示。这就需要我们可以描述同一个向量在两个坐标系下不同的表示之间的关系，一般可以通过欧拉角、旋转矩阵、四元数这三种方式表示，统称为旋转表示法。</p><h3 id="2-2-关于坐标系"><a href="#2-2-关于坐标系" class="headerlink" title="2.2 关于坐标系"></a>2.2 关于坐标系</h3><p>在研究四旋翼时，我们一般会用到两个坐标系：<strong>机体坐标系</strong><script type="math/tex">o_bx_by_bz_b</script>和<strong>地球固连坐标系</strong><script type="math/tex">o_ex_ey_ez_e</script>。同一个向量<script type="math/tex">r</script>在两种坐标系下可能有不同的表示，一般我们记向量<script type="math/tex">r</script>在机体坐标系下的表示为<script type="math/tex">^{b}r</script>，在地球固连坐标系下的表示为<script type="math/tex">^{e}r</script>。旋转表示法解决的主要问题就是：<strong>同一个向量在两种坐标系下的表示有什么联系，我们怎样由其中的一中表示推出另外一种表示</strong>。</p><h3 id="2-3-欧拉角"><a href="#2-3-欧拉角" class="headerlink" title="2.3 欧拉角"></a>2.3 欧拉角</h3><p>欧拉角是最直观的一种的旋转表示法，但是由于其使用三个参数来表示三个自由度的旋转，不可避免的会出现奇异性问题，即通常所说的“万向节死锁”，在俯仰角或滚转角接近90°时出现自由度退化的问题。</p><p>本文统一采用<script type="math/tex">z-y-x</script>欧拉角，俯仰角Pitch、滚转角Roll、偏航角Yaw分别记做<script type="math/tex">\theta、\phi、\psi</script>，在地球固连坐标系旋转至机体坐标系的过程中，先沿地球固连坐标系的<script type="math/tex">z</script>轴旋转偏航角<script type="math/tex">\psi</script>，在沿新得到的临时机体坐标系的$y$轴旋转俯仰角<script type="math/tex">\theta</script>，最后沿第二次新得到的临时机体坐标系的<script type="math/tex">x</script>轴旋转滚转角<script type="math/tex">\phi</script>，最后得到机体坐标系。</p><p><img src="/img/quadrotor/Eular Angle.png" alt="Eular Angle"></p><p>上述过程可以用三个矩阵来表示，分别为<script type="math/tex">\boldsymbol{R}_z(\psi)、\boldsymbol{R}_y(\theta)、\boldsymbol{R}_x(\phi)</script>：   $$\boldsymbol{R}_z(\psi) = \begin{pmatrix}cos\psi& sin\psi &0 \\ -sin\psi&cos\psi  &0 \\0 & 0 &1\end{pmatrix} =\boldsymbol{R}_e^k   $$     $$\boldsymbol{R}_y(\theta) = \begin{pmatrix}cos\theta& 0 &-sin\theta \\0  &1 \\sin\theta & 0 &cos\theta\end{pmatrix}=\boldsymbol{R}_k^n$$     $$\boldsymbol{R}_x(\phi) = \begin{pmatrix}1& 0 &0 \\ 0&cos\phi  &sin\phi \\ 0 & -sin\phi &cos\phi\end{pmatrix}=\boldsymbol{R}_n^b $$  </p><p>上面三个矩阵可以采用线性变换的知识轻松得到，即：从坐标系1到坐标系2的线性变换对应的矩阵，由坐标系1的每一个基在坐标系2下的坐标构成。例如：<script type="math/tex">\boldsymbol{R}_b^e=[^e\boldsymbol{b}_1 \quad ^e\boldsymbol{b}_2 \quad^e\boldsymbol{b}_3]</script>。</p><p>最终的姿态解算结果以及控制器的设计大部分是基于欧拉角进行的，之后会给出如何由旋转矩阵和四元数得到欧拉角。</p><p>由上述的旋转过程和欧拉角的定义可以得到三个欧拉角的变化率和机体角速度的关系：$$\begin{pmatrix}\omega_{xb}\\\omega_{yb} \\\omega_{zb}\end{pmatrix} = \begin{pmatrix}1& 0 &-sin\theta \\0&cos\phi  &cos\theta sin\phi \\0 & -sin\phi &cos\theta cos\phi\end{pmatrix}\begin{pmatrix}\dot{\phi}\\\dot{\theta} \\\dot{\psi}\end{pmatrix}$$</p><p>推导上式，考虑三个欧拉角坐标系<script type="math/tex">k、n、b</script>（即为旋转过程中的三个中间坐标系）即可。</p><p>反之，有：$$\begin{pmatrix}\dot{\phi}\\\dot{\theta} \\\dot{\psi}\end{pmatrix} = \begin{pmatrix}1& tan\theta sin\phi &tan\theta cos\phi\\0&cos\phi  &-sin\phi \\0 & sin\phi / cos\theta&cos\phi /cos\theta\end{pmatrix}\begin{pmatrix}\omega_{xb}\\\omega_{yb} \\\omega_{zb}\end{pmatrix}$$      </p><p>简记为：                                                                  $$\dot{\boldsymbol{\Theta}}=W \cdot \ ^b\boldsymbol{\omega}$$</p><p>上面两个式子的意义在于，我们利用陀螺仪只能测出机体角速度在机体坐标系下的表示，即<script type="math/tex">\begin{pmatrix}\omega_{xb}&\omega_{yb} &\omega_{zb}\end{pmatrix}^T</script>，为了通过积分得到三个欧拉角，我们必须用上面的式子计算出三个欧拉角的变化率<script type="math/tex">\begin{pmatrix}\dot{\phi} & \dot{\theta} &\dot{\psi}\end{pmatrix}^T</script>，然后进行数值积分，计算出目前的欧拉角，即<script type="math/tex">\phi[n]=\phi[n-1]+\dot{\phi}\times \Delta t</script>，依次迭代，不断更新。</p><h3 id="2-4-旋转矩阵"><a href="#2-4-旋转矩阵" class="headerlink" title="2.4 旋转矩阵"></a>2.4 旋转矩阵</h3><p>定义由坐标系1到坐标系2的旋转矩阵为<script type="math/tex">\boldsymbol{R}_1^2</script>，使用方法为<script type="math/tex">^{2}r=R_1^{2}\ ^{1}r</script>，即将向量在坐标系1下的坐标表示转换为在坐标系2下的坐标表示。</p><p>由上述欧拉角的旋转过程可以推出从机体坐标系到地球固连坐标系的旋转矩阵<script type="math/tex">R_b^e</script>为：$$\boldsymbol{R}_b^e=(\boldsymbol{R}_e^b)^{-1}=\boldsymbol{R}_z^T(\psi)\boldsymbol{R}_y^T(\theta)\boldsymbol{R}_x^T(\phi)=\begin{pmatrix}cos\theta cos\phi & cos\psi sin\theta sin\phi-sin\psi cos\phi &cos\psi sin\theta cos\phi +sin\psi sin\phi \\ cos\theta sin\psi&sin\psi sin\theta sin\phi+cos\psi cos\phi  &sin\psi sin\theta cos\phi -cos\psi sin\phi \\-sin\theta & sin\phi  cos\theta&cos\phi cos\theta\end{pmatrix}$$   </p><p>也可以由旋转矩阵求欧拉角，若记上述的旋转矩阵为：$$\boldsymbol{R}_b^e=\begin{pmatrix}r_{11}&r_{12}&r_{13}\\r_{21}&r_{22}&r_{23}\\r_{31}&r_{32}&r_{33}\end{pmatrix}$$</p><p>则有：</p><ul><li><p>偏航角   <script type="math/tex">\psi=arctan\frac{r_{21}}{r_{11}}</script></p></li><li><p>俯仰角   <script type="math/tex">\theta = arcsin(-r_{31})</script></p></li><li><p>滚转角   <script type="math/tex">\phi = arctan\frac{r_{32}}{r_{33}}</script></p></li></ul><p>由旋转矩阵的正交性，从地球固连坐标系到机体坐标系的旋转矩阵<script type="math/tex">R_e^b</script>为：</p><p>​                                                                    $$\boldsymbol{R}_e^b=(\boldsymbol{R}_b^e)^{-1}=(\boldsymbol{R}_b^e)^T$$</p><p>对旋转矩阵求逆只需要转置即可。</p><p>不过也正是因为旋转矩阵的正交性带来了额外的约束，导致我们在利用非线性优化进行状态估计时出现了不必要的麻烦，所以我们一般利用接下来的四元数进行优化算法的设计。或者用更加高级的李群和李代数作为工具进行姿态估计，这也是SLAM中常用的做法，不过在四旋翼姿态解算中很少使用。</p><p>旋转矩阵的导数为：$$\frac{d\boldsymbol{R}_b^e}{dt}=\boldsymbol{R}_b^e[^b\boldsymbol{\omega}]_{\times}$$</p><p>展开为： $$\frac{d\boldsymbol{R}_b^e}{dt}=\boldsymbol{R}_b^e[^b\boldsymbol{\omega}]_{\times}=\begin{pmatrix}cos\theta cos\phi & cos\psi sin\theta sin\phi-sin\psi cos\phi &cos\psi sin\theta cos\phi +sin\psi sin\phi \\ cos\theta sin\psi&sin\psi sin\theta sin\phi+cos\psi cos\phi  &sin\psi sin\theta cos\phi -cos\psi sin\phi \\-sin\theta & sin\phi  cos\theta&cos\phi cos\theta\end{pmatrix}  \begin{pmatrix}0&-\omega_{zb}&\omega_{yb}\\\omega_{zb}&0& -\omega_{xb}\\-\omega_{yb}&\omega_{xb}&0\end{pmatrix}$$</p><h3 id="2-5-四元数"><a href="#2-5-四元数" class="headerlink" title="2.5 四元数"></a>2.5 四元数</h3><p>单位四元数也可以用来表示旋转，具体理论在此不做过多介绍。</p><p>假定地球固连坐标系到机体坐标系的旋转四元数为<script type="math/tex">\boldsymbol{q}_e^b=\begin{pmatrix}q_0 & q_1 &q_2&q_3\end{pmatrix}^T</script>，则有：$$\begin{pmatrix}0\\ ^{e}\boldsymbol{r}\end{pmatrix} =(\boldsymbol{q}_b^e)^{-1}\otimes \begin{pmatrix}0\\ ^{b}\boldsymbol{r}\end{pmatrix} \otimes\boldsymbol{q}_b^e =\boldsymbol{q}_e^b\otimes \begin{pmatrix}0\\ ^{b}\boldsymbol{r}\end{pmatrix} \otimes(\boldsymbol{q}_e^b)^{-1}$$</p><p>由上式可得：                                          $$^{e}\boldsymbol{r}=\boldsymbol{C}(\boldsymbol{q}_e^b)\cdot \ ^{b}\boldsymbol{r}$$</p><p>其中：         $$\boldsymbol{C}(\boldsymbol{q}_e^b)=\begin{pmatrix}q_0^2+q_1^2-q_2^2-q_3^2&2(q_1q_2-q_0q_3)&2(q_1q_3+q_0q_2)\\2(q_1q_2+q_0q_3)&q_0^2-q_1^2+q_2^2-q_3^2&2(q_2q_3-q_0q_1)\\2(q_1q_3-q_0q_2)&2(q_2q_3+q_0q_1)&q_0^2-q_1^2-q_2^2+q_3^2\end{pmatrix}$$</p><p>上式可以看成是旋转矩阵的四元数表示，则根据由旋转矩阵求欧拉角的方法，可以得到由四元数求欧拉角的方法：</p><ul><li><p>偏航角   <script type="math/tex">\psi=arctan\frac{r_{21}}{r_{11}}=arctan\frac{2(q_1q_2+q_0q_3)}{q_0^2+q_1^2-q_2^2-q_3^2}</script></p></li><li><p>俯仰角   <script type="math/tex">\theta = arcsin(-r_{31})=arcsin(-2(q_1q_3-q_0q_2))</script></p></li><li><p>滚转角   <script type="math/tex">\phi = arctan\frac{r_{32}}{r_{33}}=arctan\frac{2(q_2q_3+q_0q_1)}{q_0^2-q_1^2-q_2^2+q_3^2}</script></p></li></ul><p>在利用四元数进行优化时，四元数的导数是一个非常关键的信息，在迭代优化中起到非常重要的作用，幸运的是，四元数导数和机体角速度可以建立起关系：$$\dot{\boldsymbol{q}_e^b}=\frac{1}{2}\begin{pmatrix}0&-^{b}\boldsymbol{\omega}^T\\^{b}\boldsymbol{\omega}&-[^{b}\boldsymbol{\omega}]_{\times}\end{pmatrix}\boldsymbol{q}_e^b$$</p><p>即：$$\dot{\boldsymbol{q}_e^b}=\frac{1}{2}\begin{pmatrix}0&-\omega_{xb}&-\omega_{yb}&-\omega_{zb} \\\omega_{xb}&0&\omega_{zb}&-\omega_{yb}\\\omega_{yb}&-\omega_{zb}&0& \omega_{xb}\\\omega_{zb}&\omega_{yb}&-\omega_{xb}&0\end{pmatrix}\begin{pmatrix}q_0 \\ q_1 \\q_2\\q_3\end{pmatrix}$$</p><p>在Mahony姿态解算算法中，就是在修正过陀螺仪得到的机体角速度之后，利用上式计算四元数导数，以修正当前的四元数，不断迭代估计当前姿态。</p><h2 id="3-模型建立"><a href="#3-模型建立" class="headerlink" title="3 模型建立"></a>3 模型建立</h2><h3 id="3-1-运动学模型"><a href="#3-1-运动学模型" class="headerlink" title="3.1 运动学模型"></a>3.1 运动学模型</h3><p>运动学模型分为平移和旋转两个方面。</p><p>对于刚体，我们在讨论<strong>平移</strong>运动时只考虑重心的平移运动，记四旋翼的重心向量为<script type="math/tex">^e\boldsymbol{p}</script>，多旋翼的重心速度为<script type="math/tex">^e\boldsymbol{v}</script>，</p><p>则有：                                                                     $$^e\dot{\boldsymbol{p}}\ = \ ^e\boldsymbol{v}$$</p><p>上式即为位置的导数等于速度，很简单。</p><p>在讨论<strong>旋转</strong>或者说姿态运动学模型时，根据我们选用的旋转表示法的不同，可以分为三种模型：</p><ul><li>欧拉角模型： <script type="math/tex">\dot{\boldsymbol{\Theta}}=W \cdot \ ^b\boldsymbol{\omega}</script></li><li>旋转矩阵模型：<script type="math/tex">\frac{d\boldsymbol{R}_b^e}{dt}=\boldsymbol{R}_b^e[^b\boldsymbol{\omega}]_{\times}</script></li><li>四元数模型：  <script type="math/tex">\dot{\boldsymbol{q}_e^b}=\frac{1}{2}\begin{pmatrix}0&-^{b}\boldsymbol{\omega}^T\\^{b}\boldsymbol{\omega}&-[^{b}\boldsymbol{\omega}]_{\times}\end{pmatrix}\boldsymbol{q}_e^b</script></li></ul><h3 id="3-2-刚体动力学模型"><a href="#3-2-刚体动力学模型" class="headerlink" title="3.2 刚体动力学模型"></a>3.2 刚体动力学模型</h3><p>动力学模型同样分为平移和旋转两个方面，我们分别称为位置动力学模型和姿态动力学模型。</p><p><strong>前置知识：</strong></p><p>在讨论位置动力学模型时，我们使用的主要工具是牛顿第二定律：$$\boldsymbol{F}=m\boldsymbol{a}$$</p><p>在讨论姿态动力学模型时，我们使用的主要工具是欧拉方程（<script type="math/tex">Eular \ equation</script>）:</p><p>固定坐标系下：                                               $$^G\boldsymbol{M}=\frac{^Gd}{dt} \ ^G\boldsymbol{L}$$</p><p>机体坐标系下：        $$^B\boldsymbol{M}=\frac{^Gd}{dt} \ ^B\boldsymbol{L} \ = \ ^B\dot{\boldsymbol{L}} + \ ^B_G\boldsymbol{\omega}_B \times ^B\boldsymbol{L}= \ ^BI \ ^B_G\dot{\boldsymbol{\omega}}_B \ + \ ^B_G\boldsymbol{\omega}_B\times(^BI \ ^B_G\boldsymbol{\omega}_B)$$</p><p>在讨论同一个向量在不同坐标系下的导数时，我们有如下关系：$$ \frac{^Gd}{dt} \ ^B\Box \ = \ \frac{^Bd}{dt} \ ^B\Box + \ ^B_G\boldsymbol{\omega}_B \times ^B\Box$$</p><p><strong>四旋翼的刚体动力学模型：</strong></p><p><strong>位置动力学模型：</strong></p><p>在地球固连坐标系下，根据牛顿第二定律，我们有：$$^e\dot{\boldsymbol{v}}\ = \ g\boldsymbol{e}_3 - \frac{f}{m} ^e\boldsymbol{b}_3 $$</p><p>上式中，<script type="math/tex">f</script>为螺旋桨产生的总拉力，易知拉力始终在机体坐标系的z轴方向，因而在地球固连坐标系看来，方向不断变化，且和飞行器的姿态有关，由上文可知，<script type="math/tex">^e\boldsymbol{b}_3 = \boldsymbol{R}_b^e\boldsymbol{e}_3</script>，</p><p>所以可以得到最终结果：                            $$^e\dot{\boldsymbol{v}}\ = \ g\boldsymbol{e}_3 - \frac{f}{m} \boldsymbol{R}_b^e\boldsymbol{e}_3 $$  </p><p>其实一句话概括，就是我们把机体坐标系下的拉力矢量转化为世界坐标系下的表示，再在世界坐标系下应用牛顿第二定律。</p><p><strong>姿态动力学模型：</strong></p><p>根据欧拉方程，我们有：                 $$^b\tau_{total}=J\cdot \ ^b\dot{\boldsymbol{\omega}}+ \ ^b\boldsymbol{\omega}\times(J\cdot \ ^b\boldsymbol{\omega})$$</p><p>其中<script type="math/tex">^b\tau_{total}</script>为四旋翼所受力矩在机体坐标系下的表示，主要有两个部分：螺旋桨在机体轴上产生的力矩<script type="math/tex">\tau</script>以及陀螺力矩<script type="math/tex">G_a</script>。</p><h3 id="3-3-模型小结"><a href="#3-3-模型小结" class="headerlink" title="3.3 模型小结"></a>3.3 模型小结</h3><p>整体而言，四旋翼的飞行控制刚体模型可以被概括为下面四个式子：</p><ul><li>运动学位置模型：<script type="math/tex">^e\dot{\boldsymbol{p}}\ = \ ^e\boldsymbol{v}</script></li><li>运动学姿态模型：</li><li>欧拉角模型： <script type="math/tex">\dot{\boldsymbol{\Theta}}=W \cdot \ ^b\boldsymbol{\omega}</script><ul><li>旋转矩阵模型：<script type="math/tex">\frac{d\boldsymbol{R}_b^e}{dt}=\boldsymbol{R}_b^e[^b\boldsymbol{\omega}]_{\times}</script></li></ul></li><li>四元数模型：  <script type="math/tex">\dot{\boldsymbol{q}_e^b}=\frac{1}{2}\begin{pmatrix}0&-^{b}\boldsymbol{\omega}^T\\^{b}\boldsymbol{\omega}&-[^{b}\boldsymbol{\omega}]_{\times}\end{pmatrix}\boldsymbol{q}_e^b</script></li><li>动力学位置模型： <script type="math/tex">^e\dot{\boldsymbol{v}}\ = \ g\boldsymbol{e}_3 - \frac{f}{m} \boldsymbol{R}_b^e\boldsymbol{e}_3</script>  </li><li>动力学姿态模型：<script type="math/tex">^b\tau + \ ^bG_a=J\cdot \ ^b\dot{\boldsymbol{\omega}}+ \ ^b\boldsymbol{\omega}\times(J\cdot \ ^b\boldsymbol{\omega})</script></li></ul><p>在系统的运动学模型和动力学模型中，同时包含有机体坐标系和地球固连坐标系。一方面，希望在<strong>地球固连坐标系下表示位置和速度</strong>，方便飞手的控制且与GPS的测量一致；同时我们希望<strong>在机体坐标系下表示拉力和力矩</strong>，这样不仅非常直观，且各种传感器的测量值也在机体坐标系下表示。</p><h2 id="4-状态估计"><a href="#4-状态估计" class="headerlink" title="4 状态估计"></a>4 状态估计</h2><h3 id="4-1-传感器测量模型"><a href="#4-1-传感器测量模型" class="headerlink" title="4.1 传感器测量模型"></a>4.1 传感器测量模型</h3><p><strong>加速度计：</strong></p><p>利用加速度计可以测量机体的俯仰角和滚转角，若记<script type="math/tex">^{b}\boldsymbol{a}=\begin{pmatrix}a_{xb} & a_{yb} &a_{zb}\end{pmatrix}^T</script>为加速度计的测量值，即加速度矢量在机体坐标系下的表示，则机体的俯仰角和滚转角为：</p><ul><li><p>俯仰角：<script type="math/tex">\theta_{a}=arcsin(\frac{a_{xb}}{g})</script></p></li><li><p>滚转角：<script type="math/tex">\phi_a=-arcsin(\frac{a_{yb}}{gcos\theta_a})</script></p></li></ul><p>加速度计没有累积误差，但动态响应特性较差，测量噪声较大。                      </p><p><strong>陀螺仪：</strong></p><p>陀螺仪可以测量机体角速度在机体坐标系下的表示，测量值可记为<script type="math/tex">^{b}\boldsymbol{\omega}=\begin{pmatrix}\omega_{xb} & \omega_{yb} &\omega_{zb}\end{pmatrix}^T</script>。</p><p>在小角度的情况下，三个欧拉角的变化率近似等于机体角速度在机体坐标系下的表示，此时直接对机体角速度进行离散积分即可得到三个欧拉角。</p><p>但当进行大角度飞行时，必须先由<script type="math/tex">\begin{pmatrix}\dot{\phi}\\\dot{\theta} \\\dot{\psi}\end{pmatrix} = \begin{pmatrix}1& tan\theta sin\phi &tan\theta cos\phi\\0&cos\phi  &-sin\phi \\0 & sin\phi / cos\theta&cos\phi /cos\theta\end{pmatrix}\begin{pmatrix}\omega_{xb}\\\omega_{yb} \\\omega_{zb}\end{pmatrix}</script>得到三个欧拉角的变化率，然后再对三个欧拉角的变化率分别进行离散积分，才能得到正确的欧拉角。</p><p>陀螺仪动态响应快，测量精度高，但是在积分得到角度的过程中不可避免的会产生累积误差。</p><p><strong>磁力计：</strong></p><p>磁力计可以测出地磁场在机体坐标系下的坐标：<script type="math/tex">^{b}\boldsymbol{m}=\begin{pmatrix}m_{xb} & m_{yb} &m_{zb}\end{pmatrix}^T</script>，在得到偏航角角时。必须先利用之前得到的俯仰角和滚转角将磁力计测量值投影到水平面，得到：</p><ul><li>x轴分量：<script type="math/tex">\overline{m}_{xe}=m_{xb}cos\theta+m_{yb}sin\phi sin\theta+m_{zb}cos\phi sin\theta</script></li><li>y轴分量：<script type="math/tex">\overline{m}_{ye}=m_{yb}cos\phi -m_{zb}sin\phi</script></li></ul><p>之后可以得到偏航角：                   $$\psi_{mag}=arctan2(\overline{m}_{xe},\overline{m}_{ye})$$  </p><p>磁力计没有累积误差，但动态响应特性较差，测量噪声较大，且容易受到干扰。</p><h3 id="4-2-互补滤波"><a href="#4-2-互补滤波" class="headerlink" title="4.2 互补滤波"></a>4.2 互补滤波</h3><p>简单来说，互补滤波就是对加速度计和磁力计解算得到的数据进行低通滤波，对陀螺仪解算得到的数据进行高通滤波。既可以保留加速度计和磁力计解算得到的数据无漂移的优势保留，也可以将陀螺仪解算得到的数据噪声小的优势保留下来。</p><p>以俯仰角为例，互补滤波的一般形式为：$$\hat{\theta}(k)=\frac{\tau}{\tau+T_s}(\hat{\theta}(k-1)+T_s\omega_{yb}(k))+\frac{T_s}{\tau+T_s}\theta_{a}(k)$$</p><p>一般系数取为0.95和0.05，则实际中的形式一般为：$$\hat{\theta}(k)=0.95(\hat{\theta}(k-1)+T_s\omega_{yb}(k))+0.05\theta_{a}(k)$$</p><p>滚转角和俯仰角也是同理。</p><h3 id="4-3-卡尔曼滤波"><a href="#4-3-卡尔曼滤波" class="headerlink" title="4.3 卡尔曼滤波"></a>4.3 卡尔曼滤波</h3><p>卡尔曼滤波器的主要作用是从一系列不完全且包含噪声不确定性的观测量中，估计系统的未知状态，其估计精度往往比单纯的基于单一观测量的方法更高。卡尔曼滤波器算法主要分两步处理，预测步骤和校正步骤。在预测步骤中，卡尔曼滤波器产生当前状态变量的预测估计，这些估计量包含不确定性。一旦出现下一个观测量（伴随着一定的误差以及随机噪声），之前的估计量会以加权平均的方式更新。</p><p><img src="/img/quadrotor/Kalman Filter.jpg" alt="Kalman Filter" style="zoom: 33%;" /></p><h3 id="4-4-Mahony四元数解算"><a href="#4-4-Mahony四元数解算" class="headerlink" title="4.4 Mahony四元数解算"></a>4.4 Mahony四元数解算</h3><p>Mahony滤波算法整体来看，可以分为以下几步：</p><ul><li>根据目前估计的四元数，将机体坐标系下的磁力计数据转换到地球固连坐标系下，得到水平方向标准磁场方向</li><li>将标准磁场方向和重力加速度方向利用当前估计的四元数再转换到机体坐标系下</li><li>将测量的加速度和磁场方向在机体坐标系下的值和上一步中转换出的值求误差(叉积)，反映当前估计四元数的不准确程度</li><li>利用PID将求得的误差用于修正陀螺仪测得的机体角速度</li><li>利用机体角速度得到四元数导数，利用四元数导数更新当前估计的四元数，不断迭代修正四元数的估计值</li><li>将实时估计的四元数转换成欧拉角实时输出</li></ul><p>总结一下，其实整个算法可以看做两大步：<strong>计算误差和修正估计</strong>。算法基于四元数进行优化估计。</p><h4 id="4-4-1-Mahony误差计算"><a href="#4-4-1-Mahony误差计算" class="headerlink" title="4.4.1 Mahony误差计算"></a>4.4.1 Mahony误差计算</h4><p>误差估计的核心思想在于：地球固连坐标系<script type="math/tex">O_ex_ey_ez_e</script>中，加速度向量归一化的值为<script type="math/tex">\begin{pmatrix}0 & 0 &1\end{pmatrix}^T</script>，即只有向下的1g的重力加速度；磁力计测量的数据在地球固连坐标系中为<script type="math/tex">\begin{pmatrix}h_x & 0 &h_z\end{pmatrix}^T</script>，即只在x和z方向有值。上面描述的是理想值，理论上我们如果将上面的两个向量利用四元数转换到机体坐标系下，得到的值应当与加速度计和磁力计测量的值相等，但实际情况中两个值肯定不相等，我们就要计算出这两者之间的误差，利用这个误差进行下一步的修正。</p><p>具体步骤为：</p><p><strong>（1）将加速度计和磁力计测得的值归一化：</strong></p><p>归一化之后加速度计测得的加速度在机体坐标系下的值记为<script type="math/tex">^{b}\boldsymbol{a}=\begin{pmatrix}a_{xb} & a_{yb} &a_{zb}\end{pmatrix}^T</script>，磁力计测得的磁场数据在机体坐标系下的值记为<script type="math/tex">^{b}\boldsymbol{m}=\begin{pmatrix}m_{xb} & m_{yb} &m_{zb}\end{pmatrix}^T</script></p><p><strong>（2）求取地球固连坐标系下的参考加速度和磁场方向：</strong></p><p>将测得的磁场方向在机体坐标系下的值转换到地球固连坐标系下：$$^{e}\boldsymbol{m}=\begin{pmatrix}m_{xe} \\ m_{ye} \\ m_{ze}\end{pmatrix}=\boldsymbol{C}(\boldsymbol{q}_e^b)\begin{pmatrix}m_{xb} \\ m_{yb} \\ m_{zb}\end{pmatrix}=\begin{pmatrix}q_0^2+q_1^2-q_2^2-q_3^2&2(q_1q_2-q_0q_3)&2(q_1q_3+q_0q_2)\\2(q_1q_2+q_0q_3)&q_0^2-q_1^2+q_2^2-q_3^2&2(q_2q_3-q_0q_1)\\2(q_1q_3-q_0q_2)&2(q_2q_3+q_0q_1)&q_0^2-q_1^2-q_2^2+q_3^2\end{pmatrix}\begin{pmatrix}m_{xb} \\ m_{yb} \\ m_{zb}\end{pmatrix}$$</p><p>计算<script type="math/tex">^{e}\boldsymbol{m}</script>在水平和竖直方向上的投影：<script type="math/tex">h_{xe}=\sqrt{m_{xe}^2+m_{ye}^2}，h_{ze}=m_{ze}</script></p><p>则磁场方向在地球固连坐标系下的理想参考方向为<script type="math/tex">^{e}\boldsymbol{h}_r=\begin{pmatrix}h_{xe} & 0 &h_{ze}\end{pmatrix}^T</script>。</p><p>加速度在地球固连坐标系下的理想参考方向为<script type="math/tex">^{e}\boldsymbol{a}_r=\begin{pmatrix}0 & 0&1\end{pmatrix}^T</script>，即为重力加速度。</p><p><strong>（3）将地球固连坐标系下的参考加速度和磁场方向转换到机体坐标系下：</strong></p><p>磁场方向在机体坐标系下的理想参考值为：$$^{b}\boldsymbol{h}_r=\begin{pmatrix}h^r_{xb} \\ h^r_{yb} \\ h^r_{zb}\end{pmatrix}=(\boldsymbol{C}(\boldsymbol{q}_e^b))^T\begin{pmatrix}h_{xe} \\ 0 \\ h_{ze}\end{pmatrix}=\begin{pmatrix}q_0^2+q_1^2-q_2^2-q_3^2&2(q_1q_2+q_0q_3)&2(q_1q_3-q_0q_2)\\2(q_1q_2-q_0q_3)&q_0^2-q_1^2+q_2^2-q_3^2&2(q_2q_3+q_0q_1)\\2(q_1q_3+q_0q_2)&2(q_2q_3-q_0q_1)&q_0^2-q_1^2-q_2^2+q_3^2\end{pmatrix}\begin{pmatrix}h_{xe} \\ 0 \\ h_{ze}\end{pmatrix}$$</p><p>加速度在机体坐标系下的理想参考值为：$$^{b}\boldsymbol{a}_r=\begin{pmatrix}a^r_{xb} \\a^r_{yb} \\ a^r_{zb}\end{pmatrix}=(\boldsymbol{C}(\boldsymbol{q}_e^b))^T\begin{pmatrix}0 \\ 0 \\ 1\end{pmatrix}=\begin{pmatrix}q_0^2+q_1^2-q_2^2-q_3^2&2(q_1q_2+q_0q_3)&2(q_1q_3-q_0q_2)\\2(q_1q_2-q_0q_3)&q_0^2-q_1^2+q_2^2-q_3^2&2(q_2q_3+q_0q_1)\\2(q_1q_3+q_0q_2)&2(q_2q_3-q_0q_1)&q_0^2-q_1^2-q_2^2+q_3^2\end{pmatrix}\begin{pmatrix}0 \\ 0 \\ 1\end{pmatrix}$$</p><p><strong>（4）利用叉积计算加速度和磁场方向在机体坐标系下测量值和理想参考值之间的误差：</strong></p><p>误差为：$$^{b}\boldsymbol{e}= \ ^{b}\boldsymbol{m}\times \ ^{b}\boldsymbol{h}_r+ \ ^{b}\boldsymbol{a}\times\ ^{b}\boldsymbol{a}_r$$</p><p>即： $$\begin{pmatrix}e_{x} \\ e_{y} \\ e_{z}\end{pmatrix}=\begin{pmatrix}m_{yb}h^r_{zb}-m_{zb}h^r_{yb} \\ m_{zb}h^r_{xb}-m_{xb}h^r_{zb}\\ m_{xb}h^r_{yb}-m_{yb}h^r_{xb}\end{pmatrix}+\begin{pmatrix}a_{yb}a^r_{zb}-a_{zb}a^r_{yb} \\ a_{zb}a^r_{xb}-a_{xb}a^r_{zb}\\ a_{xb}a^r_{yb}-a_{yb}a^r_{xb}\end{pmatrix}$$</p><h4 id="4-4-2-Mahony修正估计"><a href="#4-4-2-Mahony修正估计" class="headerlink" title="4.4.2 Mahony修正估计"></a>4.4.2 Mahony修正估计</h4><p><strong>（1）利用误差修正陀螺仪测量的机体角速度：</strong></p><p>陀螺仪测得的机体角速度在机体坐标系下的值记为<script type="math/tex">^{b}\boldsymbol{\omega}^m=\begin{pmatrix}\omega^m_{xb} & \omega^m_{yb} &\omega^m_{zb}\end{pmatrix}^T</script>，修正过后的值记为<script type="math/tex">^{b}\boldsymbol{\omega}=\begin{pmatrix}\omega_{xb} & \omega_{yb} &\omega_{zb}\end{pmatrix}^T</script>。</p><p>则修正利用误差项通过<strong>PID</strong>进行：$$^{b}\boldsymbol{\omega}= \ ^{b}\boldsymbol{\omega}^m+K_p\times  \ ^{b}\boldsymbol{e}+K_i\times \int \ ^{b}\boldsymbol{e}  $$</p><p><strong>（2）利用修正过的机体角速度计算四元数导数：</strong>$$\dot{\boldsymbol{q}_e^b}=\frac{1}{2}\begin{pmatrix}0&-\omega_{xb}&-\omega_{yb}&-\omega_{zb} \\\omega_{xb}&0&\omega_{zb}&-\omega_{yb}\\\omega_{yb}&-\omega_{zb}&0& \omega_{xb}\\\omega_{zb}&\omega_{yb}&-\omega_{xb}&0\end{pmatrix}\begin{pmatrix}q_0 \\ q_1 \\q_2\\q_3\end{pmatrix}$$</p><p><strong>（3）利用四元数导数更新四元数的估计值：</strong> $$\boldsymbol{q}_e^b[n] = \boldsymbol{q}_e^b[n-1] +T_s\times \dot{\boldsymbol{q}_e^b}$$           </p><p>上式中<script type="math/tex">T_s</script>为采样间隔。  </p><h2 id="5-控制算法"><a href="#5-控制算法" class="headerlink" title="5 控制算法"></a>5 控制算法</h2><h3 id="5-1-控制框架"><a href="#5-1-控制框架" class="headerlink" title="5.1 控制框架"></a>5.1 控制框架</h3><p>整体飞行控制框架如下图：</p><p><img src="/img/quadrotor/Control Framework.png" alt="Control Framework" style="zoom:50%;" /></p><p>四旋翼的底层控制主要有四个方面，位置控制、姿态控制、控制分配和电机控制：</p><ul><li>位置控制：利用期望的位置<script type="math/tex">\boldsymbol{p}_d</script>解算出期望的滚转角<script type="math/tex">\phi_d</script>、期望的俯仰角<script type="math/tex">\theta_d</script>和期望的总拉力<script type="math/tex">f_d</script></li><li>姿态控制：利用期望的姿态角<script type="math/tex">\phi_d、\theta_d、\psi_d</script>解​出期望的力矩<script type="math/tex">\boldsymbol{\tau}_d</script></li><li>控制分配：为了得到合适的<script type="math/tex">f_d</script>和<script type="math/tex">\boldsymbol{\tau}_d</script>，需要将期望的螺旋桨转速分配到四个电机</li><li>电机控制：利用每个电机的期望螺旋桨转速得到每个电机的期望油门指令</li></ul><p>本文中主要讨论位置控制和姿态控制。</p><p>四旋翼的闭环控制框图如下图所示：</p><p><img src="/img/quadrotor/cl_control.png" alt="cl_control" style="zoom:67%;" /></p><p>多旋翼是一个欠驱动系统，有六个输出（位置<script type="math/tex">\boldsymbol{p}\in\Re^3</script>和姿态<script type="math/tex">\boldsymbol{\Theta}\in\Re^3</script>），但只有四个独立输入（总拉力<script type="math/tex">f\in\Re</script>和三轴力矩<script type="math/tex">\boldsymbol{\tau}\in\Re^3</script>）。所以多旋翼只能跟踪四个期望指令（<script type="math/tex">\boldsymbol{p}_d\in\Re^3</script>和<script type="math/tex">\psi_d\in\Re</script>），剩余的变量（<script type="math/tex">\phi_d,\theta_d\in\Re</script>）由期望指令<script type="math/tex">\boldsymbol{p}_d</script>和<script type="math/tex">\psi_d</script>确定。</p><h3 id="5-2-简化的线性模型"><a href="#5-2-简化的线性模型" class="headerlink" title="5.2 简化的线性模型"></a>5.2 简化的线性模型</h3><p>上面建立的模型中，忽略陀螺力矩和<script type="math/tex">^b\boldsymbol{\omega}\times(J\cdot \ ^b\boldsymbol{\omega})</script>，得到如下的简化模型：</p><ul><li>运动学位置模型：<script type="math/tex">^e\dot{\boldsymbol{p}}\ = \ ^e\boldsymbol{v}</script></li><li>运动学姿态模型： <script type="math/tex">\dot{\boldsymbol{\Theta}}=W \cdot \ ^b\boldsymbol{\omega}</script>（欧拉角模型）</li><li>动力学位置模型： <script type="math/tex">^e\dot{\boldsymbol{v}}\ = \ g\boldsymbol{e}_3 - \frac{f}{m} \boldsymbol{R}_b^e\boldsymbol{e}_3</script>  </li><li>动力学姿态模型：<script type="math/tex">^b\tau  =J\cdot \ ^b\dot{\boldsymbol{\omega}}</script></li></ul><p>上面的模型还是一个非线性模型，需要进一步线性化：</p><p>我们假设四旋翼的俯仰角和滚转角都非常小，总拉力约等于四旋翼的重力，则</p><ul><li>运动学姿态模型中的<script type="math/tex">W</script>近似为单位阵<script type="math/tex">I_3</script>，</li><li>动力学位置模型中的<script type="math/tex">\boldsymbol{R}_b^e\boldsymbol{e}_3</script>近似为：<script type="math/tex">\boldsymbol{R}_b^e\boldsymbol{e}_3\approx \begin{pmatrix}\theta cos\psi+\phi sin\psi \\ \theta sin\psi-\phi cos\psi \\ 1\end{pmatrix}</script></li></ul><p>最终，原始模型可以被解耦为三个线性模型，即水平位置通道模型、高度通道模型和姿态模型：</p><ul><li><p>水平位置通道模型：                                     </p><script type="math/tex; mode=display">\dot{\boldsymbol{p}}_h=\boldsymbol{v}_h</script><script type="math/tex; mode=display">\dot{\boldsymbol{v}}_h=-g\begin{pmatrix}sin\psi&cos\psi\\-cos\psi&sin\psi\end{pmatrix}\begin{pmatrix}\phi\\\theta\end{pmatrix}=-g\boldsymbol{A}_{\psi}\boldsymbol{\Theta}_{h}</script></li><li><p>高度通道模型：                                         </p><p>​     <script type="math/tex">\dot{p}_z=v_z</script></p><script type="math/tex; mode=display">\dot{v}_z=g-\frac{f}{m}</script></li><li><p>姿态模型：                                                 </p><p>​      <script type="math/tex">\dot{\boldsymbol{\Theta}}=\ ^b\boldsymbol{\omega}</script></p><script type="math/tex; mode=display">^b\tau  =J\cdot \ ^b\dot{\boldsymbol{\omega}}</script></li></ul><h3 id="5-3-位置控制"><a href="#5-3-位置控制" class="headerlink" title="5.3 位置控制"></a>5.3 位置控制</h3><p>本文只讨论欧拉角作为输出时的位置控制：</p><p><strong>水平位置通道：</strong></p><p>控制器为双环PID，分为位置环和速度环：</p><p>位置环：针对<script type="math/tex">\dot{\boldsymbol{p}}_h=\boldsymbol{v}_h</script>，期望的水平速度为<script type="math/tex">\boldsymbol{v}_{hd}=\boldsymbol{K_{p}}  (\boldsymbol{p}_{hd}-\boldsymbol{p}_h)=\boldsymbol{K_{p}}  \boldsymbol{e}_{ph}</script>，仅有比例项控制即可。</p><p>速度环：针对<script type="math/tex">\dot{\boldsymbol{v}}_h=-g\boldsymbol{A}_{\psi}\boldsymbol{\Theta}_{h}</script>，若期望的姿态为<script type="math/tex">\boldsymbol{\Theta}_{hd}</script>，则可令<script type="math/tex">-g\boldsymbol{A}_{\psi}\boldsymbol{\Theta}_{hd}=\boldsymbol{K_{p}}  \boldsymbol{e}_{vh}+\boldsymbol{K_{i}}  \int\boldsymbol{e}_{vh}+\boldsymbol{K_{d}}  \dot{\boldsymbol{e}}_{vh}</script>，之后从上式中解出期望的姿态<script type="math/tex">\boldsymbol{\Theta}_{hd}</script>即可。</p><p>水平位置通道的输出为姿态的期望值<script type="math/tex">\boldsymbol{\Theta}_{hd}</script>，之后会将该值作为姿态控制的参考输入。</p><p><strong>高度通道：</strong></p><p>控制器为双环PID，分为位置环和速度环：</p><p>位置环：针对<script type="math/tex">\dot{p}_z=v_z</script>，期望的竖直速度为<script type="math/tex">v_{zd}=K_p e_z</script>，为最简单的比例控制。</p><p>速度环：针对<script type="math/tex">\dot{v}_z=g-\frac{f}{m}</script>，若期望的拉力为<script type="math/tex">f_d</script>，则可以令<script type="math/tex">g-\frac{f_d}{m}=K_pe_{vz}+K_i\int e_{vz}+K_d\dot{e}_{vz}</script>，之后从上式中解出期望的拉力<script type="math/tex">f_d</script>即可。</p><p>高度通道的输出为拉力的期望值<script type="math/tex">f_d</script>，之后会将该值作为控制分配的参考输入。</p><h3 id="5-4-姿态控制"><a href="#5-4-姿态控制" class="headerlink" title="5.4 姿态控制"></a>5.4 姿态控制</h3><p>本文只讨论基于欧拉角的姿态控制：</p><p>控制器为双环PID，分为角度环和角速度环：</p><p>角度环：针对<script type="math/tex">\dot{\boldsymbol{\Theta}}=\ ^b\boldsymbol{\omega}</script>，设计角速度的期望为<script type="math/tex">\ ^b\boldsymbol{\omega}_d=\boldsymbol{K}_{p}\boldsymbol{e}_{\boldsymbol{\Theta}}</script>，仅有比例控制。</p><p>角速度环：针对<script type="math/tex">^b\tau  =J\cdot \ ^b\dot{\boldsymbol{\omega}}</script>，设计期望的力矩为<script type="math/tex">^b\tau_d=\boldsymbol{K_{p}}  \boldsymbol{e}_{\omega}+\boldsymbol{K_{i}}  \int\boldsymbol{e}_{\omega}+\boldsymbol{K_{d}}  \dot{\boldsymbol{e}}_{\omega}</script></p><p>姿态控制的输出为力矩的期望值<script type="math/tex">^b\tau_d</script>，之后会将该值作为控制分配的参考输入。</p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h2><h2 id="7-参考文献"><a href="#7-参考文献" class="headerlink" title="7 参考文献"></a>7 参考文献</h2><p>[1] 《多旋翼飞行器设计与控制》全权  （一本非常全面的关于四旋翼的书籍）</p><p>[2] 《Advanced Dynamics : Rigid Body,Multibody,and Aerospace Applications》（一本关于姿态表示、刚体运动学和动力学非常好的书籍）</p>]]></content>
    
    
    
    <tags>
      
      <tag>Algorithum</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的深空摄影后期处理流程</title>
    <link href="/2021/12/04/%E6%B7%B1%E7%A9%BA%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"/>
    <url>/2021/12/04/%E6%B7%B1%E7%A9%BA%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="1-预处理"><a href="#1-预处理" class="headerlink" title="1 预处理"></a>1 预处理</h2><h3 id="1-1-校准："><a href="#1-1-校准：" class="headerlink" title="1.1 校准："></a>1.1 校准：</h3><h3 id="1-2-转色："><a href="#1-2-转色：" class="headerlink" title="1.2 转色："></a>1.2 转色：</h3><p>PI1.8：Debayer ，Bayer Pattern根据使用相机的具体型号选择，QHY8L是GBRG。Demosaicing method选择VNG，Target Images选择要转色的照片，Output Files选择输出照片的保存路径，建议新建一个文件夹debayer存放转色后的图像。</p><h3 id="1-3-对齐："><a href="#1-3-对齐：" class="headerlink" title="1.3 对齐："></a>1.3 对齐：</h3><p>PI1.8：StarAlignment，类似的操作，选择参考图像，要对齐的图像，输出文件路径。Interpolation选择Auto即可。</p><h3 id="1-4-叠加："><a href="#1-4-叠加：" class="headerlink" title="1.4 叠加："></a>1.4 叠加：</h3><p>PI1.8：ImageIntegration，Add Files导入要叠加的对齐过后的图像，Pixel Rejection中拒绝算法可以选择Sigma Clipping(均值降噪时自动剔除偏差较大的点)。</p><h2 id="2-线性处理"><a href="#2-线性处理" class="headerlink" title="2 线性处理"></a>2 线性处理</h2><h3 id="2-1-STF拉伸预览："><a href="#2-1-STF拉伸预览：" class="headerlink" title="2.1 STF拉伸预览："></a>2.1 STF拉伸预览：</h3><p>PI1.8：ScreenTransferFunction，点击左下角核武器图标自动拉伸，右下角电视图标选择是否预览，直接将左下角三角形图标拖到HT栏下部可直接生成对应的HT拉伸。之后直接将HT页面左下角的小三角拖到图像上就可直接将效果应用到图像上。</p><h3 id="2-2-动态剪裁："><a href="#2-2-动态剪裁：" class="headerlink" title="2.2 动态剪裁："></a>2.2 动态剪裁：</h3><p>PI1.8：DynamicCrop，剪裁后应用即可。</p><h3 id="2-3-DBE："><a href="#2-3-DBE：" class="headerlink" title="2.3 DBE："></a>2.3 DBE：</h3><p>PI1.8：DynamicBackgroundExtraction，第一步利用十字选择过渡区域时可以用HT做辅助拉伸看北京明暗过渡交界，第二步选择背景点时注意均匀选取，注意在Target Image Correction中的Correction选择Subtraction。</p><h3 id="2-4-背景色彩平衡："><a href="#2-4-背景色彩平衡：" class="headerlink" title="2.4 背景色彩平衡："></a>2.4 背景色彩平衡：</h3><p>PI1.8：BackgroundNeutralization，默认参数直接应用。Reference Image选择划定的Preview的背景区域，可以用Upper limit来排除背景区域中较亮恒星的干扰(最大值和最小值的确定可以用鼠标在背景区域中扫描，然后在底部看RGB对应的值，选择一个大概的值即可，不必太过纠结)。</p><h3 id="2-5-色彩校准："><a href="#2-5-色彩校准：" class="headerlink" title="2.5 色彩校准："></a>2.5 色彩校准：</h3><p>PI1.8：ColorCalibration，一般来说Structure Detection就能取得不错的效果；如果不行，先分别选出星云和背景的区域，在White Reference中的Reference Image中选择星云在的区域，在Background Reference中的Reference Image中选择背景在的区域，之后应用；如果还不行，使用Manual White Balence手动调节，注意一次成型，不行就撤回重来。</p><h3 id="2-6-线性降噪："><a href="#2-6-线性降噪：" class="headerlink" title="2.6 线性降噪："></a>2.6 线性降噪：</h3><p>PI1.8：ATrousWaveletTransform，利用小波变换降噪，不同层在Noise Reduction中选择不同的降噪参数，比如说Scale分别为1,2,4,8时参数分别为(3,0.25,2),(2,0.25,2),(1,0.25,2),(0.5,0.12,2)。</p><h3 id="2-6-反卷积："><a href="#2-6-反卷积：" class="headerlink" title="2.6 反卷积："></a>2.6 反卷积：</h3><p>PI1.8:Deconvolution，我入门看的视频中这一步是在HT拉伸后做的，效果也不错。先调整参数建立星点模型，找一颗星星数像素数，模型的像素数应该和它差不多，方向和图像中大部分星星的变形拉伸方向垂直即可。之后利用StarMask建立星点蒙版(Smoothness可以选择的小一些，6左右)，可以HT增强星点蒙版对比度，然后在Convolution做高斯模糊。之后建立明度蒙版(整体页面左上角加号图标右边的图标)并应用(关于蒙版的三个图标在整个页面的右上角)，反卷积只对较亮的主体星云作用。之后开启Deringing，其中的Local Support选择刚刚建立的星点蒙版。如果效果过于严重，可以减少迭代次数并将Deringing中的Global dark值调高(一般在0.03-0.1之间)</p><h2 id="3-非线性处理"><a href="#3-非线性处理" class="headerlink" title="3 非线性处理"></a>3 非线性处理</h2><h3 id="3-1-直方图拉伸："><a href="#3-1-直方图拉伸：" class="headerlink" title="3.1 直方图拉伸："></a>3.1 直方图拉伸：</h3><p>PI1.8:HistogramTransfermation，可以把STF中的效果拖过来直接应用。调节时注意点击左下角的小圆点开启实时预览。</p><h3 id="3-2-非线性降噪："><a href="#3-2-非线性降噪：" class="headerlink" title="3.2 非线性降噪："></a>3.2 非线性降噪：</h3><p>PI1.8:ACDNR，默认参数即可，注意套着明度蒙版做，只对背景降噪，蒙版做的稍微柔和一些。</p><h3 id="3-3-LHE增强对比度："><a href="#3-3-LHE增强对比度：" class="headerlink" title="3.3 LHE增强对比度："></a>3.3 LHE增强对比度：</h3><p>PI1.8：LocalHistogramEqualization，效果过猛可以可以降低Amount，注意套着蒙版做，只对主体强化，蒙版做的稍微柔和一点，HT时只动左边的滑块。</p><h3 id="3-4-饱和度调整："><a href="#3-4-饱和度调整：" class="headerlink" title="3.4 饱和度调整："></a>3.4 饱和度调整：</h3><p>PI1.8：CurvesTransformation&amp;ColorSaturation。CurvesTransformation中可以使用S曲线提升饱和度，也可以分别处理RGB三个通道的曲线。ColorSaturation可以通过拉曲线提升不同颜色的饱和度。调节时注意点击左下角的小圆点开启实时预览。注意套着明度蒙版做。</p><h3 id="3-5-gamma增强-暗云气-："><a href="#3-5-gamma增强-暗云气-：" class="headerlink" title="3.5 gamma增强(暗云气)："></a>3.5 gamma增强(暗云气)：</h3><p>PI1.8：ExponentialTransformation。默认参数即可。</p><h3 id="3-6-SCNR去绿："><a href="#3-6-SCNR去绿：" class="headerlink" title="3.6 SCNR去绿："></a>3.6 SCNR去绿：</h3><p>PI1.8：SCNR。默认参数即可。</p><h3 id="3-7-缩星："><a href="#3-7-缩星：" class="headerlink" title="3.7 缩星："></a>3.7 缩星：</h3><p>PI1.8：StarMask&amp;MorphologicalTransformation。建立星点蒙版后应用MorphologicalTransformation。</p><h2 id="4-导出"><a href="#4-导出" class="headerlink" title="4 导出"></a>4 导出</h2><p>注意导出时如果后面还要在PS中处理，TIFF选择位深度为16位的int</p>]]></content>
    
    
    
    <tags>
      
      <tag>Astronomy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IMU各种姿态解算方法的实现与比较</title>
    <link href="/2021/12/04/%E5%90%84%E7%A7%8D%E5%A7%BF%E6%80%81%E8%A7%A3%E7%AE%97%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <url>/2021/12/04/%E5%90%84%E7%A7%8D%E5%A7%BF%E6%80%81%E8%A7%A3%E7%AE%97%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83/</url>
    
    <content type="html"><![CDATA[<h2 id="1-基本知识：旋转表示法"><a href="#1-基本知识：旋转表示法" class="headerlink" title="1 基本知识：旋转表示法"></a>1 基本知识：旋转表示法</h2><h3 id="1-1-坐标系："><a href="#1-1-坐标系：" class="headerlink" title="1.1 坐标系："></a>1.1 坐标系：</h3><p>在姿态解算问题中，我们一般会用到两个坐标系：机体坐标系<script type="math/tex">o_bx_by_bz_b</script>和地球固连坐标系<script type="math/tex">o_ex_ey_ez_e</script>。同一个向量<script type="math/tex">r</script>在两种坐标系下可能有不同的表示，一般我们记向量<script type="math/tex">r</script>在机体坐标系下的表示为<script type="math/tex">^{b}r</script>，在地球固连坐标系下的表示为<script type="math/tex">^{e}r</script>。旋转表示法解决的主要问题就是：同一个向量在两种坐标系下的表示有什么联系，我们怎样由其中的一中表示推出另外一种表示。</p><h3 id="1-2-欧拉角："><a href="#1-2-欧拉角：" class="headerlink" title="1.2 欧拉角："></a>1.2 欧拉角：</h3><p>欧拉角是最直观的一种的旋转表示法，但是由于其使用三个参数来表示三个自由度的旋转，不可避免的会出现奇异性问题，即通常所说的“万向节死锁”，在俯仰角或滚转角接近90°时出现自由度退化的问题。</p><p>本文统一采用<script type="math/tex">z-y-x</script>欧拉角，俯仰角Pitch、滚转角Roll、偏航角Yaw分别记做<script type="math/tex">\theta、\phi、\psi</script>，​在地球固连坐标系旋转至机体坐标系的过程中，先沿地球固连坐标系的<script type="math/tex">z</script>轴旋转偏航角<script type="math/tex">\psi</script>，在沿新得到的临时机体坐标系的<script type="math/tex">y</script>轴旋转俯仰角<script type="math/tex">\theta</script>，最后沿第二次新得到的临时机体坐标系的<script type="math/tex">x</script>轴旋转滚转角<script type="math/tex">\phi</script>，最后得到机体坐标系。</p><p>最终的姿态解算结果以及控制器的设计大部分是基于欧拉角进行的，之后会给出如何由旋转矩阵和四元数得到欧拉角。</p><p>由上述的旋转过程和欧拉角的定义可以得到三个欧拉角的变化率和机体角速度的关系：$$\begin{pmatrix}\omega_{xb}\\\omega_{yb} \\\omega_{zb}\end{pmatrix} = \begin{pmatrix}1& 0 &-sin\theta \\0&cos\phi  &cos\theta sin\phi \\0 & -sin\phi &cos\theta cos\phi\end{pmatrix}\begin{pmatrix}\dot{\phi}\\\dot{\theta} \\\dot{\psi}\end{pmatrix}$$</p><p>反之，有：$$\begin{pmatrix}\dot{\phi}\\\dot{\theta} \\\dot{\psi}\end{pmatrix} = \begin{pmatrix}1& tan\theta sin\phi &tan\theta cos\phi\\0&cos\phi  &-sin\phi \\0 & sin\phi / cos\theta&cos\phi /cos\theta\end{pmatrix}\begin{pmatrix}\omega_{xb}\\\omega_{yb} \\\omega_{zb}\end{pmatrix}$$        </p><p>上面两个式子的意义在于，我们利用陀螺仪只能测出机体角速度在机体坐标系下的表示，即<script type="math/tex">\begin{pmatrix}\omega_{xb}&\omega_{yb} &\omega_{zb}\end{pmatrix}^T</script>，为了通过积分得到三个欧拉角，我们必须用上面的式子计算出三个欧拉角的变化率<script type="math/tex">\begin{pmatrix}\dot{\phi} & \dot{\theta} &\dot{\psi}\end{pmatrix}^T</script>，然后进行数值积分，计算出目前的欧拉角，即<script type="math/tex">\phi[n]=\phi[n-1]+\dot{\phi}\times \Delta t</script>，依次迭代，不断更新。</p><h3 id="1-3-旋转矩阵："><a href="#1-3-旋转矩阵：" class="headerlink" title="1.3 旋转矩阵："></a>1.3 旋转矩阵：</h3><p>定义由坐标系1到坐标系2的旋转矩阵为<script type="math/tex">R_1^2</script>，使用方法为<script type="math/tex">^{2}r=R_1^{2}\ ^{1}r</script>，即将向量在坐标系1下的坐标表示转换为在坐标系2下的坐标表示。</p><p>由上述欧拉角的旋转过程可以推出从机体坐标系到地球固连坐标系的旋转矩阵<script type="math/tex">R_b^e</script>为：$$R_b^e=\begin{pmatrix}cos\theta cos\phi & cos\psi sin\theta sin\phi-sin\psi cos\phi &cos\psi sin\theta cos\phi +sin\psi sin\phi \\ cos\theta sin\psi&sin\psi sin\theta sin\phi+cos\psi cos\phi  &sin\psi sin\theta cos\phi -cos\psi sin\phi \\-sin\theta & sin\phi  cos\theta&cos\phi cos\theta\end{pmatrix}$$   </p><p>也可以由旋转矩阵求欧拉角，若记上述的旋转矩阵为：$$R_b^e=\begin{pmatrix}r_{11}&r_{12}&r_{13}\\r_{21}&r_{22}&r_{23}\\r_{31}&r_{32}&r_{33}\end{pmatrix}$$</p><p>则有：</p><ul><li><p>偏航角   <script type="math/tex">\psi=arctan\frac{r_{21}}{r_{11}}</script></p></li><li><p>俯仰角   <script type="math/tex">\theta = arcsin(-r_{31})</script></p></li><li><p>滚转角   <script type="math/tex">\phi = arctan\frac{r_{32}}{r_{33}}</script></p></li></ul><p>由旋转矩阵的正交性，从地球固连坐标系到机体坐标系的旋转矩阵<script type="math/tex">R_e^b</script>为：$$R_e^b=(R_b^e)^{-1}=(R_b^e)^T$$</p><p>对旋转矩阵求逆只需要转置即可。</p><p>不过也正是因为旋转矩阵的正交性带来了额外的约束，导致我们在利用非线性优化进行状态估计时出现了不必要的麻烦，所以我们一般利用接下来的四元数进行优化算法的设计。或者用更加高级的李群和李代数作为工具进行姿态估计，这也是SLAM中常用的做法，不过在四旋翼姿态解算中很少使用。</p><p>旋转矩阵的导数为：$$\frac{d\boldsymbol{R}_b^e}{dt}=\boldsymbol{R}_b^e[^b\boldsymbol{\omega}]_{\times}$$</p><p>展开为：$$\frac{d\boldsymbol{R}_b^e}{dt}=\boldsymbol{R}_b^e[^b\boldsymbol{\omega}]_{\times}=\begin{pmatrix}cos\theta cos\phi & cos\psi sin\theta sin\phi-sin\psi cos\phi &cos\psi sin\theta cos\phi +sin\psi sin\phi \\ cos\theta sin\psi&sin\psi sin\theta sin\phi+cos\psi cos\phi  &sin\psi sin\theta cos\phi -cos\psi sin\phi \\-sin\theta & sin\phi  cos\theta&cos\phi cos\theta\end{pmatrix}  \begin{pmatrix}0&-\omega_{zb}&\omega_{yb}\\\omega_{zb}&0& -\omega_{xb}\\-\omega_{yb}&\omega_{xb}&0\end{pmatrix}$$</p><h3 id="1-4-四元数："><a href="#1-4-四元数：" class="headerlink" title="1.4 四元数："></a>1.4 四元数：</h3><p>单位四元数也可以用来表示旋转，具体理论在此不做过多介绍。</p><p>假定地球固连坐标系到机体坐标系的旋转四元数为<script type="math/tex">\boldsymbol{q}_e^b=\begin{pmatrix}q_0 & q_1 &q_2&q_3\end{pmatrix}^T</script>，则有：$$\begin{pmatrix}0\\ ^{e}\boldsymbol{r}\end{pmatrix} =(\boldsymbol{q}_b^e)^{-1}\otimes \begin{pmatrix}0\\ ^{b}\boldsymbol{r}\end{pmatrix} \otimes\boldsymbol{q}_b^e =\boldsymbol{q}_e^b\otimes \begin{pmatrix}0\\ ^{b}\boldsymbol{r}\end{pmatrix} \otimes(\boldsymbol{q}_e^b)^{-1}$$</p><p>由上式可得：                                       $$^{e}\boldsymbol{r}=\boldsymbol{C}(\boldsymbol{q}_e^b)\cdot \ ^{b}\boldsymbol{r}$$</p><p>其中：         $$\boldsymbol{C}(\boldsymbol{q}_e^b)=\begin{pmatrix}q_0^2+q_1^2-q_2^2-q_3^2&2(q_1q_2-q_0q_3)&2(q_1q_3+q_0q_2)\\2(q_1q_2+q_0q_3)&q_0^2-q_1^2+q_2^2-q_3^2&2(q_2q_3-q_0q_1)\\2(q_1q_3-q_0q_2)&2(q_2q_3+q_0q_1)&q_0^2-q_1^2-q_2^2+q_3^2\end{pmatrix}$$</p><p>上式可以看成是旋转矩阵的四元数表示，则根据由旋转矩阵求欧拉角的方法，可以得到由四元数求欧拉角的方法：</p><ul><li><p>偏航角   <script type="math/tex">\psi=arctan\frac{r_{21}}{r_{11}}=arctan\frac{2(q_1q_2+q_0q_3)}{q_0^2+q_1^2-q_2^2-q_3^2}</script></p></li><li><p>俯仰角   <script type="math/tex">\theta = arcsin(-r_{31})=arcsin(-2(q_1q_3-q_0q_2))</script></p></li><li><p>滚转角   <script type="math/tex">\phi = arctan\frac{r_{32}}{r_{33}}=arctan\frac{2(q_2q_3+q_0q_1)}{q_0^2-q_1^2-q_2^2+q_3^2}</script></p></li></ul><p>在利用四元数进行优化时，四元数的导数是一个非常关键的信息，在迭代优化中起到非常重要的作用，幸运的是，四元数导数和机体角速度可以建立起关系：$$\dot{\boldsymbol{q}_e^b}=\frac{1}{2}\begin{pmatrix}0&-^{b}\boldsymbol{\omega}^T\\^{b}\boldsymbol{\omega}&-[^{b}\boldsymbol{\omega}]_{\times}\end{pmatrix}\boldsymbol{q}_e^b$$</p><p>即：$$\dot{\boldsymbol{q}_e^b}=\frac{1}{2}\begin{pmatrix}0&-\omega_{xb}&-\omega_{yb}&-\omega_{zb} \\\omega_{xb}&0&\omega_{zb}&-\omega_{yb}\\\omega_{yb}&-\omega_{zb}&0& \omega_{xb}\\\omega_{zb}&\omega_{yb}&-\omega_{xb}&0\end{pmatrix}\begin{pmatrix}q_0 \\ q_1 \\q_2\\q_3\end{pmatrix}$$</p><p>在Mahony姿态解算算法中，就是在修正过陀螺仪得到的机体角速度之后，利用上式计算四元数导数，以修正当前的四元数，不断迭代估计当前姿态。</p><h2 id="2-测量模型：加速度计、陀螺仪、磁力计"><a href="#2-测量模型：加速度计、陀螺仪、磁力计" class="headerlink" title="2 测量模型：加速度计、陀螺仪、磁力计"></a>2 测量模型：加速度计、陀螺仪、磁力计</h2><h3 id="2-1-加速度计："><a href="#2-1-加速度计：" class="headerlink" title="2.1 加速度计："></a>2.1 加速度计：</h3><p>利用加速度计可以测量机体的俯仰角和滚转角，若记<script type="math/tex">^{b}\boldsymbol{a}=\begin{pmatrix}a_{xb} & a_{yb} &a_{zb}\end{pmatrix}^T</script>为加速度计的测量值，即加速度矢量在机体坐标系下的表示，则机体的俯仰角和滚转角为：</p><ul><li><p>俯仰角：<script type="math/tex">\theta_{a}=arcsin(\frac{a_{xb}}{g})</script></p></li><li><p>滚转角：<script type="math/tex">\phi_a=-arcsin(\frac{a_{yb}}{gcos\theta_a})</script></p></li></ul><p>加速度计没有累积误差，但动态响应特性较差，测量噪声较大。                      </p><h3 id="2-2-陀螺仪："><a href="#2-2-陀螺仪：" class="headerlink" title="2.2 陀螺仪："></a>2.2 陀螺仪：</h3><p>陀螺仪可以测量机体角速度在机体坐标系下的表示，测量值可记为<script type="math/tex">^{b}\boldsymbol{\omega}=\begin{pmatrix}\omega_{xb} & \omega_{yb} &\omega_{zb}\end{pmatrix}^T</script>。</p><p>在小角度的情况下，三个欧拉角的变化率近似等于机体角速度在机体坐标系下的表示，此时直接对机体角速度进行离散积分即可得到三个欧拉角。</p><p>但当进行大角度飞行时，必须先由<script type="math/tex">\begin{pmatrix}\dot{\phi}\\\dot{\theta} \\\dot{\psi}\end{pmatrix} = \begin{pmatrix}1& tan\theta sin\phi &tan\theta cos\phi\\0&cos\phi  &-sin\phi \\0 & sin\phi / cos\theta&cos\phi /cos\theta\end{pmatrix}\begin{pmatrix}\omega_{xb}\\\omega_{yb} \\\omega_{zb}\end{pmatrix}</script>得到三个欧拉角的变化率，然后再对三个欧拉角的变化率分别进行离散积分，才能得到正确的欧拉角。</p><p>陀螺仪动态响应快，测量精度高，但是在积分得到角度的过程中不可避免的会产生累积误差。</p><h3 id="2-3-磁力计："><a href="#2-3-磁力计：" class="headerlink" title="2.3 磁力计："></a>2.3 磁力计：</h3><p>磁力计可以测出地磁场在机体坐标系下的坐标：<script type="math/tex">^{b}\boldsymbol{m}=\begin{pmatrix}m_{xb} & m_{yb} &m_{zb}\end{pmatrix}^T</script>，在得到偏航角角时。必须先利用之前得到的俯仰角和滚转角将磁力计测量值投影到水平面，得到：</p><ul><li>x轴分量：<script type="math/tex">\overline{m}_{xe}=m_{xb}cos\theta+m_{yb}sin\phi sin\theta+m_{zb}cos\phi sin\theta</script></li><li>y轴分量：<script type="math/tex">\overline{m}_{ye}=m_{yb}cos\phi -m_{zb}sin\phi</script></li></ul><p>之后可以得到偏航角：                   $$\psi_{mag}=arctan2(\overline{m}_{xe},\overline{m}_{ye})$$  </p><p>磁力计没有累积误差，但动态响应特性较差，测量噪声较大，且容易受到干扰。</p><h2 id="3-状态估计：滤波算法"><a href="#3-状态估计：滤波算法" class="headerlink" title="3 状态估计：滤波算法"></a>3 状态估计：滤波算法</h2><p>在尝试各种滤波算法时，采用的平台为维特智能的JY901B九轴传感器，其可以通过串口或I2C回传加速度计、陀螺仪和磁力计的原始数据，也可以回传其内部自带算法解算得到的四元数和欧拉角。我在进行测试的时候，认为其内部自带的解算算法解算出的值较为准确，将我采用自己的算法解算出来的数据和其进行比较，大致确定每一种算法的优劣。并感受不同算法的特点。</p><p><strong>本小节所有数据均为实测。</strong></p><h3 id="3-1-互补滤波："><a href="#3-1-互补滤波：" class="headerlink" title="3.1 互补滤波："></a>3.1 互补滤波：</h3><h4 id="3-1-1-原理："><a href="#3-1-1-原理：" class="headerlink" title="3.1.1 原理："></a>3.1.1 原理：</h4><p>简单来说，互补滤波就是对加速度计和磁力计解算得到的数据进行低通滤波，对陀螺仪解算得到的数据进行高通滤波。既可以保留加速度计和磁力计解算得到的数据无漂移的优势保留，也可以将陀螺仪解算得到的数据噪声小的优势保留下来。</p><p>以俯仰角为例，互补滤波的一般形式为：$$\hat{\theta}(k)=\frac{\tau}{\tau+T_s}(\hat{\theta}(k-1)+T_s\omega_{yb}(k))+\frac{T_s}{\tau+T_s}\theta_{a}(k)$$</p><p>一般系数取为0.95和0.05，则实际中的形式一般为：$$\hat{\theta}(k)=0.95(\hat{\theta}(k-1)+T_s\omega_{yb}(k))+0.05\theta_{a}(k)$$</p><p>滚转角和俯仰角也是同理。</p><h4 id="3-1-2-效果："><a href="#3-1-2-效果：" class="headerlink" title="3.1.2 效果："></a>3.1.2 效果：</h4><h5 id="3-1-2-1-互补滤波解算和传感器自带解算的比较："><a href="#3-1-2-1-互补滤波解算和传感器自带解算的比较：" class="headerlink" title="3.1.2.1 互补滤波解算和传感器自带解算的比较："></a>3.1.2.1 互补滤波解算和传感器自带解算的比较：</h5><p>俯仰角Pitch互补滤波解算比较：</p><p><img src="/img/IMU_solve/CF_Pitch.svg" alt="CF_Pitch"  /></p><p>滚转角Roll互补滤波解算比较：</p><p><img src="/img/IMU_solve/CF_Roll.svg" alt="CF_Roll"></p><p>偏航角Yaw互补滤波解算比较：</p><p><img src="/img/IMU_solve/CF_Yaw.svg" alt="CF_Yaw"></p><p>互补滤波的解算值和传感器自身解算的标准值之间还是存在很大差异，尤其是在姿态变化大的时候差距尤为明显。互补滤波感觉响应较慢，在姿态大幅快速变化时无法快速收敛。且在欧拉角较大时存在解算失效的问题，俯仰角和滚转角的解算值很少能超过80°。</p><h5 id="3-1-2-2-互补滤波各个值之间的比较分析："><a href="#3-1-2-2-互补滤波各个值之间的比较分析：" class="headerlink" title="3.1.2.2 互补滤波各个值之间的比较分析："></a>3.1.2.2 互补滤波各个值之间的比较分析：</h5><p><img src="/img/IMU_solve/CF_Compare.svg" alt="CF_Compare" style="zoom:150%;" /></p><p>从上图中可以看出，加速度计解算出的值动态响应很快但数据噪声较大，仅使用陀螺仪解算出的值较为平滑且噪声较小，但随着时间会有累积误差导致解算的值不断漂移。互补滤波融合之后的值不仅动态响应较快没有累积误差，且没有噪声数据较为平滑，综合保留了两者的优点。</p><h4 id="3-1-3-代码：STM32F405"><a href="#3-1-3-代码：STM32F405" class="headerlink" title="3.1.3 代码：STM32F405"></a>3.1.3 代码：STM32F405</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//互补滤波进行解算:</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Get_Eular_Angle_CF</span><span class="hljs-params">(<span class="hljs-keyword">float</span> gx, <span class="hljs-keyword">float</span> gy, <span class="hljs-keyword">float</span> gz, <span class="hljs-keyword">float</span> ax, <span class="hljs-keyword">float</span> ay, <span class="hljs-keyword">float</span> az, <span class="hljs-keyword">float</span> mx, <span class="hljs-keyword">float</span> my, <span class="hljs-keyword">float</span> mz)</span></span><br><span class="hljs-function"></span>&#123;<br>      <span class="hljs-comment">//测量实际的测量间隔，用于陀螺仪积分时时间间隔的确定</span><br>  INS_dt= (cnt - INS_cnt2)/<span class="hljs-number">1000.0f</span>;<br>      INS_cnt2 = cnt;<br>  <br>      <span class="hljs-comment">//由机体角速度得到三个欧拉家的变化率</span><br>  detla_roll =  gx <br>              + <span class="hljs-built_in">sin</span>(pitch/<span class="hljs-number">57.3f</span>)*<span class="hljs-built_in">sin</span>(roll/<span class="hljs-number">57.3f</span>)/<span class="hljs-built_in">cos</span>(pitch/<span class="hljs-number">57.3f</span>)*gy <br>              + <span class="hljs-built_in">sin</span>(pitch/<span class="hljs-number">57.3f</span>)*<span class="hljs-built_in">cos</span>(roll/<span class="hljs-number">57.3f</span>)/<span class="hljs-built_in">cos</span>(pitch/<span class="hljs-number">57.3f</span>)*gz;<br>  detla_pitch = <span class="hljs-built_in">cos</span>(roll/<span class="hljs-number">57.3f</span>)*gy - <span class="hljs-built_in">sin</span>(roll/<span class="hljs-number">57.3f</span>)*gz;<br>      detla_yaw =  <span class="hljs-built_in">sin</span>(roll/<span class="hljs-number">57.3f</span>)/<span class="hljs-built_in">cos</span>(pitch/<span class="hljs-number">57.3f</span>)*gy <br>                 - <span class="hljs-built_in">cos</span>(roll/<span class="hljs-number">57.3f</span>)/<span class="hljs-built_in">cos</span>(pitch/<span class="hljs-number">57.3f</span>)*gz;<br>  <br>      <span class="hljs-comment">//俯仰角Pitch解算</span><br>  Pitch_Accelerometer_CF = <span class="hljs-built_in">asin</span>(ax)*<span class="hljs-number">57.3f</span>;<span class="hljs-comment">//加速度计</span><br>  Pitch_Gyroscope_CF = Pitch_Last_CF - INS_cnt1 * detla_pitch;<span class="hljs-comment">//陀螺仪</span><br>  pitch = <span class="hljs-number">0.05f</span>*Pitch_Accelerometer_CF + <span class="hljs-number">0.95f</span>*Pitch_Gyroscope_CF;<span class="hljs-comment">//互补滤波</span><br>  Pitch_Last_CF = Data_Complementary_Filter.pitch;<br><br>      <span class="hljs-comment">//在J-scope中查看数据波形</span><br>  JS_Pitch_Accelerometer_CF = (<span class="hljs-keyword">int</span>)(Pitch_Accelerometer_CF*<span class="hljs-number">100</span>);<br>  JS_Pitch_CF = (<span class="hljs-keyword">int</span>)(Data_Complementary_Filter.pitch*<span class="hljs-number">100</span>);<br>  JS_Pitch_gy_CF = (<span class="hljs-keyword">int</span>)(Pitch_gy_CF*<span class="hljs-number">100</span>);<br>     <br>      <span class="hljs-comment">//滚转角Roll解算</span><br>    Roll_Accelerometer_CF = -<span class="hljs-built_in">asin</span>(ay/<span class="hljs-built_in">cos</span>(Pitch_Accelerometer_CF/<span class="hljs-number">57.3f</span>))*<span class="hljs-number">57.3f</span>;<br>      Roll_Gyroscope_CF  = Roll_Last_CF - INS_dt * detla_roll;<br>  roll = <span class="hljs-number">0.05f</span>*Roll_Accelerometer_CF + <span class="hljs-number">0.95f</span>*Roll_Gyroscope_CF;<br>  Roll_Last_CF = Data_Complementary_Filter.roll;<br><br>      <span class="hljs-comment">//将磁力计解算的数据投影到水平面</span><br>  mxe =  mx*<span class="hljs-built_in">cos</span>(pitch/<span class="hljs-number">57.3f</span>)<br>   + my*<span class="hljs-built_in">sin</span>(roll/<span class="hljs-number">57.3f</span>)*<span class="hljs-built_in">sin</span>(pitch/<span class="hljs-number">57.3f</span>)<br>   + mz*<span class="hljs-built_in">cos</span>(roll/<span class="hljs-number">57.3f</span>)*<span class="hljs-built_in">sin</span>(pitch/<span class="hljs-number">57.3f</span>);<br>  mye =  my*<span class="hljs-built_in">cos</span>(roll/<span class="hljs-number">57.3f</span>)<br>   - mz*<span class="hljs-built_in">sin</span>(roll/<span class="hljs-number">57.3f</span>);<br>      <span class="hljs-comment">//偏航角Yaw解算</span><br>  Yaw_Magnetometer_CF = <span class="hljs-built_in">atan2</span>(mxe,mye) * <span class="hljs-number">57.3f</span>;<br>  Yaw_Gyroscope_CF = Yaw_Last_CF - INS_dt * detla_yaw;<br>  yaw = <span class="hljs-number">0.05f</span>*Yaw_Magnetometer_CF + <span class="hljs-number">0.95f</span>*Yaw_Gyroscope_CF;<br>  Yaw_Last_CF = yaw;<br><br>  JS_Yaw_CF = (<span class="hljs-keyword">int</span>)(Data_Complementary_Filter.yaw*<span class="hljs-number">100</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-卡尔曼滤波："><a href="#3-2-卡尔曼滤波：" class="headerlink" title="3.2 卡尔曼滤波："></a>3.2 卡尔曼滤波：</h3><p>未完待续。。。。。。</p><h3 id="3-3-Mahony滤波算法：基于四元数"><a href="#3-3-Mahony滤波算法：基于四元数" class="headerlink" title="3.3 Mahony滤波算法：基于四元数"></a>3.3 Mahony滤波算法：基于四元数</h3><h4 id="3-3-1-原理："><a href="#3-3-1-原理：" class="headerlink" title="3.3.1 原理："></a>3.3.1 原理：</h4><h4 id="3-3-1-1-综合分析："><a href="#3-3-1-1-综合分析：" class="headerlink" title="3.3.1.1 综合分析："></a>3.3.1.1 综合分析：</h4><p>Mahony滤波算法整体来看，可以分为以下几步：</p><ul><li>根据目前估计的四元数，将机体坐标系下的磁力计数据转换到地球固连坐标系下，得到水平方向标准磁场方向</li><li>将标准磁场方向和重力加速度方向利用当前估计的四元数再转换到机体坐标系下</li><li>将测量的加速度和磁场方向在机体坐标系下的值和上一步中转换出的值求误差(叉积)，反映当前估计四元数的不准确程度</li><li>利用PID将求得的误差用于修正陀螺仪测得的机体角速度</li><li>利用机体角速度得到四元数导数，利用四元数导数更新当前估计的四元数，不断迭代修正四元数的估计值</li><li>将实时估计的四元数转换成欧拉角实时输出</li></ul><p>总结一下，其实整个算法可以看做两大步：<strong>计算误差和修正估计</strong>。算法基于四元数进行优化估计。</p><h4 id="3-3-1-2-计算误差："><a href="#3-3-1-2-计算误差：" class="headerlink" title="3.3.1.2 计算误差："></a>3.3.1.2 计算误差：</h4><p>误差估计的核心思想在于：地球固连坐标系<script type="math/tex">O_ex_ey_ez_e</script>中，加速度向量归一化的值为<script type="math/tex">\begin{pmatrix}0 & 0 &1\end{pmatrix}^T</script>，即只有向下的1g的重力加速度；磁力计测量的数据在地球固连坐标系中为<script type="math/tex">\begin{pmatrix}h_x & 0 &h_z\end{pmatrix}^T</script>，即只在x和z方向有值。上面描述的是理想值，理论上我们如果将上面的两个向量利用四元数转换到机体坐标系下，得到的值应当与加速度计和磁力计测量的值相等，但实际情况中两个值肯定不相等，我们就要计算出这两者之间的误差，利用这个误差进行下一步的修正。</p><p>具体步骤为：</p><p><strong>（1）将加速度计和磁力计测得的值归一化：</strong></p><p>归一化之后加速度计测得的加速度在机体坐标系下的值记为<script type="math/tex">^{b}\boldsymbol{a}=\begin{pmatrix}a_{xb} & a_{yb} &a_{zb}\end{pmatrix}^T</script>，磁力计测得的磁场数据在机体坐标系下的值记为<script type="math/tex">^{b}\boldsymbol{m}=\begin{pmatrix}m_{xb} & m_{yb} &m_{zb}\end{pmatrix}^T</script></p><p><strong>（2）求取地球固连坐标系下的参考加速度和磁场方向：</strong></p><p>将测得的磁场方向在机体坐标系下的值转换到地球固连坐标系下：$$^{e}\boldsymbol{m}=\begin{pmatrix}m_{xe} \\ m_{ye} \\ m_{ze}\end{pmatrix}=\boldsymbol{C}(\boldsymbol{q}_e^b)\begin{pmatrix}m_{xb} \\ m_{yb} \\ m_{zb}\end{pmatrix}=\begin{pmatrix}q_0^2+q_1^2-q_2^2-q_3^2&2(q_1q_2-q_0q_3)&2(q_1q_3+q_0q_2)\\2(q_1q_2+q_0q_3)&q_0^2-q_1^2+q_2^2-q_3^2&2(q_2q_3-q_0q_1)\\2(q_1q_3-q_0q_2)&2(q_2q_3+q_0q_1)&q_0^2-q_1^2-q_2^2+q_3^2\end{pmatrix}\begin{pmatrix}m_{xb} \\ m_{yb} \\ m_{zb}\end{pmatrix}$$</p><p>计算<script type="math/tex">^{e}\boldsymbol{m}</script>在水平和竖直方向上的投影：<script type="math/tex">h_{xe}=\sqrt{m_{xe}^2+m_{ye}^2}，h_{ze}=m_{ze}</script></p><p>则磁场方向在地球固连坐标系下的理想参考方向为<script type="math/tex">^{e}\boldsymbol{h}_r=\begin{pmatrix}h_{xe} & 0 &h_{ze}\end{pmatrix}^T</script>。</p><p>加速度在地球固连坐标系下的理想参考方向为<script type="math/tex">^{e}\boldsymbol{a}_r=\begin{pmatrix}0 & 0&1\end{pmatrix}^T</script>，即为重力加速度。</p><p><strong>（3）将地球固连坐标系下的参考加速度和磁场方向转换到机体坐标系下：</strong></p><p>磁场方向在机体坐标系下的理想参考值为：$$^{b}\boldsymbol{h}_r=\begin{pmatrix}h^r_{xb} \\ h^r_{yb} \\ h^r_{zb}\end{pmatrix}=(\boldsymbol{C}(\boldsymbol{q}_e^b))^T\begin{pmatrix}h_{xe} \\ 0 \\ h_{ze}\end{pmatrix}=\begin{pmatrix}q_0^2+q_1^2-q_2^2-q_3^2&2(q_1q_2+q_0q_3)&2(q_1q_3-q_0q_2)\\2(q_1q_2-q_0q_3)&q_0^2-q_1^2+q_2^2-q_3^2&2(q_2q_3+q_0q_1)\\2(q_1q_3+q_0q_2)&2(q_2q_3-q_0q_1)&q_0^2-q_1^2-q_2^2+q_3^2\end{pmatrix}\begin{pmatrix}h_{xe} \\ 0 \\ h_{ze}\end{pmatrix}$$</p><p>加速度在机体坐标系下的理想参考值为：$$^{b}\boldsymbol{a}_r=\begin{pmatrix}a^r_{xb} \\a^r_{yb} \\ a^r_{zb}\end{pmatrix}=(\boldsymbol{C}(\boldsymbol{q}_e^b))^T\begin{pmatrix}0 \\ 0 \\ 1\end{pmatrix}=\begin{pmatrix}q_0^2+q_1^2-q_2^2-q_3^2&2(q_1q_2+q_0q_3)&2(q_1q_3-q_0q_2)\\2(q_1q_2-q_0q_3)&q_0^2-q_1^2+q_2^2-q_3^2&2(q_2q_3+q_0q_1)\\2(q_1q_3+q_0q_2)&2(q_2q_3-q_0q_1)&q_0^2-q_1^2-q_2^2+q_3^2\end{pmatrix}\begin{pmatrix}0 \\ 0 \\ 1\end{pmatrix}$$</p><p><strong>（4）利用叉积计算加速度和磁场方向在机体坐标系下测量值和理想参考值之间的误差：</strong></p><p>误差为：$$^{b}\boldsymbol{e}= \ ^{b}\boldsymbol{m}\times \ ^{b}\boldsymbol{h}_r+ \ ^{b}\boldsymbol{a}\times\ ^{b}\boldsymbol{a}_r$$</p><p>即： $$\begin{pmatrix}e_{x} \\ e_{y} \\ e_{z}\end{pmatrix}=\begin{pmatrix}m_{yb}h^r_{zb}-m_{zb}h^r_{yb} \\ m_{zb}h^r_{xb}-m_{xb}h^r_{zb}\\ m_{xb}h^r_{yb}-m_{yb}h^r_{xb}\end{pmatrix}+\begin{pmatrix}a_{yb}a^r_{zb}-a_{zb}a^r_{yb} \\ a_{zb}a^r_{xb}-a_{xb}a^r_{zb}\\ a_{xb}a^r_{yb}-a_{yb}a^r_{xb}\end{pmatrix}$$</p><h4 id="3-3-1-3-修正估计："><a href="#3-3-1-3-修正估计：" class="headerlink" title="3.3.1.3 修正估计："></a>3.3.1.3 修正估计：</h4><p><strong>（1）利用误差修正陀螺仪测量的机体角速度：</strong></p><p>陀螺仪测得的机体角速度在机体坐标系下的值记为<script type="math/tex">^{b}\boldsymbol{\omega}^m=\begin{pmatrix}\omega^m_{xb} & \omega^m_{yb} &\omega^m_{zb}\end{pmatrix}^T</script>，修正过后的值记为<script type="math/tex">^{b}\boldsymbol{\omega}=\begin{pmatrix}\omega_{xb} & \omega_{yb} &\omega_{zb}\end{pmatrix}^T</script>。</p><p>则修正利用误差项通过<strong>PID</strong>进行：$$^{b}\boldsymbol{\omega}= \ ^{b}\boldsymbol{\omega}^m+K_p\times  \ ^{b}\boldsymbol{e}+K_i\times \int \ ^{b}\boldsymbol{e}  $$</p><p><strong>（2）利用修正过的机体角速度计算四元数导数：</strong>$$\dot{\boldsymbol{q}_e^b}=\frac{1}{2}\begin{pmatrix}0&-\omega_{xb}&-\omega_{yb}&-\omega_{zb} \\\omega_{xb}&0&\omega_{zb}&-\omega_{yb}\\\omega_{yb}&-\omega_{zb}&0& \omega_{xb}\\\omega_{zb}&\omega_{yb}&-\omega_{xb}&0\end{pmatrix}\begin{pmatrix}q_0 \\ q_1 \\q_2\\q_3\end{pmatrix}$$</p><p><strong>（3）利用四元数导数更新四元数的估计值：</strong> $$\boldsymbol{q}_e^b[n] = \boldsymbol{q}_e^b[n-1] +T_s\times \dot{\boldsymbol{q}_e^b}$$           </p><p>上式中<script type="math/tex">T_s</script>为采样间隔。  </p><h4 id="3-3-2-效果："><a href="#3-3-2-效果：" class="headerlink" title="3.3.2 效果："></a>3.3.2 效果：</h4><p>俯仰角Pitch解算比较：</p><p><img src="/img/IMU_solve/MH_Pitch.svg" alt="MH_Pitch"></p><p>滚转角Roll解算比较：</p><p><img src="/img/IMU_solve/MH_Roll.svg" alt="MH_Roll"></p><p>偏航角Yaw解算比较：</p><p><img src="/img/IMU_solve/MH_Yaw.svg" alt="MH_Yaw"></p><p>可以看到，Mahony算法解算的结果和标准解算的结果很接近，动态响应较快，可以跟上较快的角度变化。在欧拉角较大的时候也能进行正常的解算。</p><h4 id="3-3-3-代码：STM32F405"><a href="#3-3-3-代码：STM32F405" class="headerlink" title="3.3.3 代码：STM32F405"></a>3.3.3 代码：STM32F405</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//mahony解算算法:</span><br><br><span class="hljs-keyword">float</span> mahony_Kp = <span class="hljs-number">2.0f</span>;<span class="hljs-comment">//PID的参数</span><br><span class="hljs-keyword">float</span> mahony_Ki = <span class="hljs-number">0.005f</span>;<span class="hljs-comment">//PID的参数      </span><br><span class="hljs-keyword">float</span> mahony_halfT = <span class="hljs-number">0.0025f</span>;<span class="hljs-comment">//采样周期的一半</span><br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">float</span> q0 = <span class="hljs-number">1</span>, q1 = <span class="hljs-number">0</span>, q2 = <span class="hljs-number">0</span>, q3 = <span class="hljs-number">0</span>;<span class="hljs-comment">//待估计的四元数        </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">float</span> exInt = <span class="hljs-number">0</span>, eyInt = <span class="hljs-number">0</span>, ezInt = <span class="hljs-number">0</span>;<span class="hljs-comment">//PID中的积分项</span><br><br><span class="hljs-keyword">float</span> norm;  <br><span class="hljs-keyword">float</span> hx, hy, hz, bx, bz;  <br><span class="hljs-keyword">float</span> vx, vy, vz, wx, wy, wz;   <br><span class="hljs-keyword">float</span> ex, ey, ez;  <br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mahony_AHRSupdate</span><span class="hljs-params">(<span class="hljs-keyword">float</span> gx, <span class="hljs-keyword">float</span> gy, <span class="hljs-keyword">float</span> gz, <span class="hljs-keyword">float</span> ax, <span class="hljs-keyword">float</span> ay, <span class="hljs-keyword">float</span> az, <span class="hljs-keyword">float</span> mx, <span class="hljs-keyword">float</span> my, <span class="hljs-keyword">float</span> mz)</span> </span><br><span class="hljs-function"></span>&#123;     <br>     <span class="hljs-comment">//实测的采样周期的一半</span><br> mahony_halfT = INS_cnt1/<span class="hljs-number">2.f</span>;<br>  <br> <span class="hljs-comment">//避免重复计算</span><br> <span class="hljs-keyword">float</span> q0q0 = q0*q0;  <br> <span class="hljs-keyword">float</span> q0q1 = q0*q1;  <br> <span class="hljs-keyword">float</span> q0q2 = q0*q2;  <br> <span class="hljs-keyword">float</span> q0q3 = q0*q3;  <br> <span class="hljs-keyword">float</span> q1q1 = q1*q1;  <br> <span class="hljs-keyword">float</span> q1q2 = q1*q2;  <br> <span class="hljs-keyword">float</span> q1q3 = q1*q3;  <br> <span class="hljs-keyword">float</span> q2q2 = q2*q2;  <br> <span class="hljs-keyword">float</span> q2q3 = q2*q3;  <br> <span class="hljs-keyword">float</span> q3q3 = q3*q3;  <br><br> <span class="hljs-comment">//将加速度计和磁力计测量数据归一化  </span><br> norm = <span class="hljs-built_in">sqrt</span>(ax*ax + ay*ay + az*az);  <br> <span class="hljs-keyword">if</span>(norm!=<span class="hljs-number">0</span>)<br> &#123;<br>   ax = ax / norm;  <br>   ay = ay / norm;  <br>   az = az / norm; <br> &#125; <br> norm = <span class="hljs-built_in">sqrt</span>(mx*mx + my*my + mz*mz);<br>    <span class="hljs-keyword">if</span>(norm!=<span class="hljs-number">0</span>)<br> &#123; <br>   mx = mx / norm;  <br>   my = my / norm;  <br>   mz = mz / norm;  <br> &#125;<br><br> <span class="hljs-comment">//将磁力计测量的数据转换到地面固连坐标系下 </span><br> hx = <span class="hljs-number">2</span>*mx*(<span class="hljs-number">0.5</span> - q2q2 - q3q3) + <span class="hljs-number">2</span>*my*(q1q2 - q0q3) + <span class="hljs-number">2</span>*mz*(q1q3 + q0q2);  <br> hy = <span class="hljs-number">2</span>*mx*(q1q2 + q0q3) + <span class="hljs-number">2</span>*my*(<span class="hljs-number">0.5</span> - q1q1 - q3q3) + <span class="hljs-number">2</span>*mz*(q2q3 - q0q1);  <br> hz = <span class="hljs-number">2</span>*mx*(q1q3 - q0q2) + <span class="hljs-number">2</span>*my*(q2q3 + q0q1) + <span class="hljs-number">2</span>*mz*(<span class="hljs-number">0.5</span> - q1q1 -q2q2);        <br> bx = <span class="hljs-built_in">sqrt</span>((hx*hx) + (hy*hy));  <br> bz = hz;  <br><br>     <span class="hljs-comment">//将地面固连坐标系下标准重力加速度和磁场方向再转换到机体坐标系下 </span><br> vx = <span class="hljs-number">2</span>*(q1q3 - q0q2);  <br> vy = <span class="hljs-number">2</span>*(q0q1 + q2q3);  <br> vz = q0q0 - q1q1 - q2q2 + q3q3;  <br> wx = <span class="hljs-number">2</span>*bx*(<span class="hljs-number">0.5</span> - q2q2 - q3q3) + <span class="hljs-number">2</span>*bz*(q1q3 - q0q2);  <br> wy = <span class="hljs-number">2</span>*bx*(q1q2 - q0q3) + <span class="hljs-number">2</span>*bz*(q0q1 + q2q3);  <br> wz = <span class="hljs-number">2</span>*bx*(q0q2 + q1q3) + <span class="hljs-number">2</span>*bz*(<span class="hljs-number">0.5</span> - q1q1 - q2q2);   <br>            <br>     <span class="hljs-comment">//计算实际测量值和上面转换后的参考值之间的误差，误差用叉积来计算</span><br> ex = (ay*vz - az*vy) + (my*wz - mz*wy);  <br> ey = (az*vx - ax*vz) + (mz*wx - mx*wz);  <br> ez = (ax*vy - ay*vx) + (mx*wy - my*wx);  <br>            <br> <span class="hljs-comment">//计算PID中误差的积分</span><br> exInt = exInt + ex*mahony_Ki* (INS_cnt1);  <br> eyInt = eyInt + ey*mahony_Ki* (INS_cnt1);  <br> ezInt = ezInt + ez*mahony_Ki* (INS_cnt1);  <br> <span class="hljs-comment">//利用上面计算的误差来调整机体角速度，思想为PID </span><br> gx = gx + mahony_Kp*ex + exInt;  <br> gy = gy + mahony_Kp*ey + eyInt;  <br> gz = gz + mahony_Kp*ez + ezInt;  <br>            <br> <span class="hljs-comment">//利用上面的四元数导数和机体坐标系的关系得到四元数导数，然后更新当前四元数的估计值</span><br> q0 = q0 + (-q1*gx - q2*gy - q3*gz)*mahony_halfT;  <br> q1 = q1 + (q0*gx + q2*gz - q3*gy)*mahony_halfT;  <br> q2 = q2 + (q0*gy - q1*gz + q3*gx)*mahony_halfT;  <br> q3 = q3 + (q0*gz + q1*gy - q2*gx)*mahony_halfT;   <br><br> <span class="hljs-comment">//归一化得到单位四元数</span><br> norm = <span class="hljs-built_in">sqrt</span>(q0*q0 + q1*q1 + q2*q2 + q3*q3);  <br> q0 = q0 / norm;  <br> q1 = q1 / norm;  <br> q2 = q2 / norm;  <br> q3 = q3 / norm;  <br>&#125;  <br><br><span class="hljs-keyword">int</span> JS_Pitch_Mahony;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Get_Eular_Angle_Mahony</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-comment">//调用上面Mahony的算法得到四元数的估计值</span><br>     <span class="hljs-comment">//注意角速度单位为rad/s</span><br> <span class="hljs-built_in">mahony_AHRSupdate</span>(JY_901B_Data.Gyroscope.gx/<span class="hljs-number">57.3f</span>,                     <br>                       JY_901B_Data.Gyroscope.gy/<span class="hljs-number">57.3f</span>,<br>                       JY_901B_Data.Gyroscope.gz/<span class="hljs-number">57.3f</span>, <br>               JY_901B_Data.Accelerometer.ax, <br>                       JY_901B_Data.Accelerometer.ay, <br>                       JY_901B_Data.Accelerometer.az, <br>                   JY_901B_Data.magnetometer.mx, <br>                       JY_901B_Data.magnetometer.my, <br>                       JY_901B_Data.magnetometer.mz);<br>    <br>     <span class="hljs-comment">//由四元数得到欧拉角</span><br>     Data_Mahony.pitch = <span class="hljs-built_in">asin</span>(<span class="hljs-number">2</span>*(q0*q2-q1*q3)) * <span class="hljs-number">57.3f</span>;<br> Data_Mahony.roll = <span class="hljs-built_in">atan2</span>(<span class="hljs-number">2</span>*(q0*q1+q2*q3),<span class="hljs-number">1</span><span class="hljs-number">-2</span>*q1*q1<span class="hljs-number">-2</span>*q2*q2) *<span class="hljs-number">57.3f</span>;<br> Data_Mahony.yaw = <span class="hljs-built_in">atan2</span>(<span class="hljs-number">2</span>*(q0*q3+q1*q2),<span class="hljs-number">1</span><span class="hljs-number">-2</span>*q3*q3<span class="hljs-number">-2</span>*q2*q2) *<span class="hljs-number">57.3f</span>;<br> <br>     <span class="hljs-comment">//在J-scope中显示波形</span><br> JS_Pitch_Mahony = -(<span class="hljs-keyword">int</span>)(<span class="hljs-number">100</span>*Data_Mahony.pitch);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>IMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电机和云台系统辨识方法</title>
    <link href="/2021/12/02/%E7%94%B5%E6%9C%BA%E4%BA%91%E5%8F%B0%E7%B3%BB%E7%BB%9F%E8%BE%A8%E8%AF%86%E6%96%B9%E6%B3%95/"/>
    <url>/2021/12/02/%E7%94%B5%E6%9C%BA%E4%BA%91%E5%8F%B0%E7%B3%BB%E7%BB%9F%E8%BE%A8%E8%AF%86%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1-基本思路"><a href="#1-基本思路" class="headerlink" title="1 基本思路"></a>1 基本思路</h2><h3 id="1-1-系统辨识目标"><a href="#1-1-系统辨识目标" class="headerlink" title="1.1 系统辨识目标"></a>1.1 系统辨识目标</h3><p>在控制方案的设计过程中，我们经常需要知道系统的传递函数或者是状态空间方程。只有知道了系统的传递函数，我们才能采用经典控制理论中的工具去分析系统并提出改进方案，根轨迹法以及频率响应法都需要知道系统的开环传递函数，超前-滞后校正器也需要知道系统的相位裕度才有了前进的方向，系统的带宽则需要根据闭环伯德图来确定。</p><p>我们想要知道系统的稳定性(可以通过相位裕度)或者响应速度(可以通过带宽)，并根据具体目标设计超前/滞后校正器或者PID等控制器来提升控制系统的性能，前提是必须知道系统的传递函数。而设计LQR控制器等则需要知道系统的状态空间方程。所以我们必须进行系统辨识，得到系统的传递函数，才能有的放矢的设计控制器来提高系统的性能。</p><p>系统辨识的目标就是在给定一组时域的输入-输出数据之后，得到系统的传递函数或者是状态空间方程。</p><p>在实际应用中，我们需要控制电机或者云台(本质上也是在控制电机)，一般采用的是双环PID，其中位置环仅仅是简单的运动学微分关系，即速度是位置的微分，两者在<script type="math/tex">s</script>域相差一个<script type="math/tex">s</script>的系数，没有什么可辨识的。一般我们感兴趣的是电机电流到电机速度的传递函数，这个一般来说会受到转动惯量、粘滞阻尼、电机转矩常数等多种因素制约，而这些参数我们一般不容易精确测定，这时候就需要通过系统辨识来得到从电机电流到电机转速的传递函数。</p><h3 id="1-2-系统框图"><a href="#1-2-系统框图" class="headerlink" title="1.2 系统框图"></a>1.2 系统框图</h3><p><img src="/img/SystemIdentification/框图.png" alt=""></p><p>一般闭环系统框图如上图所示。以电机速度环为例，<script type="math/tex">r(t)</script>是参考输入，即电机的期望速度；<script type="math/tex">C(s)</script>是控制器的传递函数，即PID等控制器的传递函数；<script type="math/tex">G(s)</script>是被控对象的传递函数，即从电机电流到电机速度的传递函数；<script type="math/tex">H(s)</script>为观测器的传递函数，电机速度环中该传递函数为1，即单位反馈；<script type="math/tex">y(t)</script>为输出，即电机实际的速度输出；<script type="math/tex">u</script>是系统的输入，电机速度环中即为电机的电流。</p><p>系统的闭环传递函数为：<script type="math/tex">\Phi(s)=\frac{Y(s)}{R(s)}=\frac{C(s)G(s)}{1+C(s)G(s)H(s)}</script>，该传递函数可用于确定当给一个期望的速度时，系统实际输出的速度到底是什么，即在参考输入和实际输出之间架起了桥梁。</p><h3 id="1-3-基本原理"><a href="#1-3-基本原理" class="headerlink" title="1.3 基本原理"></a>1.3 基本原理</h3><p>在实际中，我们采集不同频率下的云台或电机输入输出数据（即参考的速度输入和实际的速度输出），通过系统辨识确定系统的闭环传递函数<script type="math/tex">\Phi(s)</script>。</p><p>因为系统的闭环传递函数<script type="math/tex">\Phi(s)</script>架起了参考输入<script type="math/tex">r(t)</script>和实际输出<script type="math/tex">y(t)</script>之间的桥梁，所以我们采集不同频率下的参考输入-实际输出数据（速度环例子中即为期望的速度和实际的速度），即可确定系统的闭环传递函数<script type="math/tex">\Phi(s)</script>。之后我们可以再算出系统的开环传递函数，进行控制器的设计。</p><p>若要想直接确定系统的开环传递函数，因为被控对象的传递函数<script type="math/tex">G(s)</script>架起了系统输入<script type="math/tex">u(t)</script>和实际输出<script type="math/tex">y(t)</script>之间的桥梁，所以我们采集不同频率下的系统输入-实际输出数据（速度环例子中即为电机的电流和实际的速度），即可确定被控对象的传递函数<script type="math/tex">G(s)</script>。之后我们可以再算出系统的开环传递函数，进行控制器的设计。</p><p>为了得到不同频率下响应的幅度-相位关系，我们依次输入从低频到高频的不同频率的正弦波，采集系统的实际响应，以此进行系统辨识。</p><h3 id="1-4-所需工具"><a href="#1-4-所需工具" class="headerlink" title="1.4 所需工具"></a>1.4 所需工具</h3><p>Keil、J-scope、Matlab(systeIdentification工具箱)。</p><h3 id="1-5-基本步骤："><a href="#1-5-基本步骤：" class="headerlink" title="1.5 基本步骤："></a>1.5 基本步骤：</h3><ul><li>在Yaw轴云台/电机上加载速度环PID控制器，使得系统可以稳定运行</li><li>写一个简单的信号发生器，将频率逐渐增加的激励信号输入至PID控制器</li><li>采集并记录对应时刻的激励信号和角速度信息(期望速度和实际速度)</li><li>对输入输出数据进行系统辨识得到系统闭环传递函数，用其他方法进行验证</li></ul><h2 id="2-电机系统辨识效果"><a href="#2-电机系统辨识效果" class="headerlink" title="2 电机系统辨识效果"></a>2 电机系统辨识效果</h2><h3 id="2-1-激励信号"><a href="#2-1-激励信号" class="headerlink" title="2.1 激励信号"></a>2.1 激励信号</h3><p>产生频率从1Hz到500Hz变化的正弦信号，每个频率点持续一定周期。由于频率范围较大，且高频部分云台振幅变化较小，为了减少数据量，采用类指数形式的变化趋势。为了保证信号不会发生跳变，在每次信号频率发生变化时都需要从零相位开始，因此周期需要是整数。使用MATLAB生成的激励信号频率如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">F = ([<span class="hljs-number">1</span>:<span class="hljs-number">0.5</span>:<span class="hljs-number">22</span>, <span class="hljs-number">24</span>:<span class="hljs-number">2</span>:<span class="hljs-number">40</span>, <span class="hljs-number">50</span>:<span class="hljs-number">10</span>:<span class="hljs-number">120</span>,<span class="hljs-number">200</span>,<span class="hljs-number">250</span>,<span class="hljs-number">333</span>,<span class="hljs-number">500</span>]);<br>T = <span class="hljs-built_in">round</span>(<span class="hljs-number">1000.</span>/F);<span class="hljs-comment">%周期取整</span><br>F = <span class="hljs-number">1000.</span>/T;        <br></code></pre></td></tr></table></figure><h3 id="2-2-数据采集"><a href="#2-2-数据采集" class="headerlink" title="2.2 数据采集"></a>2.2 数据采集</h3><p>将J-scope中电机采集到的输入-输出数据导出为csv格式的文件，进而转为Excel导入到matlab中进一步处理。</p><p>得到的参考输入和实际输出的时域图像为：</p><p><img src="/img/SystemIdentification/时域输入输出.svg" alt=""></p><p>由时域图像可以看出，在高频下输出的幅度明显衰减。</p><h3 id="2-3-辨识结果"><a href="#2-3-辨识结果" class="headerlink" title="2.3 辨识结果"></a>2.3 辨识结果</h3><p>之后将数据导入到systemIdentification工具箱中进行系统辨识。因为目前我的J-scope的采集频率只能到80Hz左右，采样间隔在12ms-20ms之间不等，因此Sample time 设定为0.016，即16ms，实测和其他两种方法得到的结果较为吻合。注意这个Sample time的设定一定要与实际的采样间隔相符合，否则得到的结果有较大问题。</p><p>辨识得到的传递函数为：   $$\Phi(s)=\frac{Y(s)}{R(s)}=\frac{86.9s+9691}{s^2+136.7s+10420}$$   </p><p>系统伯德图为：</p><p><img src="/img/SystemIdentification/bode_sys_cl.svg" alt=""></p><h3 id="2-4-结果验证"><a href="#2-4-结果验证" class="headerlink" title="2.4 结果验证"></a>2.4 结果验证</h3><h4 id="2-4-1-直接测量不同频率下输出的幅值和相位"><a href="#2-4-1-直接测量不同频率下输出的幅值和相位" class="headerlink" title="2.4.1 直接测量不同频率下输出的幅值和相位"></a>2.4.1 直接测量不同频率下输出的幅值和相位</h4><p>在stm32的程序中，通过查找一定时间内的云台角速度的极值找出幅度，通过计算输入输出信号下降沿穿过x轴的时间差除以周期来计算该频率下的相位差。</p><p>得到输入-输出的幅度和相位差分别为：</p><p><img src="/img/SystemIdentification/direct_sys_cl.svg" alt=""></p><h4 id="2-4-2-对时域数据进行FFT得到频率响应"><a href="#2-4-2-对时域数据进行FFT得到频率响应" class="headerlink" title="2.4.2 对时域数据进行FFT得到频率响应"></a>2.4.2 对时域数据进行FFT得到频率响应</h4><p>对时域数据做fft变换，然后计算输入输出数据的幅度比和相位差，得到系统的频率响应：</p><p><img src="/img/SystemIdentification/fft_sys_cl.svg" alt=""></p><h4 id="2-4-3-三种方法比较"><a href="#2-4-3-三种方法比较" class="headerlink" title="2.4.3 三种方法比较"></a>2.4.3 三种方法比较</h4><p>三种方法得到的闭环响应幅频特性比较如下：</p><p><img src="/img/SystemIdentification/3_sys_cl.svg" alt=""></p><p>由图可见，在低频部分，系统辨识得到的传递函数能够较好的拟合fft变换的结果和实测的频率响应结果，因此可以用该传递函数来刻画电机系统。<br>由bode图可以看出3dB带宽大概为140rad/s，实际意义就是该云台系统能够响应的频率22.3Hz以内。</p><h3 id="2-5-后续"><a href="#2-5-后续" class="headerlink" title="2.5 后续"></a>2.5 后续</h3><p>得到系统闭环传递函数后，经过处理可以得到开环传递函数，以便进一步分析系统稳定性(bode图、Nyquist图等)，还可以用频率分析法对环路进行整形，设计超前校正器，从而达到我们想要的性能。</p><h3 id="2-6-代码"><a href="#2-6-代码" class="headerlink" title="2.6 代码"></a>2.6 代码</h3><h4 id="2-6-1-Keil中产生激励信号并收集幅度和相位信息"><a href="#2-6-1-Keil中产生激励信号并收集幅度和相位信息" class="headerlink" title="2.6.1 Keil中产生激励信号并收集幅度和相位信息"></a>2.6.1 Keil中产生激励信号并收集幅度和相位信息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">float</span> t[<span class="hljs-number">64</span>] = &#123;<span class="hljs-number">1000</span>, <span class="hljs-number">667</span>, <span class="hljs-number">500</span>, <span class="hljs-number">400</span>, <span class="hljs-number">333</span>, <span class="hljs-number">286</span>, <span class="hljs-number">250</span>, <span class="hljs-number">222</span>, <span class="hljs-number">200</span>, <span class="hljs-number">182</span>, <span class="hljs-number">167</span>, <span class="hljs-number">154</span>, <span class="hljs-number">143</span>, <span class="hljs-number">133</span>, <span class="hljs-number">125</span>, <span class="hljs-number">118</span>, <span class="hljs-number">111</span>, <span class="hljs-number">105</span>, <span class="hljs-number">100</span>, <span class="hljs-number">95</span>, <span class="hljs-number">91</span>, <span class="hljs-number">87</span>, <span class="hljs-number">83</span>, <span class="hljs-number">80</span>, <span class="hljs-number">77</span>, <span class="hljs-number">74</span>, <span class="hljs-number">71</span>, <span class="hljs-number">69</span>, <span class="hljs-number">67</span>, <span class="hljs-number">65</span>, <span class="hljs-number">63</span>, <span class="hljs-number">61</span>, <span class="hljs-number">59</span>, <span class="hljs-number">57</span>, <span class="hljs-number">56</span>, <span class="hljs-number">54</span>, <span class="hljs-number">53</span>, <span class="hljs-number">51</span>, <span class="hljs-number">50</span>, <span class="hljs-number">49</span>, <span class="hljs-number">48</span>, <span class="hljs-number">47</span>, <span class="hljs-number">45</span>, <span class="hljs-number">42</span>, <span class="hljs-number">38</span>, <span class="hljs-number">36</span>, <span class="hljs-number">33</span>, <span class="hljs-number">31</span>, <span class="hljs-number">29</span>, <span class="hljs-number">28</span>, <span class="hljs-number">26</span>, <span class="hljs-number">25</span>, <span class="hljs-number">20</span>, <span class="hljs-number">17</span>, <span class="hljs-number">14</span>, <span class="hljs-number">13</span>, <span class="hljs-number">11</span>, <span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>&#125;;<span class="hljs-comment">//不同频率信号的周期</span><br><span class="hljs-keyword">float</span> f[<span class="hljs-number">64</span>] = &#123;<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.499250</span>, <span class="hljs-number">2.000000</span>, <span class="hljs-number">2.500000</span>, <span class="hljs-number">3.003003</span>, <span class="hljs-number">3.496503</span>, <span class="hljs-number">4.000000</span>, <span class="hljs-number">4.504505</span>, <span class="hljs-number">5.000000</span>, <span class="hljs-number">5.494505</span>, <span class="hljs-number">5.988024</span>, <span class="hljs-number">6.493506</span>, <span class="hljs-number">6.993007</span>, <span class="hljs-number">7.518797</span>, <span class="hljs-number">8.000000</span>, <span class="hljs-number">8.474576</span>, <span class="hljs-number">9.009009</span>, <span class="hljs-number">9.523810</span>, <span class="hljs-number">10.000000</span>, <span class="hljs-number">10.526316</span>, <span class="hljs-number">10.989011</span>, <span class="hljs-number">11.494253</span>, <span class="hljs-number">12.048193</span>, <span class="hljs-number">12.500000</span>, <span class="hljs-number">12.987013</span>, <span class="hljs-number">13.513514</span>, <span class="hljs-number">14.084507</span>, <span class="hljs-number">14.492754</span>, <span class="hljs-number">14.925373</span>, <span class="hljs-number">15.384615</span>, <span class="hljs-number">15.873016</span>, <span class="hljs-number">16.393443</span>, <span class="hljs-number">16.949153</span>, <span class="hljs-number">17.543860</span>, <span class="hljs-number">17.857143</span>, <span class="hljs-number">18.518519</span>, <span class="hljs-number">18.867925</span>, <span class="hljs-number">19.607843</span>, <span class="hljs-number">20.000000</span>, <span class="hljs-number">20.408163</span>, <span class="hljs-number">20.833333</span>, <span class="hljs-number">21.276596</span>, <span class="hljs-number">22.222222</span>, <span class="hljs-number">23.809524</span>, <br><span class="hljs-number">26.315789</span>, <span class="hljs-number">27.777778</span>, <span class="hljs-number">30.303030</span>, <span class="hljs-number">32.258065</span>, <span class="hljs-number">34.482759</span>, <span class="hljs-number">35.714286</span>, <span class="hljs-number">38.461538</span>, <span class="hljs-number">40.000000</span>, <span class="hljs-number">50.0000</span>, <span class="hljs-number">58.8235</span>, <span class="hljs-number">71.4286</span>, <span class="hljs-number">76.9231</span>, <span class="hljs-number">90.9091</span>, <span class="hljs-number">100.0000</span>, <span class="hljs-number">111.1111</span>, <span class="hljs-number">125.0000</span>, <span class="hljs-number">200.0000</span>, <span class="hljs-number">250.0000</span>, <span class="hljs-number">333.3333</span>, <span class="hljs-number">500.0000</span>&#125;;<span class="hljs-comment">//不同频率信号的频率</span><br><br><span class="hljs-keyword">int</span> mag[<span class="hljs-number">64</span>] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//存放不同频率时的幅度信息</span><br><span class="hljs-keyword">int</span> phase[<span class="hljs-number">64</span>] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//存放不同频率时的相位信息</span><br><span class="hljs-keyword">int</span> i_measure = <span class="hljs-number">0</span>;<span class="hljs-comment">//存放幅度相位信息时的数组下标</span><br><br><span class="hljs-keyword">int</span> i_sin = <span class="hljs-number">0</span>;<span class="hljs-comment">//选择不同频率的数组下标</span><br><span class="hljs-keyword">float</span> time_sin = <span class="hljs-number">0</span>;<span class="hljs-comment">//正弦信号的计时器</span><br><span class="hljs-keyword">float</span> sin_signal;<span class="hljs-comment">//最终的正弦信号</span><br><br><span class="hljs-keyword">int8_t</span> record_phase = <span class="hljs-number">1</span>;<span class="hljs-comment">//记录相位时需要的标志位</span><br><span class="hljs-keyword">int</span> state = <span class="hljs-number">0</span>;<span class="hljs-comment">//状态机，记录相位时需要</span><br><span class="hljs-keyword">float</span> time_target_0 = <span class="hljs-number">0</span>;<span class="hljs-comment">//参考输入穿越0点的时间</span><br><span class="hljs-keyword">float</span> time_actual_0 = <span class="hljs-number">0</span>;<span class="hljs-comment">//实际输出穿越0点的时间</span><br><br><span class="hljs-comment">//以下代码可以在FreeRTOS里专门开个Task在里面1ms跑一次：</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SignalGenerate</span><span class="hljs-params">(<span class="hljs-keyword">void</span> <span class="hljs-keyword">const</span> * argument)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/* USER CODE BEGIN SignalGenerate */</span><br>  <span class="hljs-comment">/* Infinite loop */</span><br>  <span class="hljs-keyword">for</span>(;;)<br>  &#123;<br>    <span class="hljs-keyword">if</span>(time_sin * <span class="hljs-number">100</span> &gt; t[i_sin] &amp;&amp; i_sin &lt;= <span class="hljs-number">63</span>)<br>    &#123;<span class="hljs-comment">//不同频率信号之间的切换，改变time_sin * 100中的数字可以调节总时间</span><br> i_sin++;<br> i_measure++;<br>   time_sin = <span class="hljs-number">0</span>;<br> record_phase =<span class="hljs-number">1</span>;<br> state = <span class="hljs-number">0</span>;<br>     &#125;<br>    <span class="hljs-keyword">if</span>(i_sin == <span class="hljs-number">64</span>)<span class="hljs-comment">//激励信号结束</span><br> &#123;<br> sin_signal = <span class="hljs-number">0</span>;<br> time_sin = <span class="hljs-number">0</span>;<br> &#125;<br><br> sin_signal = <span class="hljs-built_in">sin</span>(<span class="hljs-number">2</span> * <span class="hljs-number">3.1415926</span> * f[i_sin] * time_sin);<span class="hljs-comment">//正弦信号</span><br> <span class="hljs-comment">//sin_signal = sin(2 * 3.1415926 * f[i_sin] * time_sin) &gt; 0?0:1;//阶跃信号</span><br><br> time_sin += <span class="hljs-number">0.001f</span>;<br>      <br> motor_pid[<span class="hljs-number">0</span>].target = <span class="hljs-number">2000</span>*sin_signal;<span class="hljs-comment">//闭环传递函数辨识</span><br> <span class="hljs-comment">//motor_pid[0].output = 2000*sin_signal;//开环传递函数辨识</span><br><br> <span class="hljs-keyword">if</span>(moto_chassis[<span class="hljs-number">0</span>].speed_rpm &gt; mag[i_measure])<span class="hljs-comment">//记录最大幅度</span><br>   mag[i_measure] = moto_chassis[<span class="hljs-number">0</span>].speed_rpm;<br><br> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(motor_pid[<span class="hljs-number">0</span>].target)&lt;<span class="hljs-number">20</span> &amp;&amp; state == <span class="hljs-number">0</span>)<span class="hljs-comment">//记录穿越零点的时间 </span><br> &#123; <br> time_target_0 = time_sin;<br> state = <span class="hljs-number">1</span>;<br> &#125;<br> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(moto_chassis[<span class="hljs-number">0</span>].speed_rpm)&lt;<span class="hljs-number">20</span> &amp;&amp; state ==<span class="hljs-number">1</span> ) <br> &#123;<br> time_actual_0 = time_sin;<br> state = <span class="hljs-number">2</span>;<br> &#125;<br> <span class="hljs-keyword">if</span>(record_phase &amp;&amp; state == <span class="hljs-number">2</span>)<span class="hljs-comment">//记录相位</span><br> &#123;<br> phase[i_measure] = (<span class="hljs-keyword">int</span>)(<span class="hljs-number">360</span>*                                                          (time_actual_0time_target_0)/(t[i_measure]/<span class="hljs-number">1000.0f</span>))%<span class="hljs-number">360</span>;<br> record_phase = <span class="hljs-number">0</span>;<br> &#125;<br>      <br>     osDelay(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-comment">/* USER CODE END SignalGenerate */</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="2-6-2-matlab中数据处理代码"><a href="#2-6-2-matlab中数据处理代码" class="headerlink" title="2.6.2 matlab中数据处理代码"></a>2.6.2 matlab中数据处理代码</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%%计算激励信号的产生周期</span><br>F = ([<span class="hljs-number">1</span>:<span class="hljs-number">0.5</span>:<span class="hljs-number">22</span>, <span class="hljs-number">24</span>:<span class="hljs-number">2</span>:<span class="hljs-number">40</span>, <span class="hljs-number">50</span>:<span class="hljs-number">10</span>:<span class="hljs-number">120</span>,<span class="hljs-number">200</span>,<span class="hljs-number">250</span>,<span class="hljs-number">333</span>,<span class="hljs-number">500</span>]);<br>T = <span class="hljs-built_in">round</span>(<span class="hljs-number">1000.</span>/F)<span class="hljs-comment">%对激励信号的周期进行取整        </span><br>F = <span class="hljs-number">1000.</span>/T<br><br><span class="hljs-comment">%%计算FFT的代码</span><br>N_FFT = <span class="hljs-number">8192</span>;<br>Fs = <span class="hljs-number">80</span>;<span class="hljs-comment">%采样频率，单位为Hz</span><br>Y1 = fft(test_target4,N_FFT);<span class="hljs-comment">%参考输入信号的FFT变换</span><br>Y2 = fft(test_actual4,N_FFT);<span class="hljs-comment">%实际输出信号的FFT变换</span><br>Y = Y2./Y1;<span class="hljs-comment">%计算输出和输入的比值</span><br>F_fft = ((<span class="hljs-number">0</span>:<span class="hljs-number">1</span>/N_FFT:<span class="hljs-number">1</span><span class="hljs-number">-1</span>/N_FFT)*Fs).&#x27;; <span class="hljs-comment">%得到变换后的频率</span><br>N_plot = <span class="hljs-built_in">length</span>(F_fft)/<span class="hljs-number">2</span>; <span class="hljs-comment">%由对称性，频率选一半即可</span><br><br><span class="hljs-comment">%%单片机实测的数据</span><br>w=<span class="hljs-built_in">logspace</span>(<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">500</span>);<span class="hljs-comment">%产生对数变化的频率点</span><br>mag=[<span class="hljs-number">2025</span>,<span class="hljs-number">2027</span>,<span class="hljs-number">2029</span>,<span class="hljs-number">2023</span>,<span class="hljs-number">2034</span>,<span class="hljs-number">2046</span>,<span class="hljs-number">2059</span>,<span class="hljs-number">2044</span>,<span class="hljs-number">2054</span>,<span class="hljs-number">2044</span>,<span class="hljs-number">2065</span>,<span class="hljs-number">2044</span>,<span class="hljs-number">2084</span>,<span class="hljs-number">2077</span>,<span class="hljs-number">2080</span>,<span class="hljs-number">2268</span>,<span class="hljs-number">2096</span>,<span class="hljs-number">2126</span>,<span class="hljs-number">2274</span>,<span class="hljs-number">2132</span>,<span class="hljs-number">2211</span>,<span class="hljs-number">2134</span>,<span class="hljs-number">2178</span>,<span class="hljs-number">2130</span>,<span class="hljs-number">2144</span>,<span class="hljs-number">2088</span>,<span class="hljs-number">2163</span>,<span class="hljs-number">2161</span>,<span class="hljs-number">2228</span>,<span class="hljs-number">2295</span>,<span class="hljs-number">2385</span>,<span class="hljs-number">2230</span>,<span class="hljs-number">2299</span>,<span class="hljs-number">2333</span>,<span class="hljs-number">2082</span>,<span class="hljs-number">2222</span>,<span class="hljs-number">2153</span>,<span class="hljs-number">2270</span>,<span class="hljs-number">1927</span>,<span class="hljs-number">1866</span>,<span class="hljs-number">2054</span>,<span class="hljs-number">2049</span>,<span class="hljs-number">1715</span>,<span class="hljs-number">2042</span>,<span class="hljs-number">1435</span>,<span class="hljs-number">1418</span>,<span class="hljs-number">1554</span>,<span class="hljs-number">1203</span>,<span class="hljs-number">1232</span>,<span class="hljs-number">1263</span>,<span class="hljs-number">950</span>,<span class="hljs-number">1098</span>,<span class="hljs-number">954</span>,<span class="hljs-number">807</span>,<span class="hljs-number">770</span>,<span class="hljs-number">619</span>,<span class="hljs-number">299</span>,<span class="hljs-number">246</span>,<span class="hljs-number">269</span>,<span class="hljs-number">174</span>,<span class="hljs-number">144</span>,<span class="hljs-number">54</span>,<span class="hljs-number">50</span>,<span class="hljs-number">66</span>];<span class="hljs-comment">%单片机实测的幅值</span><br>mag = mag/<span class="hljs-number">2000</span>;<span class="hljs-comment">%实际输出幅值/参考输入幅值</span><br>mag=<span class="hljs-number">20</span>*<span class="hljs-built_in">log10</span>(mag);<span class="hljs-comment">%转化为dB</span><br>p = [<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">12</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-number">18</span>,<span class="hljs-number">20</span>,<span class="hljs-number">21</span>,<span class="hljs-number">23</span>,<span class="hljs-number">22</span>,<span class="hljs-number">22</span>,<span class="hljs-number">24</span>,<span class="hljs-number">25</span>,<span class="hljs-number">26</span>,<span class="hljs-number">28</span>,<span class="hljs-number">30</span>,<span class="hljs-number">32</span>,<span class="hljs-number">34</span>,<span class="hljs-number">36</span>,<span class="hljs-number">38</span>,<span class="hljs-number">40</span>,<span class="hljs-number">42</span>,<span class="hljs-number">44</span>,<span class="hljs-number">44</span>,<span class="hljs-number">51</span>,<span class="hljs-number">53</span>,<span class="hljs-number">54</span>,<span class="hljs-number">58</span>,<span class="hljs-number">62</span>,<span class="hljs-number">66</span>,<span class="hljs-number">68</span>,<span class="hljs-number">70</span>,<span class="hljs-number">64</span>,<span class="hljs-number">73</span>,<span class="hljs-number">82</span>,<span class="hljs-number">80</span>,<span class="hljs-number">80</span>,<span class="hljs-number">111</span>,<span class="hljs-number">104</span>,<span class="hljs-number">120</span>,<span class="hljs-number">120</span>,<span class="hljs-number">116</span>];<span class="hljs-comment">%单片机实测的相位</span><br><br><span class="hljs-comment">%%系统辨识得到的数据</span><br>sys_cl = tf(tf7)<span class="hljs-comment">%此处为实际辨识出的系统闭环传递函数</span><br>[mag_si,phase,w]= bode(sys_cl,w);<br>m_si=<span class="hljs-built_in">zeros</span>(<span class="hljs-built_in">length</span>(w));<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(w)<br>  m_si(<span class="hljs-built_in">i</span>) = <span class="hljs-number">20</span>*<span class="hljs-built_in">log10</span>(mag_si(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-built_in">i</span>));<br>  p_si(<span class="hljs-built_in">i</span>) = phase(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-built_in">i</span>);<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">%%绘图</span><br><span class="hljs-built_in">figure</span>(<span class="hljs-number">1</span>)<br>subplot(<span class="hljs-number">211</span>)<span class="hljs-comment">%幅度</span><br>semilogx(F_fft(<span class="hljs-number">1</span>:N_plot)*<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>,<span class="hljs-number">20</span>*<span class="hljs-built_in">log10</span>(<span class="hljs-built_in">abs</span>(Y(<span class="hljs-number">1</span>:N_plot))),<span class="hljs-string">&#x27;c&#x27;</span>)<span class="hljs-comment">%FFT</span><br><span class="hljs-built_in">hold</span> on<br>semilogx(<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*F,mag,<span class="hljs-string">&#x27;b&#x27;</span>);<span class="hljs-comment">%单片机实测</span><br><span class="hljs-built_in">hold</span> on<br>semilogx(w,m_si(:,<span class="hljs-number">1</span>),<span class="hljs-string">&#x27;r&#x27;</span>);<span class="hljs-comment">%系统辨识</span><br>ylabel(<span class="hljs-string">&quot;幅度dB&quot;</span>)<br>subplot(<span class="hljs-number">212</span>)<span class="hljs-comment">%相位</span><br>semilogx(F_fft(<span class="hljs-number">1</span>:N_plot)*<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>,<span class="hljs-built_in">angle</span>(Y(<span class="hljs-number">1</span>:N_plot))*<span class="hljs-number">57.3</span>,<span class="hljs-string">&#x27;c&#x27;</span>);<span class="hljs-comment">%FFT</span><br><span class="hljs-built_in">hold</span> on<br>semilogx(<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*F(<span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(p)),-p,<span class="hljs-string">&#x27;b&#x27;</span>);<span class="hljs-comment">%单片机实测</span><br><span class="hljs-built_in">hold</span> on<br>semilogx(w,p_si,<span class="hljs-string">&#x27;r&#x27;</span>);<span class="hljs-comment">%系统辨识</span><br>ylabel(<span class="hljs-string">&quot;相位°&quot;</span>)<br>xlabel(<span class="hljs-string">&quot;频率rad/s&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="3利用电机辨识结果设计控制器"><a href="#3利用电机辨识结果设计控制器" class="headerlink" title="3利用电机辨识结果设计控制器"></a>3利用电机辨识结果设计控制器</h2><h3 id="3-1-辨识效果"><a href="#3-1-辨识效果" class="headerlink" title="3.1 辨识效果"></a>3.1 辨识效果</h3><p>针对系统框图：</p><p><img src="/img/SystemIdentification/1.png" style="zoom: 67%;" /></p><p>我们一共有三种辨识方法：</p><ul><li>闭环辨识，即根据<script type="math/tex">r(t)</script>和<script type="math/tex">y(t)</script>辨识闭环传递函数<script type="math/tex">\Phi(s)</script>，核心是<script type="math/tex">r(t)</script>为不同频率的正弦信号</li><li>直接开环辨识，即根据<script type="math/tex">e(t)</script>和<script type="math/tex">y(t)</script>辨识开环传递函数<script type="math/tex">C(s)G(s)</script>，核心是<script type="math/tex">e(t)</script>为不同频率的正弦信号</li><li>电机辨识，即根据<script type="math/tex">u(t)</script>和<script type="math/tex">y(t)</script>辨识电机传递函数<script type="math/tex">G(s)</script>，核心是<script type="math/tex">u(t)</script>为不同频率的正弦信号</li></ul><p>其中，闭环传递函数和开环传递函数有如下关系：   $$\Phi(s)=\frac{C(s)G(s)}{1+C(s)G(s)}$$      $$C(s)G(s)=\frac{\Phi(s)}{1-\Phi(s)}$$   </p><p>分别采用以上三种辨识方法，我们可以得到如下结果：</p><p>采用闭环辨识，得到闭环传递函数为：   $$\Phi(s)=\frac{62.64s+566.2}{s^2+64.69s+621.8}$$   </p><p>采用直接开环辨识，得到开环传递函数和控制器传递函数为：   $$C(s)G(s)=\frac{53.69s^2+874.2s+1527}{s^3+17.6s^2+137.8s+4.287\times10^{-6}}$$       $$C(s)=\frac{9.341s+4.539}{s+0.008438}$$   </p><p>采用电机辨识，得到电机传递函数为：   $$G(s)=\frac{8.07s+1.722}{s^2+0.6468s+0.08032}$$   </p><p>三种方式都可以得到闭环传递函数和开环传递函数，理论上，三种方式得到的结果应当接近：</p><p>实际三种方式得到的闭环和开环传递函数的伯德图如下：</p><p>闭环传递函数：</p><p><img src="/img/SystemIdentification/bode_syscl_compare.svg" alt=""></p><p>开环传递函数：</p><p><img src="/img/SystemIdentification/bode_syso_compare.svg" alt=""></p><p>可以看到，不同方法得到的开环和闭环传递函数的伯德图基本一致，验证了理论的正确性。</p><h3 id="3-2-PID控制器仿真设计"><a href="#3-2-PID控制器仿真设计" class="headerlink" title="3.2 PID控制器仿真设计"></a>3.2 PID控制器仿真设计</h3><p>PID控制器的设计可以采用matlab工具箱中的sisotool工具，将开环传递函数导入之后，利用PID tuning工具来设计并仿真不同的PID参数，根据时域阶跃响应情况和开环伯德图提供的相位裕度等信息，调整对于响应速度和鲁棒性的需求，即可得到合适的PID参数。实际测试结果和仿真结果基本一致，认为辨识结果可信。</p><p>注意：连续时间的<script type="math/tex">K_I^c</script>和离散时间的<script type="math/tex">K_I^d</script>需要进行如下换算：<script type="math/tex">K^d_I=K_I^c \times T_s</script></p><p>例如，仿真时得到理想的<script type="math/tex">K_I^c</script>是10，控制周期<script type="math/tex">T_s</script>为0.002s，则单片机实现时的<script type="math/tex">K_I^d</script>为10×0.002 = 0.02。</p><p>注意：以下仿真选用的开环传递函数为直接电机辨识而来，即根据<script type="math/tex">u(t)</script>和<script type="math/tex">y(t)</script>直接辨识电机传递函数<script type="math/tex">G(s)</script>。</p><p>PID仿真设计工具如下图：</p><p><img src="/img/SystemIdentification/sisotool.png" alt="sisotool"></p><p>不同PID参数的仿真结果和实测结果如下：</p><p><img src="/img/SystemIdentification/step_syscl_compare.svg" alt=""></p><p>从上图中可以看出，仿真的闭环系统阶跃响应和实测的闭环系统阶跃响应，无论在超调量还是调节时间上都相当接近，这也证明了系统辨识结果的正确性，也说明了利用仿真设计控制器的实际可行性。</p><h2 id="4-云台系统辨识效果"><a href="#4-云台系统辨识效果" class="headerlink" title="4 云台系统辨识效果"></a>4 云台系统辨识效果</h2><h2 id="5-参考文献："><a href="#5-参考文献：" class="headerlink" title="5 参考文献："></a>5 参考文献：</h2><p>[1]<a href="https://bbs.robomaster.com/forum.php?mod=viewthread&amp;tid=4941&amp;extra=&amp;page=1（主要参考的官方教程，本文中省略的细节都可以在该教程中找到）">https://bbs.robomaster.com/forum.php?mod=viewthread&amp;tid=4941&amp;extra=&amp;page=1（主要参考的官方教程，本文中省略的细节都可以在该教程中找到）</a></p><p>[2]<a href="https://blog.csdn.net/CCCDeric/article/details/112075279">https://blog.csdn.net/CCCDeric/article/details/112075279</a> （正弦信号的产生给了我很多灵感）</p><p>[3]<a href="https://blog.csdn.net/nicholas_duan/article/details/103251126">https://blog.csdn.net/nicholas_duan/article/details/103251126</a> （Keil中将数据导出的方法）</p><p>[4]<a href="https://ww2.mathworks.cn/help/signal/ug/practical-introduction-to-frequency-domain-analysis.html（利用FFT得到频率响应）">https://ww2.mathworks.cn/help/signal/ug/practical-introduction-to-frequency-domain-analysis.html（利用FFT得到频率响应）</a></p><p>[5]<a href="https://bbs.robomaster.com/thread-5059-1-1.html">https://bbs.robomaster.com/thread-5059-1-1.html</a> （官方利用matlab设计控制器的教程）</p>]]></content>
    
    
    
    <tags>
      
      <tag>System Identification</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LQR最优控制在电机控制方面的实际应用</title>
    <link href="/2021/12/01/%E5%85%A8%E7%8A%B6%E6%80%81%E5%8F%8D%E9%A6%88%E6%8E%A7%E5%88%B6%E7%8E%87LQR%E5%9C%A8%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E6%96%B9%E9%9D%A2%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/"/>
    <url>/2021/12/01/%E5%85%A8%E7%8A%B6%E6%80%81%E5%8F%8D%E9%A6%88%E6%8E%A7%E5%88%B6%E7%8E%87LQR%E5%9C%A8%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E6%96%B9%E9%9D%A2%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-基本思想"><a href="#1-基本思想" class="headerlink" title="1 基本思想"></a>1 基本思想</h2><h3 id="1-1-系统框图"><a href="#1-1-系统框图" class="headerlink" title="1.1 系统框图"></a>1.1 系统框图</h3><p><img src="/img/LQR_3508/statefeedback_pend2.png" alt="statefeedback_pend2"></p><p>上图中，<script type="math/tex">r</script>是参考输入，<script type="math/tex">u</script>是系统输入，<script type="math/tex">\boldsymbol{x}</script>是状态变量组成的向量，<script type="math/tex">y</script>为系统输出。</p><p>对应到电机位置控制中，<script type="math/tex">r</script>参考输入，代表的是电机的期望位置，即我们希望电机到达的位置。<script type="math/tex">u</script>为系统输入，即电机的电流或电压，通过系统输入我们驱动电机的运动。<script type="math/tex">\boldsymbol{x}</script>状态变量，我们选择电机角度位置和电机角速度作为两个状态变量。<script type="math/tex">y</script>系统输出，可以将电机的实际位置作为系统输出。</p><h3 id="1-2-系统方程"><a href="#1-2-系统方程" class="headerlink" title="1.2 系统方程"></a>1.2 系统方程</h3><p>对于一个一般的系统，我们通常用两组方程来描述：</p><ul><li>状态微分方程：       $$\dot{\boldsymbol{x}}=\boldsymbol{Ax+Bu}$$  </li></ul><ul><li>输出方程：              $$\boldsymbol{y=Cx+Du}$$</li></ul><p>在设计全状态反馈控制律时，我们利用全部的状态变量并结合参考输入来得到系统输入，</p><p>即系统输入由下式构成：                              $$u=\boldsymbol{-Kx}+Nr$$</p><p>在具体的电机位置控制问题中，状态变量<script type="math/tex">\boldsymbol{x}</script>由位置和速度一同构成，参考输入<script type="math/tex">r</script>即为我们期望电机到达的位置，系统输入<script type="math/tex">u</script>是电机电压或电流。与PID不同，PID先通过位置的误差计算出期望的速度，在通过速度的误差计算出期望的电流。而基于状态空间的全状态反馈控制设计则直接由期望位置、实际位置和实际速度一同确定电机的期望电流值，注意电机的期望速度是0，这是由问题的调节器本质决定的(即系统只能让一个状态变量跟踪一个参考输入信号，其余状态变量趋于0)。</p><p>问题的关键在于确定上式中的反馈增益<script type="math/tex">\boldsymbol{K}</script>，有很多种方法，比如说先确定闭环系统的特征根进而确定增益，再比如说根据经验和时域相应调节，最后也可以利用LQR设计最优控制系统得到<script type="math/tex">\boldsymbol{K}</script>。得到增益<script type="math/tex">\boldsymbol{K}</script>之后，参考输入前的系数<script type="math/tex">N</script>可以很方便的确定。整个系统的设计就完成了。</p><p>关于LQR(Linear Quadratic Regulatory，线性二次调节器)，说明如下：</p><p>针对未校正的单输入-单输出系统：                       $$\dot{\boldsymbol{x}}=\boldsymbol{Ax+B}u$$</p><p>状态反馈控制信号为：                          $$u=-\boldsymbol{Kx}=-\begin{pmatrix}k_1 & k_2 & ... &k_n\end{pmatrix}\boldsymbol{x}$$</p><p>定义综合性能指标为：                               $$J=\int_{0}^{\infty } (\boldsymbol{x^TQx}+Ru^2)dt$$</p><p>LQR通过确定合适的反馈增益<script type="math/tex">\boldsymbol{K}</script>，使得上面定义的综合性能指标最小。通过综合考虑状态变量的误差以及系统的输入消耗，设计出最优的控制系统。</p><h3 id="1-3-电机位置控制方程"><a href="#1-3-电机位置控制方程" class="headerlink" title="1.3 电机位置控制方程"></a>1.3 电机位置控制方程</h3><p>具体到电机位置控制的问题，我们选择电机位置<script type="math/tex">\theta</script>和电机角速度<script type="math/tex">\dot{\theta}</script>作为状态变量，电机电流<script type="math/tex">i</script>(大疆3508电机)或者电机电压<script type="math/tex">u</script>(大疆6020电机)作为系统输入，期望电机位置为参考输入<script type="math/tex">r</script>。</p><p>由动力学方程：                                          $$J\ddot{\theta}(t)+b\dot{\theta}(t)=k_mi(t)$$</p><p>上式中<script type="math/tex">J</script>为系统的转动惯量，<script type="math/tex">b</script>为系统的摩擦阻尼系数，<script type="math/tex">k_m</script>为电机的转矩常数。</p><p>可得系统的状态微分方程为：</p><p>​                                                        $$\begin{pmatrix}\dot{\theta} \\ \ddot{\theta} \end{pmatrix}=\begin{pmatrix}0&1 \\ 0&-b/J \end{pmatrix}\begin{pmatrix}\theta \\ \dot{\theta} \end{pmatrix}+\begin{pmatrix}0 \\ k_m/J \end{pmatrix} i$$</p><p>即：                                                        $$A=\begin{pmatrix}0&1 \\ 0&-b/J \end{pmatrix}$$ </p><p>以及：$$B=\begin{pmatrix}0 \\ k_m/J \end{pmatrix}$$</p><p>若采用LQR设计全状态反馈控制，则综合性能指标为：$$J=\int_{0}^{\infty } \{\quad \boldsymbol{\begin{pmatrix}\dot{\theta} & \ddot{\theta} \end{pmatrix}\begin{pmatrix}Q_1 &0 \\ 0 & Q_2 \end{pmatrix}\begin{pmatrix}\dot{\theta} \\ \ddot{\theta} \end{pmatrix}}+R\times i^2\quad \}dt$$</p><p>可以看出，<script type="math/tex">Q_1</script>的大小代表了位置误差所占的权重，<script type="math/tex">Q_2</script>的大小代表了速度误差所占的权重，<script type="math/tex">R</script>的大小代表了输入消耗的能量所占的权重。</p><p>可以预料到，<script type="math/tex">Q_1</script>越大，位置误差在性能函数中所占的权重越大，反馈矩阵<script type="math/tex">\boldsymbol{K}</script>中的<script type="math/tex">k_1</script>也应该越大，表示了位置误差对于输出电流的影响越大，系统更加倾向于减小最终的位置误差。同理，<script type="math/tex">Q_2</script>越大，速度误差在性能函数中所占的权重越大，反馈矩阵<script type="math/tex">\boldsymbol{K}</script>中的<script type="math/tex">k_2</script>也应该越大，表示了速度误差对于输出电流的影响越大，系统更加倾向于快速使最终的速度收敛到0，即减少系统的震荡。</p><p>我们可以从<strong>直观上</strong>理解一下为什么全状态反馈控制能够工作：</p><p>控制方程可以写作：<script type="math/tex">u=-\boldsymbol{Kx}+Nr</script>，本问题中<script type="math/tex">N=k_1</script>，即控制方程可以化为：</p><p>​                                   $$u=-k_1\times \theta-k_2\times \dot{\theta}+k_1\times\theta_{set} =k_1\times(\theta_{set}-\theta)+k_2\times \dot{\theta}=i$$</p><p>即：                                                    $$i=k_1\times(\theta_{set}-\theta)+k_2\times \dot{\theta}$$</p><p>当角度没有到达预定角度时，上式中的第一项不为0，电流较大，驱动电机到达预定位置，当电机到达预定位置附近时，第一项较小，但电机较快的速度导致第二项较大，产生电流使得电机减速，从而在预定位置处速度为0，电机稳定的到达预定位置。直观上看，<script type="math/tex">k_1</script>越大，电机会较快的到达预定位置，但可能伴随着较大的超调和震荡，此时可以增加<script type="math/tex">k_2</script>的值，使得速度迅速衰减为0，到达抑制震荡的效果。</p><h3 id="1-4-基础代码"><a href="#1-4-基础代码" class="headerlink" title="1.4 基础代码"></a>1.4 基础代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//LQR计算 </span><br> Motor.LQR.out = Motor.LQR.K_total*(<br>                -Motor.LQR.K_location*Motor.Location.Location<br>                -Motor.LQR.K_speed*Motor.Speed.Speed<br>    +Motor.LQR.K_location*Motor.Location.SetLocation);<br>     <span class="hljs-keyword">if</span>(Motor.LQR.out &gt; <span class="hljs-number">1</span>) Motor.LQR.out = <span class="hljs-number">1</span>;<br>     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(Motor.LQR.out &lt; <span class="hljs-number">-1</span>) Motor.LQR.out = <span class="hljs-number">-1</span>; <br> Can1SendMessege[<span class="hljs-number">0</span>]=((<span class="hljs-keyword">int16_t</span>)(Motor.LQR.out*<span class="hljs-number">16000</span>))&gt;&gt;<span class="hljs-number">8</span>;<br> Can1SendMessege[<span class="hljs-number">1</span>]=((<span class="hljs-keyword">int16_t</span>)(Motor.LQR.out*<span class="hljs-number">16000</span>))&amp;<span class="hljs-number">0x00ff</span>; <br> CAN1_Send_Msg(Can1SendMessege,<span class="hljs-number">8</span>);<br></code></pre></td></tr></table></figure><p>思想很简单，就是上面公式<script type="math/tex">i=k_1\times(\theta_{set}-\theta)+k_2\times \dot{\theta}</script>的直接应用。实践中，可以通过<script type="math/tex">K_{location}</script>和<script type="math/tex">K_{speed}</script>调节位置误差和速度误差所占比例的权重，再通过调节<script type="math/tex">K_{total}</script>使得响应速度和稳态误差达到一个满意的水平。不知为何，matlab中利用LQR进行计算只能得到一个较为满意的<script type="math/tex">K_{location}</script>和<script type="math/tex">K_{speed}</script>的比值，最后还需要调节<script type="math/tex">K_{total}</script>才能让系统最终工作。如果直接手动整定参数，可以不用管<script type="math/tex">K_{total}</script>，直接调节<script type="math/tex">K_{location}</script>和<script type="math/tex">K_{speed}</script>即可(数据归一化会使调节变得方便)。</p><h2 id="2-仿真效果"><a href="#2-仿真效果" class="headerlink" title="2 仿真效果"></a>2 仿真效果</h2><h3 id="2-1-仿真代码"><a href="#2-1-仿真代码" class="headerlink" title="2.1 仿真代码"></a>2.1 仿真代码</h3><p>matlab仿真代码如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%%构建系统状态空间方程</span><br>A=[<span class="hljs-number">0</span> <span class="hljs-number">1</span>;<span class="hljs-number">0</span> <span class="hljs-number">-0.0013</span>];<br>B=[<span class="hljs-number">0</span>;<span class="hljs-number">13.5</span>];<br><span class="hljs-comment">%此处按照y=r构建，r即参考输入为位置</span><br>C=[<span class="hljs-number">1</span> <span class="hljs-number">0</span>];<br>D=[<span class="hljs-number">0</span>];<br>sys_ss = ss(A,B,C,D);<br><span class="hljs-comment">%%计算LQR得到的反馈矩阵K</span><br>Q=[<span class="hljs-number">10</span> <span class="hljs-number">0</span>;<span class="hljs-number">0</span> <span class="hljs-number">1</span>];<br>R=<span class="hljs-number">1</span>;<br>K=lqr(A,B,Q,R)<br><span class="hljs-comment">%%计算跟踪参考输入所需要的系数</span><br>T=[A B;C D];<br>T_inv = inv(T);<br>N=T_inv*[<span class="hljs-number">0</span>;<span class="hljs-number">0</span>;<span class="hljs-number">1</span>];<br>Nbar=K*[<span class="hljs-number">1</span>;<span class="hljs-number">0</span>];<br><span class="hljs-comment">%%仿真闭环系统的阶跃响应</span><br>Ac = [(A-B*K)];<br>Bc = [B];<br>Cc = [C];<br>Dc = [D];<br>sys_cl = ss(Ac,Bc*Nbar,Cc,Dc);<br>step(sys_cl)<br></code></pre></td></tr></table></figure><p>这个状态空间方程不一定完全准确，但和实际值应该差不多。通过对于不同<script type="math/tex">Q</script>和<script type="math/tex">R</script>的值的仿真，我们可以得到一些经验，并看到<script type="math/tex">Q</script>和<script type="math/tex">R</script>的值对于系统时域阶跃响应的影响非常直观且符合直觉。</p><h3 id="2-2-Q的值对于K和阶跃响应的影响"><a href="#2-2-Q的值对于K和阶跃响应的影响" class="headerlink" title="2.2 Q的值对于K和阶跃响应的影响"></a>2.2 <script type="math/tex">Q</script>的值对于<script type="math/tex">K</script>和阶跃响应的影响</h3><h4 id="2-2-1-Q-1的影响"><a href="#2-2-1-Q-1的影响" class="headerlink" title="2.2.1 Q_1的影响"></a>2.2.1 <script type="math/tex">Q_1</script>的影响</h4><p>不同<script type="math/tex">Q_1</script>对应的<script type="math/tex">K_1</script>和<script type="math/tex">K_2</script>：</p><p><img src="/img/LQR_3508/Q1-K.svg" alt=""></p><p>不同<script type="math/tex">Q_1</script>对应的阶跃响应：</p><p><img src="/img/LQR_3508/Q1-step.svg" alt=""></p><p>可以看到，随着<script type="math/tex">Q_1</script>的不断增大，位置误差在性能函数中的占比也不断增大，导致位置误差在最终的系统输入中占比也越来越大，直接结果就是<script type="math/tex">K_1</script>随着<script type="math/tex">Q_1</script>的增大明显增大，而<script type="math/tex">K_2</script>仅仅是微微增大。同样的，随着<script type="math/tex">Q_1</script>的增大，位置误差更倾向于快速减小，表现在系统的阶跃响应上就是系统的上升时间明显减小。</p><h4 id="2-2-2-Q-2的影响"><a href="#2-2-2-Q-2的影响" class="headerlink" title="2.2.2 Q_2的影响"></a>2.2.2 <script type="math/tex">Q_2</script>的影响</h4><p>不同<script type="math/tex">Q_2</script>对应的<script type="math/tex">K_1</script>和<script type="math/tex">K_2</script>：</p><p><img src="/img/LQR_3508/Q2-K.svg" alt=""></p><p>不同<script type="math/tex">Q_2</script>对应的阶跃响应：</p><p><img src="/img/LQR_3508/Q2-step.svg" alt=""></p><p>可以看到，随着<script type="math/tex">Q_2</script>的不断增大，速度误差在性能函数中的占比也不断增大，导致速度误差在最终的系统输入中占比也越来越大，直接结果就是<script type="math/tex">K_2</script>随着<script type="math/tex">Q_2</script>的增大明显增大，而<script type="math/tex">K_1</script>的大小则变化不大。同样的，随着<script type="math/tex">Q_2</script>的增大，速度误差更倾向于快速的缩小，电机更倾向于以更小的速度运行，导致系统阶跃响应变慢，但好处就是系统阶跃响应的超调得到了抑制。</p><h3 id="2-3-R的值对于K和阶跃响应的影响"><a href="#2-3-R的值对于K和阶跃响应的影响" class="headerlink" title="2.3 R的值对于K和阶跃响应的影响"></a>2.3 <script type="math/tex">R</script>的值对于<script type="math/tex">K</script>和阶跃响应的影响</h3><p>不同<script type="math/tex">R</script>对应的<script type="math/tex">K_1</script>和<script type="math/tex">K_2</script>：</p><p><img src="/img/LQR_3508/R-K.svg" alt=""></p><p>不同<script type="math/tex">R</script>对应的阶跃响应：</p><p><img src="/img/LQR_3508/R-step.svg" alt=""></p><p>可以看到，随着<script type="math/tex">R</script>的不断增大，系统倾向于以耗能更小的方式运行，则<script type="math/tex">K_1</script>和<script type="math/tex">K_2</script>都随着<script type="math/tex">R</script>的增大而减小，且系统的阶跃响应随着<script type="math/tex">R</script>的增大而变慢，系统的耗能减少。</p><h2 id="3-电机实际测试结果"><a href="#3-电机实际测试结果" class="headerlink" title="3 电机实际测试结果"></a>3 电机实际测试结果</h2><p>单电机测试选用大疆3508电机进行测试。<strong>本小节所有数据皆为实测</strong>。</p><h3 id="3-1-基于经验和时域波形的调参"><a href="#3-1-基于经验和时域波形的调参" class="headerlink" title="3.1 基于经验和时域波形的调参"></a>3.1 基于经验和时域波形的调参</h3><p>严格来说，本小节中的内容并不能叫LQR控制，因为反馈增益矩阵是<script type="math/tex">K</script>根据经验和时域响应确定的，并不一定是根据模型得到的最优控制的解。本小节的内容叫手动调参的全状态反馈控制率设计更为合适。但在下文中，为了方便，大部分时间仍把这种方法叫做LQR。</p><h4 id="3-1-1-k-1-K-location-大小对于最终效果的影响"><a href="#3-1-1-k-1-K-location-大小对于最终效果的影响" class="headerlink" title="3.1.1 k_1(K_{location})大小对于最终效果的影响"></a>3.1.1 <script type="math/tex">k_1</script>(<script type="math/tex">K_{location}</script>)大小对于最终效果的影响</h4><p>在本小节中，我们固定<script type="math/tex">k_2</script>不变，仅改变<script type="math/tex">k_1</script>的值，测量电机的阶跃响应。所有位置数据和速度数据均已进行过归一化。在J-scope中读出实际位置和实际速度的数据，在matlab中绘制图像。<strong>本小节所有数据皆为实测</strong>。</p><p>不同参数下电机的阶跃响应如下图所示，左侧为位置随时间变化的曲线，右侧为速度随时间变化的曲线。</p><p>1、<script type="math/tex">k_1=0.5   \qquad  k_2=10</script>   ：</p><p><img src="/img/LQR_3508/k1_0.5,k2_10.svg" alt=""></p><p>2、<script type="math/tex">k_1=1   \qquad  k_2=10</script>   ：</p><p><img src="/img/LQR_3508/k1_1,k2_10.svg" alt="k1_1,k2_10"></p><p>3、<script type="math/tex">k_1=2   \qquad  k_2=10</script>   ：</p><p><img src="/img/LQR_3508/k1_2,k2_10.svg" alt="k1_2,k2_10"></p><p>4、<script type="math/tex">k_1=3   \qquad  k_2=10</script>   ：</p><p><img src="/img/LQR_3508/k1_3,k2_10.svg" alt="k1_3,k2_10"></p><p>从上面四张图中可以看出，<script type="math/tex">k_1</script>较小时，位置误差不是那么重要，电机位置误差在系统输入中占比较小，同时因为速度误差占比较大，电机倾向于以较慢的速度进行相应，电机位置的阶跃响应较慢。随着<script type="math/tex">k_1</script>的增大，电机位置误差所占权重越来越大。电机阶跃响应速度明显变快，同时可以注意到电机速度的最大值不断增加。</p><p>所以，在参数整定的过程中，如果系统的阶跃响应较慢，上升时间较长，可以考虑增大<script type="math/tex">k_1</script>来加快响应。</p><h4 id="3-1-2-k-2-K-speed-大小对于最终效果的影响"><a href="#3-1-2-k-2-K-speed-大小对于最终效果的影响" class="headerlink" title="3.1.2 k_{2}(K_{speed})大小对于最终效果的影响"></a>3.1.2 <script type="math/tex">k_{2}</script>(<script type="math/tex">K_{speed}</script>)大小对于最终效果的影响</h4><p>在本小节中，我们固定<script type="math/tex">k_1</script>不变，仅改变<script type="math/tex">k_2</script>的值，测量电机的阶跃响应。所有位置数据和速度数据均已进行过归一化。在J-scope中读出实际位置和实际速度的数据，在matlab中绘制图像。本小节所有数据皆为实测。</p><p>不同参数下电机的阶跃响应如下图所示，左侧为位置随时间变化的曲线，右侧为速度随时间变化的曲线。</p><p>1、<script type="math/tex">k_1=2.5   \qquad  k_2=2.5</script>   ：</p><p><img src="/img/LQR_3508/k1_2.5,k2_2.5.svg" alt=""></p><p>2、<script type="math/tex">k_1=2.5   \qquad  k_2=5</script>    ：                                                  </p><p><img src="/img/LQR_3508/k1_2.5,k2_5.svg" alt=""> </p><p>3、<script type="math/tex">k_1=2.5   \qquad  k_2=7.5</script>   ：                                                                             </p><p><img src="/img/LQR_3508/k1_2.5,k2_7.5.svg" alt="K12.5K27.5"></p><p>4、<script type="math/tex">k_1=2.5   \qquad  k_2=10</script>   :                                      </p><p><img src="/img/LQR_3508/k1_2.5,k2_10.svg" alt=""></p><p>从上面四张图中可以看出，固定<script type="math/tex">k_1</script>不变时，一开始<script type="math/tex">k_2</script>较小，说明速度误差不是那么重要，在系统输出中速度误差项占比较小，所以电机速度收敛为0的速度较慢 ，系统阶跃响应出现了很大的超调和震荡。随着<script type="math/tex">k_2</script>的增大，速度误差的占比逐渐增大，电机阶跃响应的超调减小，收敛速度变快且震荡逐渐消失，到了最后电机完全没有超调和震荡，且响应速度没有收到明显影响。                                                    </p><p>所以，在参数整定的过程中，如果阶跃响应出现了超调和震荡，可以考虑增大<script type="math/tex">k_2</script>来予以消除。</p><h4 id="3-1-3-简单经验总结"><a href="#3-1-3-简单经验总结" class="headerlink" title="3.1.3 简单经验总结"></a>3.1.3 简单经验总结</h4><ul><li>如果系统的阶跃响应较慢，上升时间较长，可以考虑增大<script type="math/tex">k_1</script>来加快响应。</li></ul><ul><li>如果阶跃响应出现了超调和震荡，可以考虑增大<script type="math/tex">k_2</script>来予以消除。</li></ul><h4 id="3-1-4-LQR和PID效果比较-时域参数整定"><a href="#3-1-4-LQR和PID效果比较-时域参数整定" class="headerlink" title="3.1.4 LQR和PID效果比较(时域参数整定)"></a>3.1.4 LQR和PID效果比较(时域参数整定)</h4><p>在比较中，我先在阶跃响应幅度为8的时候，将PID和LQR的时域响应都调到了最优(在没有超调的时候上升时间最短)，相应的参数为：</p><p>​                           对于<script type="math/tex">LQR</script>：          $$K_{location}=3.8,K_{speed}=13.6,K_{total}=1$$</p><p>​                           对于<script type="math/tex">PID</script>：     $$速度环：K_p=12,K_i=0.01\quad 位置环：K_p=0.45$$</p><p>之后给予幅度为76的阶跃信号，分别测量两者阶跃响应曲线，进行比较：</p><p><img src="/img/LQR_3508/PIDvsLQR，sl76.svg" alt=""></p><p><img src="/img/LQR_3508/PID&amp;LQRin1.svg" alt=""></p><p>可以看到，采用LQR控制的电机响应速度比采用PID控制的电机响应速度要快一些，在J-scope中使用示波器光标实测LQR的上升时间要比PID的上升时间小200ms左右，其中LQR的上升时间约为500ms，PID的上升时间约为700ms。且LQR的超调量明显小于PID，电机拿在手中调试的过程中也感觉到LQR比PID要更加顺滑且明显LQR响应更快。</p><p>LQR不仅响应比PID快，调试参数时也更加简单方便。LQR中的<script type="math/tex">K_{location}</script>和<script type="math/tex">K_{speed}</script>意义明确，很容易和时域指标对应起来。比起双环PID，LQR同时采用速度和位置计算期望的电流值，省去了中间环节，更为直接迅速，控制的实时性更高。</p><h3 id="3-2-系统辨识得到系统参数，matlab进行LQR设计"><a href="#3-2-系统辨识得到系统参数，matlab进行LQR设计" class="headerlink" title="3.2 系统辨识得到系统参数，matlab进行LQR设计"></a>3.2 系统辨识得到系统参数，matlab进行LQR设计</h3><h4 id="3-2-1-系统辨识思路"><a href="#3-2-1-系统辨识思路" class="headerlink" title="3.2.1 系统辨识思路"></a>3.2.1 系统辨识思路</h4><h4 id="3-2-2-辨识结果"><a href="#3-2-2-辨识结果" class="headerlink" title="3.2.2 辨识结果"></a>3.2.2 辨识结果</h4><h4 id="3-3-3-仿真效果"><a href="#3-3-3-仿真效果" class="headerlink" title="3.3.3 仿真效果"></a>3.3.3 仿真效果</h4><h4 id="3-3-4-电机实测效果"><a href="#3-3-4-电机实测效果" class="headerlink" title="3.3.4 电机实测效果"></a>3.3.4 电机实测效果</h4><h2 id="5-参考文献："><a href="#5-参考文献：" class="headerlink" title="5 参考文献："></a>5 参考文献：</h2><p>[1] <a href="https://ctms.engin.umich.edu/CTMS/index.php?example=InvertedPendulum&amp;section=ControlStateSpace">https://ctms.engin.umich.edu/CTMS/index.php?example=InvertedPendulum&amp;section=ControlStateSpace</a>  (一篇关于倒立摆的状态空间设计的文章，本文许多仿真及思想借鉴于此)</p><p>[2]《现代控制系统 Modern Control System》Richard C.Dorf   (很多概念讲的很详细清楚)</p><p>[3]《自动控制原理与设计 Feedback Control of Dynamic System》Gene F.Franklin  (其中的许多思想非常好)</p><p>[4] <a href="https://bbs.robomaster.com/forum.php?mod=viewthread&amp;tid=4941">https://bbs.robomaster.com/forum.php?mod=viewthread&amp;tid=4941</a> (RM官方系统辨识教程，本文中主要系统辨识方法来源于此篇文章)</p>]]></content>
    
    
    
    <tags>
      
      <tag>Control</tag>
      
      <tag>Optimal Control</tag>
      
      <tag>Algorithum</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PnP(Perspective-n-Point)问题：各种算法总结分析</title>
    <link href="/2021/11/30/PnP(Perspective-n-Point)%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2021/11/30/PnP(Perspective-n-Point)%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="1-本文简介"><a href="#1-本文简介" class="headerlink" title="1 本文简介"></a>1 本文简介</h2><h3 id="1-1-写作动机"><a href="#1-1-写作动机" class="headerlink" title="1.1 写作动机"></a>1.1 写作动机</h3><p>笔者近日在学习计算机视觉与SLAM的过程中，因面临确定物体位姿的需求，详细的学习了PnP(Perspective-n-Point)问题及其主流的四种解决算法（DLT、P3P、EPnP、BA）。在查阅网络资料学习的过程中，遇到的不少文章基本上只对其中的个别算法进行了简单介绍，且没有严格的数学推导，问题的描述和符号也不是很严格清晰，给学习带来了较多障碍。故萌生了写此文的想法，用严格统一的符号和表述详细的介绍PnP问题的四种解决算法，也算是学习过程中的一个小小的笔记。</p><p>本文同时发布于知乎，欢迎前往阅读和点赞：<a href="https://zhuanlan.zhihu.com/p/399140251">https://zhuanlan.zhihu.com/p/399140251</a> 。</p><p><img src="/img/PNP_summary/pnp_setting.png" alt="pnp_setting"></p><h3 id="1-2-问题描述"><a href="#1-2-问题描述" class="headerlink" title="1.2 问题描述"></a>1.2 问题描述</h3><p>PnP(Perspective-n-Point)是求解3D到2D点对运动的方法，目的是求解相机坐标系相对世界坐标系的位姿。它描述了已知<script type="math/tex">n</script>个3D点的坐标(相对世界坐标系)以及这些点的像素坐标时，如何估计相机的位姿(即求解世界坐标系到相机坐标系的旋转矩阵<script type="math/tex">R</script>和平移向量<script type="math/tex">t</script>)。</p><p>用数学公式描述如下：</p><ul><li>基本公式： $$\omega \boldsymbol{p}=KP^C=K(R_{CW}\times P^W+t^C_{CW})$$ 其中:<ul><li><script type="math/tex">\boldsymbol{p}</script>为点在像素坐标系下的坐标</li><li><script type="math/tex">P^C</script>为点在相机坐标系下的坐标</li><li><script type="math/tex">P^W</script>为点在世界坐标系下的坐标</li><li><script type="math/tex">\omega</script>为点的深度</li><li><script type="math/tex">K</script>为相机的内参矩阵</li><li><script type="math/tex">R_{CW}</script>和<script type="math/tex">t^C_{CW}</script>为从世界坐标系到相机坐标系的位姿转换。</li></ul></li><li><strong>已知</strong>：<ul><li>所有<script type="math/tex">n</script>个点在<strong>世界坐标系</strong>下的坐标<script type="math/tex">P_1^W,P_2^W,...,P_n^W</script></li><li>这些点相应在<strong>像素坐标系</strong>下的坐标<script type="math/tex">\boldsymbol{p}_1,\boldsymbol{p}_2,...,\boldsymbol{p}_n</script></li><li>相机<strong>内参</strong>矩阵<script type="math/tex">K</script></li><li>注：由于是已知<script type="math/tex">n</script>个点的3D-2D对应关系，所以相应问题被称作PnP问题。</li></ul></li><li><strong>求解</strong>：<strong>相机坐标系相对于世界坐标系的位姿</strong>，即<script type="math/tex">P^C=R_{CW}\times P^W+\boldsymbol{t^C_{CW}}</script>中的<script type="math/tex">R_{CW}</script>和<script type="math/tex">\boldsymbol{t^C_{CW}}</script><ul><li><script type="math/tex">R_{CW}</script>是世界坐标系到相机坐标系的旋转矩阵，将同一个向量在世界坐标系下的表示转化为在相机坐标系下的表示</li><li><script type="math/tex">\boldsymbol{t^C_{CW}}</script>为相应的平移向量，从相机坐标系原点指向世界坐标系原点的向量，在相机坐标系下的表示。</li></ul></li><li>算法：直接线性变换(DLT)、P3P、EPnP、光束法平差(BA，Bundle Adjustment)。</li></ul><h3 id="1-3-符号介绍"><a href="#1-3-符号介绍" class="headerlink" title="1.3 符号介绍"></a>1.3 符号介绍</h3><p>本文中，一律用上标区别向量在不同坐标系下的表达：</p><ul><li><script type="math/tex">P^W=[X^W,Y^W,Z^W]^T</script>代表点在<strong>世界坐标系</strong>下的表示</li><li><script type="math/tex">P^C=[X^C,Y^C,Z^C]^T</script>代表点在<strong>相机坐标系</strong>下的表示</li><li><script type="math/tex">P^{'}=[X^C/Z^C,Y^C/Z^C,1]^T=[u_1,v_1,1]^T</script>代表点在<strong>相机归一化坐标系</strong>下的表示</li><li><script type="math/tex">\boldsymbol{p}=[u,v,1]^T</script>代表点在<strong>像素坐标系</strong>下的表示(投影到像素平面之后扩展为齐次坐标)</li></ul><p>上述坐标系间的转换关系如下：$$\omega \boldsymbol{p}=KP^C=K(R_{CW}\times P^W+t^C_{CW})$$</p><p>其中<script type="math/tex">\omega = Z^C</script>为点在相机坐标系下的深度。</p><p>展开：$$\omega \boldsymbol{p}=Z^C\begin{pmatrix}u\\v \\1\end{pmatrix} = \begin{pmatrix}f_x& s &c_x \\0&f_y  &c_y \\0 & 0 &1\end{pmatrix}\begin{pmatrix}X^C\\Y^C \\Z^C\end{pmatrix}=\begin{pmatrix}f_x& s &c_x \\0&f_y  &c_y \\0 & 0 &1\end{pmatrix}\begin{pmatrix}r_{11}& r_{12} & r_{13} & t_1\\r_{21}& r_{22} & r_{23} & t_2\\r_{31}& r_{32} &r_{33}  & t_3\end{pmatrix}\begin{pmatrix}X^W\\Y^W \\Z^W\\1\end{pmatrix}=K[R|t] P^W$$</p><p>PnP就是在已知$n$个点的像素坐标$p_i$及其世界坐标系下的坐标$P^W_i$和相机的内参矩阵$K$的前提下，求解相机的位姿$R$和$t$。</p><h2 id="2-算法总结"><a href="#2-算法总结" class="headerlink" title="2 算法总结"></a>2 算法总结</h2><h3 id="2-1-直接线性变换（DLT，Direct-Linear-Transform）"><a href="#2-1-直接线性变换（DLT，Direct-Linear-Transform）" class="headerlink" title="2.1 直接线性变换（DLT，Direct  Linear  Transform）"></a>2.1 直接线性变换（DLT，Direct  Linear  Transform）</h3><p>为了通过一个点的像素坐标和世界坐标构建一个关于相机位姿参数的方程，我们可以先通过相机内参将像素坐标转换为相机归一化坐标，根据相应的归一化约束条件可以获得关于姿态参数的两个方程，为了求解$R$和$t$中一共的12个参数，我们至少需要6个点来构建方程。</p><p>根据关系<script type="math/tex">\omega \boldsymbol{p}=KP^C=K[R|t]P^W</script>，可得<script type="math/tex">\omega K^{-1} \boldsymbol{p}=\omega P^{'}=P^{C}=[R|t]P^W</script>。</p><p>最初，我们已知点的像素坐标：$$\begin{pmatrix}u\\v \\1\end{pmatrix}$$</p><p>将其左乘相机内参矩阵的逆<script type="math/tex">K^{-1}</script>可得点在相机归一化坐标系中的坐标： $$\begin{pmatrix}u_1\\v_1 \\1\end{pmatrix} =K^{-1}\begin{pmatrix}u\\v \\1\end{pmatrix}$$</p><p>相机归一化坐标系中的坐标乘以点相对于成像平面的深度<script type="math/tex">\omega=Z^C</script>可得点相对于相机坐标系的坐标：$$\omega\begin{pmatrix}u_1\\v_1 \\1\end{pmatrix} =P^C$$</p><p>根据<script type="math/tex">P^{C}=[R|t]P^W</script>，可构建等式:  $$\omega\begin{pmatrix}u_1\\v_1 \\1\end{pmatrix} =\begin{pmatrix}t_1& t_2 & t_3 & t_4\\t_5& t_6 & t_7 & t_8\\t_9& t_{10} &t_{11}  & t_{12}\end{pmatrix}\begin{pmatrix}X^W\\Y^W \\Z^W\\1\end{pmatrix}$$</p><p>利用最后一行把$\omega$消去，可得两个约束：$$u_1=\frac{t_1X_W+t_2Y_W+t_3Z_W+t_4}{t_9X_W+t_{10}Y_W+t_{11}Z_W+t_{12}}$$， $$v_1=\frac{t_5X_W+t_6Y_W+t_7Z_W+t_8}{t_9X_W+t_{10}Y_W+t_{11}Z_W+t_{12}}$$</p><p>为简化表示，定义增广矩阵$T=[R|t]$的行向量表示： $$\boldsymbol{t}_1=(t_1,t_2,t_3,t_4)^T， \boldsymbol{t}_2=(t_5,t_6,t_7,t_8)^T， \boldsymbol{t}_3=(t_9,t_{10},t_{11},t_{12})^T$$</p><p>所以说，有：   $$\boldsymbol{t_1^TP^W}-\boldsymbol{t_3^TP^W}u_1=0，\boldsymbol{t_2^TP^W}-\boldsymbol{t_3^TP^W}v_1=0$$</p><p>注意上式中：<script type="math/tex">\boldsymbol{t}</script>是待求的变量；<script type="math/tex">\boldsymbol{P^W},u_1,v_1</script>是已知量，分别为点在世界坐标系下的3D位置以及在相机归一化坐标系下的2D投影位置(可通过点的像素坐标左乘相机内参矩阵的逆得到)。可以看出，每个特征点提供了两个关于<script type="math/tex">\boldsymbol{t}</script>的线性约束。假设一共有<script type="math/tex">N</script>个特征点，则可列出如下线性方程组：    $$\begin{pmatrix} \boldsymbol{P_1^T}  & 0 & -u_1 \boldsymbol{P_1^T}\\  0& \boldsymbol{P_1^T}  & -v_1 \boldsymbol{P_1^T}\\  ...& ... & ...\\  \boldsymbol{P_N^T}&  0&-u_N \boldsymbol{P_N^T} \\  0&  \boldsymbol{P_N^T}&-v_N \boldsymbol{P_N^T}\end{pmatrix} \begin{pmatrix} \boldsymbol{t_1} \\ \boldsymbol{t_2}\\\boldsymbol{t_3}\end{pmatrix}=0$$  </p><p>记为:$$A\boldsymbol{t}=0$$</p><p>注意上式中点的坐标省去了上标<script type="math/tex">^W</script>，它们都是点在世界坐标系下的表示。</p><p>注意到<script type="math/tex">\boldsymbol{t}</script>一共有12维，最少通过6对匹配点即可实现增广矩阵<script type="math/tex">\boldsymbol{T=[R|t]}</script>的线性求解，这种方法称为DLT。当1匹配点的数量大于6对时，可以使用SVD等方法求超定方程的最小二乘解。针对SVD求超定方程的最小二乘解，说明如下：当匹配点数量大于6对时，可以获得一个在<script type="math/tex">|\boldsymbol{t}|=1</script>约束下的最小二乘解<script type="math/tex">\boldsymbol{t^*}=\underset{\boldsymbol{t}}{argmin}||A\boldsymbol{t}||</script>。具体的，令<script type="math/tex">A=UDV^T</script>，则最小二乘解<script type="math/tex">\boldsymbol{t^*}</script>为<script type="math/tex">V</script>的最后一列<script type="math/tex">\boldsymbol{t^v}</script>，这样求得的最小二乘解是没有尺度的，之后可以再利用SVD确定最优旋转矩阵近似以及相应的尺度，便可以确定最终的相机姿态<script type="math/tex">T=[R|t]</script>。关于这一部分的细节，可以看参考文献[3].</p><h3 id="2-2-P3P"><a href="#2-2-P3P" class="headerlink" title="2.2 P3P"></a>2.2 P3P</h3><p>P3P利用3个点的几何关系，通过三点已知的世界坐标系下的3D坐标以及相应点在相机归一化平面上投影的2D坐标，可以通过构建方程得到三个点在相机坐标系下的3D坐标，之后将问题转化为3D-3D的ICP问题，由于带有匹配信息的3D-3D位姿求解非常容易，所以这种方法是有效的。</p><p>上图中，我们记3D点为A,B,C，2D点为a,b,c(注意2D点为3D点在相机归一化平面上的投影)，我们需要通过一些几何关系构建方程得到OA、OB、OC，来得到3D点在相机坐标系下的坐标（其实就是获取归一化平面上2D点的深度信息）。</p><p>对于三组对应的三角形： $$\bigtriangleup Oab-\bigtriangleup OAB,\bigtriangleup Obc -\bigtriangleup OBC,\bigtriangleup Oac-\bigtriangleup OAC$$</p><p>由余弦定理：$$OA^2+OB^2-2OA\cdot OB\cdot cos(a,b)=AB^2$$ $$OB^2+OC^2-2OB\cdot OC\cdot cos(b,c)=BC^2$$ $$OA^2+OC^2-2OA\cdot OC\cdot cos(a,c)=AC^2$$</p><p>对以上三式全体除以<script type="math/tex">OC^2</script>，并记<script type="math/tex">x=OA/OC,y=OB/OC</script>，可得： $$x^2+y^2-2xy cos(a,b)=AB^2/OC^2$$ $$y^2+1^2-2y cos(b,c)=BC^2/OC^2$$ $$x^2+1^2-2x cos(a,c)=AC^2/OC^2$$</p><p>由上式中的后两式可知，若能解出$x,y$，则代入后两式中的任一式，即可得到<script type="math/tex">OC</script>，之后再由<script type="math/tex">x,y</script>计算出<script type="math/tex">OA,OB</script>，便可以知道三个点在相机坐标系下的坐标。</p><p>为求解出<script type="math/tex">x,y</script>，记<script type="math/tex">v=AB^2/OC^2,uv=BC^2/OC^2,wv=AC^2/OC^2</script>，有：$$x^2+y^2-2xy cos=v$$ $$y^2+1^2-2y cos=uv$$ $$x^2+1^2-2x cos=wv$$</p><p>将第一个式子中得到的<script type="math/tex">v</script>代入后两式，可得：$$(1-u)y^2-ux^2-cos(b,c)y+2uxycos(a,b)+1=0$$ $$(1-w)x^2-wy^2-cos(a,c)x+2wxycos(a,b)+1=0$$</p><p>上面两个方程中，由于我们知道点的相机归一化坐标，即2D投影位置，则三个余弦<script type="math/tex">cos(a,b),cos(b,c),cos(a,c)</script>是已知的。同时，<script type="math/tex">u=BC^2/AB^2,w=AC^2/AB^2</script>可以通过三个点在世界坐标系下的坐标算出。该式中只有<script type="math/tex">x,y</script>是未知的，随着相机的移动会发生改变。所以，该方程组是关于<script type="math/tex">x,y</script>的一个二元二次方程，求该方程的解析解需要用到吴消元法，这个解法在参考文献[4]里有详细介绍。该方程最多可能有四个解，我们可以使用验证点来计算最可能的解，得到<script type="math/tex">A,B,C</script>在相机坐标系下的3D坐标，之后使用ICP计算相机的位姿<script type="math/tex">R,t</script>。</p><p>P3P利用3个点的几何关系，通过三对点已知的世界坐标系下的3D坐标以及相应点在相机归一化平面上投影的2D坐标，可以通过构建方程得到三个点在相机坐标系下的3D坐标，之后将问题转化为3D-3D的ICP问题，由于带有匹配信息的3D-3D位姿求解非常容易，所以这种方法是有效的。</p><p>但P3P同样存在一些问题：</p><ul><li>P3P值利用3个点的信息，当给定的匹配点多于3组时，难以利用更多的信息。</li><li>如果3D点或2D点受到噪声影响，或者存在误匹配，则算法失效。</li></ul><h3 id="2-3-EPnP"><a href="#2-3-EPnP" class="headerlink" title="2.3 EPnP"></a>2.3 EPnP</h3><p>EPnP的思路和P3P差不多，相对P3P来说，EPnP利用更多的信息，用迭代的方式对相机位姿进行优化，以尽可能消除噪声的影响。但主体思路都是先得到相应点在相机坐标系下的坐标，将3D-2D问题转换为3D-3D问题，再利用ICP求解。</p><p>EPnP算法利用已知的<script type="math/tex">n</script>个3D点的世界坐标，通过PCA选择4个控制点(世界坐标已知)，建立新的局部坐标系，从而将3D点的世界坐标用新的控制点(世界坐标)表示出来。然后，利用相机投影模型和2D点像素坐标，建立关于控制点在相机坐标系下坐标的线性方程组，求解出4个控制点在相机坐标系下的坐标，进而求解出<script type="math/tex">n</script>个3D点在相机坐标系下的坐标。到了这里，我们已知<script type="math/tex">n</script>个3D点在世界坐标系下和相机坐标系下的坐标，问题转换为3D-3D问题，利用ICP求解即可。</p><p>在本节中:</p><ul><li>所有<script type="math/tex">n</script>个3D参考点在世界坐标系下的坐标分别为<script type="math/tex">\boldsymbol{p}^w_i,i=1,2,...,n</script></li><li>在相机坐标系下的坐标分别为<script type="math/tex">\boldsymbol{p}^c_i,i=1,2,...,n</script></li><li>我们选择的4个控制点在世界坐标系下的坐标分别为<script type="math/tex">\boldsymbol{c}^w_j,j=1,2,3,4</script> </li><li>4个控制点在相机坐标系下的坐标分别为<script type="math/tex">\boldsymbol{c}^c_j,j=1,2,3,4</script> </li></ul><p>EPnP将<script type="math/tex">n</script>个参考点中的每一个表示为4个控制点的加权和：</p><p>​                                                       $$\boldsymbol{p}^w_i=\sum_{j=1}^{4}\alpha _{ij}\boldsymbol{c}^w_j,\quad with \quad\sum_{j=1}^{4}\alpha _{ij}=1$$</p><p>同理，相机坐标系下也有：</p><p>​                                                       $$\boldsymbol{p}^c_i=\sum_{j=1}^{4}\alpha _{ij}\boldsymbol{c}^c_j,\quad with \quad\sum_{j=1}^{4}\alpha _{ij}=1$$</p><p><script type="math/tex">n</script>个参考点的世界坐标<script type="math/tex">\boldsymbol{p}^w_i</script>我们是已知的，四个参考点是我们人为选择的，其世界坐标<script type="math/tex">\boldsymbol{c}^w_j</script>可以认为是已知的，加权系数<script type="math/tex">\alpha_{ij}</script>可以利用参考点和控制点的世界坐标很方便的计算出来。那么唯一需要我们计算的未知量就是4个控制点在相机坐标系下的坐标，其可以根据相机投影模型和<script type="math/tex">n</script>个参考点的2D像素坐标构建线性方程组计算。之后我们便得到了<script type="math/tex">n</script>个参考点在世界坐标系和相机坐标系下的坐标，问题便被转化为ICP问题。</p><p>接下来我们依次解决上面一段所述EPnP算法框架中的细节问题：</p><ul><li>关系<script type="math/tex">\boldsymbol{p}^c_i=\sum_{j=1}^{4}\alpha _{ij}\boldsymbol{c}^c_j</script>为什么成立？</li><li>为什么控制点要选择4个？</li><li>4个控制点该如何选择？</li><li>4个控制点在相机坐标系下的坐标如何计算？</li></ul><p>由于 ：$$\boldsymbol{p}^c_i=\begin{pmatrix}R&\boldsymbol{t}\end{pmatrix}\begin{pmatrix}\boldsymbol{p}^w_i\\1\end{pmatrix}=\begin{pmatrix}R&\boldsymbol{t}\end{pmatrix}\begin{pmatrix}\sum_{j=1}^{4}\alpha_{ij}\boldsymbol{c}^w_j\\1\end{pmatrix}= \begin{pmatrix}R&\boldsymbol{t}\end{pmatrix}\begin{pmatrix}\sum_{j=1}^{4}\alpha_{ij}\boldsymbol{c}^w_j\\\sum_{j=1}^{4}\alpha _{ij}\end{pmatrix}=\sum_{j=1}^{4}\alpha _{ij}\begin{pmatrix}R&\boldsymbol{t}\end{pmatrix}\begin{pmatrix}\boldsymbol{c}^w_j\\1\end{pmatrix}=\sum_{j=1}^{4}\alpha _{ij}\boldsymbol{c}^c_j$$</p><p>因此关系<script type="math/tex">\boldsymbol{p}^c_i=\sum_{j=1}^{4}\alpha _{ij}\boldsymbol{c}^c_j</script>成立，在上面的推导过程中，我们用到了非常重要的约束条件<script type="math/tex">\sum_{j=1}^{4}\alpha _{ij}=1</script>。如果没有这个约束条件，上述推导将不成立，我们也无法得到相机坐标系下参考点和控制点的关系。</p><p>正是由于约束条件<script type="math/tex">\sum_{j=1}^{4}\alpha _{ij}=1</script>必须被精确的满足，我们在选择控制点时必须选择4个而不是3个。</p><p>假如我们仅选择3个控制点，那么我们可以列出方程：$$\boldsymbol{p}^w_i=\begin{pmatrix}X^W_i\\Y^W _i\\Z^W_i\end{pmatrix}=\begin{pmatrix}\boldsymbol{c}^w_1&\boldsymbol{c}^w_2 &\boldsymbol{c}^w_3\end{pmatrix}\begin{pmatrix}\alpha_{i1}\\\alpha_{i2}\\\alpha_{i3}\end{pmatrix}$$</p><p> 且 $$\sum_{j=1}^{3}\alpha _{ij}=1$$</p><p>一共三个未知量确有四个方程，这是一个超定方程组，只存在最小二乘意义上的解。换句话，在一般情形下，不存在精确满足4个方程的解。即约束不一定能被精确的满足。</p><p>在选择4个控制点的情形下：$$\begin{pmatrix}\boldsymbol{p}^w_i\\1\end{pmatrix}=\begin{pmatrix}X^W_i\\Y^W _i\\Z^W_i\\1\end{pmatrix}=\begin{pmatrix}\boldsymbol{c}^w_1&\boldsymbol{c}^w_2 &\boldsymbol{c}^w_3&\boldsymbol{c}^w_4\\1&1&1&1\end{pmatrix}\begin{pmatrix}\alpha_{i1}\\\alpha_{i2}\\\alpha_{i3}\\\alpha_{i4}\end{pmatrix}=C\begin{pmatrix}\alpha_{i1}\\\alpha_{i2}\\\alpha_{i3}\\\alpha_{i4}\end{pmatrix}$$</p><p>可以精确解出： $$\begin{pmatrix}\alpha_{i1}\\\alpha_{i2}\\\alpha_{i3}\\\alpha_{i4}\end{pmatrix}=C^{-1}\begin{pmatrix}\boldsymbol{p}^w_i\\1\end{pmatrix}$$</p><p>在选择控制点时，原则上只要矩阵<script type="math/tex">C</script>可逆即可，四个控制点不共面即可。参考文献[5]中给出了更加精细选择控制点的方法，可以参考。</p><p>之后我们进行最重要的一步，即计算4个控制点在相机坐标系下的坐标：</p><p>由相机模型，我们可以得到： $$\omega_i\begin{pmatrix}u_i\\v_i \\1\end{pmatrix}=\begin{pmatrix}f_x& 0 &c_x \\0&f_y  &c_y \\0 & 0 &1\end{pmatrix} \sum_{j=1}^{4}\alpha _{ij}\begin{pmatrix}x^c_j\\y^c_j \\z^c_j\end{pmatrix}$$</p><p>上式中有<script type="math/tex">\boldsymbol{c}^c_j=(x^c_j,y^c_j,z^c_j)^T</script>。我们可以得到两个线性方程：$$\sum_{j=1}^4\alpha _{ij}f_xx_j^c+\alpha _{ij}(c_x-u_i)z^c_j=0$$ $$\sum_{j=1}^4\alpha _{ij}f_yy_j^c+\alpha _{ij}(c_y-v_i)z^c_j=0$$</p><p>把所有<script type="math/tex">n</script>个点结合起来，可以得到关于4个控制点共12个坐标的线性方程组，解数值方程。最后还需要利用空间点在外参变换下，空间关系不改变的约束，即<script type="math/tex">||\boldsymbol{c}^w_i-\boldsymbol{c}^w_j||^2=||\boldsymbol{c}^c_i-\boldsymbol{c}^c_j||^2</script>，结合非线性优化来得到最终的控制点在相机坐标系下的坐标。</p><p>得到4个控制点在相机坐标系下的坐标之后，我们便可以计算<script type="math/tex">n</script>个参考点在相机坐标系下的坐标。有了<script type="math/tex">n</script>个3D参考点在相机坐标系和世界坐标系下的坐标之后，我们将问题转化为3D-3D问题，利用ICP求解即可。</p><h3 id="2-4-光束法平差（BA，Bundle-Adjustment）"><a href="#2-4-光束法平差（BA，Bundle-Adjustment）" class="headerlink" title="2.4 光束法平差（BA，Bundle Adjustment）"></a>2.4 光束法平差（BA，Bundle Adjustment）</h3><p>上面的方法都是线性的，我们还可以把PnP问题构建为一个关于重投影误差的非线性最小二乘问题。线性方法往往是通过将空间点的位置看做已知量，通过构建方程组求解相机位姿。而非线性优化则将相机位姿和空间点位置都看成优化变量，放在一起优化，这也是BA的另一个名字：捆集优化的由来(个人理解)。这种方法将相机位姿和三维点位置放在一起进行重投影误差最小化的优化，是一种整体的优化方法。</p><p>假设我们有n个三维空间点，其世界坐标系下的坐标为<script type="math/tex">\boldsymbol{P}^W_i=[X^W_i,Y^W_i,Z^W_i]^T(i=1,2,...,n)</script>，相应点在像素坐标系下的齐次坐标为<script type="math/tex">\boldsymbol{p}_i=[u_i,v_i,1]^T(i=1,2,...,n)</script>。假设相机位姿已知且观测点没有噪声，则两者之间存在以下关系：$$\omega_i\begin{pmatrix}u_i\\v_i \\1\end{pmatrix} =\boldsymbol{KT}\begin{pmatrix}X^W\\Y^W \\Z^W\\1\end{pmatrix}$$</p><p>其矩阵形式为： $$\omega_i \boldsymbol{p_i}=\boldsymbol{KTP}^W_i$$</p><p>上式中隐含了一次从齐次坐标到非齐次坐标的转换,其中<script type="math/tex">\omega_i</script>为点在相机坐标系下的深度，<script type="math/tex">K</script>为相机内参矩阵，<script type="math/tex">T</script>为世界坐标系到相机坐标系的变换矩阵。</p><p>但由于相机位姿未知以及观测点存在一定噪声误差，该式并不严格成立。因此，为了求解出最优的相机位姿，我们构建最小二乘问题，将<script type="math/tex">n</script>个观测点对应的误差求和，寻找最优的相机位姿，使得总的误差最小化：$$\boldsymbol{T^*}=\underset{\boldsymbol{T}}{argmin}\frac{1}{2}\sum_{i=1}^n||\boldsymbol{p_i}-\frac{1}{\omega_i }\boldsymbol{KTP}^W_i||^2$$</p><p>上式中的误差，是将<strong>观测</strong>到的像素坐标系下的投影坐标与通过相机位姿和3D点位置<strong>计算</strong>得到的像素坐标系下的投影坐标做差，称为重投影误差。一般来说，我们计算误差时使用非齐次坐标，即像素坐标系两个轴方向上的误差，故误差只有两维。在实际问题中，我们通过特征匹配得到了像素坐标系下的<script type="math/tex">\boldsymbol{p}_i</script>和世界坐标系下的<script type="math/tex">\boldsymbol{P}^W_i</script>是同一个空间点的两种不同表达形式，但是不知道相机位姿<script type="math/tex">T</script>，所以一开始观测到的像素坐标<script type="math/tex">\boldsymbol{p}_i</script>和通过位姿计算投影得到的计算值<script type="math/tex">\frac{1}{\omega_i }\boldsymbol{KTP}^W_i</script>并不重合，两者之间有一定的距离，我们通过调整相机位姿的估计值，使得这个距离变小。因为我们有很多对空间点的匹配关系，这个相机位姿估计值的调整需要同时考虑很多对点，这也就使得最后的效果是整体误差的缩小，而每一对点的误差都不会精确为0。</p><p>在调整相机位姿的估计值使得整体误差变小的过程中，最重要的是要知道误差相对于相机位姿的导数，知道了导数才能确定相机位姿估计值调整的方向，导数即误差项关于优化变量的导数，也就是线性化： $$\boldsymbol{e(x+\Delta x)\approx e(x)+J^T\Delta x}$$</p><p>其中的雅克比矩阵<script type="math/tex">\boldsymbol{J^T}</script>的解析形式是问题的关键。目前，<script type="math/tex">\boldsymbol{e}</script>为像素误差(2维)，<script type="math/tex">\boldsymbol{x}</script>为相机位姿(6维)，<script type="math/tex">\boldsymbol{J^T}</script>是一个<script type="math/tex">2\times 6</script>的矩阵。</p><p>之后将应用扰动模型来通过李代数求解误差相对于位姿的导数。由于旋转矩阵自身带有约束，作为优化变量会引入额外的约束，使问题变得困难。通过李群—李代数之间的转换关系，我们可以把位姿估计变成无约束的优化问题，简化求解方式。</p><p>记空间点在相机坐标系下的坐标为<script type="math/tex">P^C=[X^C,Y^C,Z^C]^T</script>，则有<script type="math/tex">\omega \boldsymbol{p}=KP^C</script>，利用相机模型可知：$$u_{cal}=f_x\frac{X^C}{Z^C}+c_x,v_{cal}=f_y\frac{Y^C}{Z^C}+c_y$$ </p><p>上式中的<script type="math/tex">u,v</script>均为根据相机位姿计算而来的像素坐标，通过下标表明。我们定义的误差为观测值减计算值(预测值)，即$$\boldsymbol{e}=\begin{pmatrix}u_{measure}-u_{calculate}\\v_{measure}-v_{calculate} \end{pmatrix}=\begin{pmatrix}u_{measure}-f_x\frac{X^C}{Z^C}-c_x\\v_{measure}-f_y\frac{Y^C}{Z^C}-c_y \end{pmatrix}$$</p><p>通过定义相机坐标系下坐标这一中间变量，我们可以很方便的通过链式法则求解误差的变化关于位姿扰动量的导数：$$\frac{\partial \boldsymbol{e}}{\partial \delta\boldsymbol{\xi}}=\frac{\partial \boldsymbol{e}}{\partial \boldsymbol{P}^C}\frac{\partial \boldsymbol{P}^C}{\partial \delta\boldsymbol{\xi}}$$ </p><p>上式中第一项是误差关于投影点的导数，根据上文相机模型中得到的关系，可得：$$\frac{\partial \boldsymbol{e}}{\partial \boldsymbol{P}^C}=-\begin{pmatrix}\frac{\partial u_{cal}}{\partial X^C}& \frac{\partial u_{cal}}{\partial Y^C} & \frac{\partial u_{cal}}{\partial Z^C} \\\frac{\partial v_{cal}}{\partial X^C}& \frac{\partial v_{cal}}{\partial Y^C} & \frac{\partial v_{cal}}{\partial Z^C}  \end{pmatrix}=-\begin{pmatrix}\frac{f_x}{Z^C}& 0 & -\frac{f_xX^C}{(Z^{C})^2}  \\0& \frac{f_y}{Z^C} & -\frac{f_yY^C}{(Z^{C})^2}  \end{pmatrix}$$</p><p>第二项为变换到相机坐标系后的点关于李代数的导数，可得：$$\frac{\partial \boldsymbol{P}^C}{\partial \delta\boldsymbol{\xi}}=\frac{\partial (\boldsymbol{TP}^W)}{\partial \delta\boldsymbol{\xi}}=(\boldsymbol{TP}^W)^{\odot}=\begin{pmatrix}\boldsymbol{I}& -(\boldsymbol{P}^C)^{\wedge }  \end{pmatrix}$$</p><p>注意我们采用的是非齐次坐标，所以上式中只保留了矩阵的前三维。</p><p>将上面两项相乘，就可以得到最终版<script type="math/tex">2\times 6</script> 的雅克比矩阵：$$\boldsymbol{J}^T=\frac{\partial \boldsymbol{e}}{\partial \delta\boldsymbol{\xi}}=-\begin{pmatrix}\frac{f_x}{Z^C}& 0 & -\frac{f_xX^C}{(Z^{C})^2} &-\frac{f_xY^CX^C}{(Z^{C})^2}&f_x+\frac{f_x(X^C)^2}{(Z^{C})^2}&-\frac{f_xY^C}{Z^C} \\0& \frac{f_y}{Z^C} & -\frac{f_yY^C}{(Z^{C})^2}  & -f_y-\frac{f_y(Y^C)^2}{(Z^{C})^2}&\frac{f_yY^CX^C}{(Z^{C})^2}&\frac{f_yX^C}{Z^C}\end{pmatrix}$$</p><p>上式中的雅克比描述了重投影误差关于相机位姿李代数的一阶变化关系。前面的负号是由于我们的误差是由观测值减计算值(预测值)定义的，如果反过来，将误差定义成“预测值减观测值”的形式，只需要去掉前面的负号即可。此外，如果李代数<script type="math/tex">se(3)</script>的定义方式是旋转在前，平移在后，则只需要将该矩阵的前3列与后3列对调即可。</p><p>除了优化相机位姿之外，我们还希望优化特征点的空间位置，因此还需要讨论误差<script type="math/tex">\boldsymbol{e}</script>关于空间点<script type="math/tex">\boldsymbol{P}^W</script>的导数，这个导数相对来说推导较为简单：$$\frac{\partial \boldsymbol{e}}{\partial \boldsymbol{P}^W}=\frac{\partial \boldsymbol{e}}{\partial \boldsymbol{P}^C}\frac{\partial \boldsymbol{P}^C}{\partial \boldsymbol{P}^W}$$</p><p>上式中第一项已经推出，推导第二项时，按照定义，有<script type="math/tex">\boldsymbol{P}^C=R\boldsymbol{P}^W+t</script>，则<script type="math/tex">\boldsymbol{P}^C</script>对<script type="math/tex">\boldsymbol{P}^W</script>求导之后只剩下<script type="math/tex">R</script>.</p><p>所以，我们得到误差向量关于空间点位置的导数为：$$\frac{\partial \boldsymbol{e}}{\partial \boldsymbol{P}^W}=-\begin{pmatrix}\frac{f_x}{Z^C}& 0 & -\frac{f_xX^C}{(Z^{C})^2}  \\0& \frac{f_y}{Z^C} & -\frac{f_yY^C}{(Z^{C})^2}  \end{pmatrix}\boldsymbol{R}$$</p><p>上面我们导出了重投影误差向量关于相机位姿与特征点位置的两个导数矩阵。这两个导数矩阵十分重要，能够在优化迭代调整相机位姿估计值的过程中，提供重中之重的梯度方向，指导优化的迭代。</p><p>下面是具体的优化迭代过程：</p><p>每一次迭代时，对于每一个空间点，先将空间点在世界坐标系下的坐标变换到相机坐标系下，在通过相机内参得到像素坐标的计算值，将像素坐标的观测值与计算值做差，得到误差向量<script type="math/tex">\boldsymbol{e}_i</script>，同时得到雅克比矩阵<script type="math/tex">\boldsymbol{J}^T_i</script>。对每个点计算出其对应的误差向量和雅克比矩阵之后，可以得到<script type="math/tex">\boldsymbol{H}=\sum_{i=1}^n\boldsymbol{J}_i\boldsymbol{J}^T_i</script>，<script type="math/tex">\boldsymbol{b}=-\sum_{i=1}^n\boldsymbol{J}_i\boldsymbol{e}_i</script>，通过解线性方程组<script type="math/tex">\boldsymbol{H}\boldsymbol{\Delta x}=\boldsymbol{b}</script>，得到位姿的变化量<script type="math/tex">\boldsymbol{\Delta x}</script>，则变化之后的位姿为：<script type="math/tex">\xi ^{'}=exp(\boldsymbol{\Delta x})\xi</script>，如此不断迭代，当<script type="math/tex">\boldsymbol{\Delta x}</script>范数足够小时停止迭代。</p><p>下面是高翔老师在《视觉SLAM14讲》中提供的手写Gauss-Newton法进行位姿估计的相关代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bundleAdjustmentGaussNewton</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-keyword">const</span> VecVector3d &amp;points_3d,</span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-keyword">const</span> VecVector2d &amp;points_2d,</span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-keyword">const</span> Mat &amp;K,</span></span><br><span class="hljs-params"><span class="hljs-function">  Sophus::SE3d &amp;pose)</span></span><br><span class="hljs-function">  </span>&#123;  <span class="hljs-comment">//传入空间点点，空间点像素坐标，内参; 初始pose,此程序中初始pose为0;</span><br>  <span class="hljs-keyword">typedef</span> Eigen::Matrix&lt;<span class="hljs-keyword">double</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>&gt; Vector6d;<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> iterations = <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">double</span> cost = <span class="hljs-number">0</span>, lastCost = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">double</span> fx = K.at&lt;<span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">double</span> fy = K.at&lt;<span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">double</span> cx = K.at&lt;<span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">double</span> cy = K.at&lt;<span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>      <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> iter = <span class="hljs-number">0</span>; iter &lt; iterations; iter++) &#123;  <span class="hljs-comment">//进行迭代</span><br>    Eigen::Matrix&lt;<span class="hljs-keyword">double</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>&gt; H = Eigen::Matrix&lt;<span class="hljs-keyword">double</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>&gt;::<span class="hljs-built_in">Zero</span>();<br>    Vector6d b = Vector6d::<span class="hljs-built_in">Zero</span>();<br>    cost = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// compute cost</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; points_3d.<span class="hljs-built_in">size</span>(); i++) &#123;<br>      Eigen::Vector3d pc = pose * points_3d[i];<span class="hljs-comment">//得到空间点在相机坐标系下的坐标</span><br>      <span class="hljs-comment">// Vector6d se3 = pose.log();</span><br>      <span class="hljs-comment">// cout&lt;&lt;&quot;se3 = &quot;&lt;&lt;se3.transpose()&lt;&lt;endl;一开始se3为0,三四次迭代后趋于稳定</span><br>      <span class="hljs-keyword">double</span> inv_z = <span class="hljs-number">1.0</span> / pc[<span class="hljs-number">2</span>];<br>      <span class="hljs-keyword">double</span> inv_z2 = inv_z * inv_z;<br>      <span class="hljs-function">Eigen::Vector2d <span class="hljs-title">proj</span> <span class="hljs-params">(fx * pc[<span class="hljs-number">0</span>] / pc[<span class="hljs-number">2</span>] + cx, fy * pc[<span class="hljs-number">1</span>] / pc[<span class="hljs-number">2</span>] + cy)</span></span>;<span class="hljs-comment">//P点像素坐标的投影计算值</span><br>      Eigen::Vector2d e = points_2d[i] - proj;<span class="hljs-comment">//作差，得到差值;是观测值-预测值！</span><br>      cost += e.<span class="hljs-built_in">squaredNorm</span>();<span class="hljs-comment">//误差的二范数的平方</span><br>      Eigen::Matrix&lt;<span class="hljs-keyword">double</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>&gt; J;<span class="hljs-comment">//2*6的雅克比矩阵，即误差相对于位姿求导，通过导数可以知道有了误差以后我们应该往哪个方向去优化</span><br>      J &lt;&lt; -fx * inv_z,<br>        <span class="hljs-number">0</span>,<br>        fx * pc[<span class="hljs-number">0</span>] * inv_z2,<br>        fx * pc[<span class="hljs-number">0</span>] * pc[<span class="hljs-number">1</span>] * inv_z2,<br>        -fx - fx * pc[<span class="hljs-number">0</span>] * pc[<span class="hljs-number">0</span>] * inv_z2,<br>        fx * pc[<span class="hljs-number">1</span>] * inv_z,<br>        <span class="hljs-number">0</span>,<br>        -fy * inv_z,<br>        fy * pc[<span class="hljs-number">1</span>] * inv_z,<br>        fy + fy * pc[<span class="hljs-number">1</span>] * pc[<span class="hljs-number">1</span>] * inv_z2,<br>        -fy * pc[<span class="hljs-number">0</span>] * pc[<span class="hljs-number">1</span>] * inv_z2,<br>        -fy * pc[<span class="hljs-number">0</span>] * inv_z;<br>      H += J.<span class="hljs-built_in">transpose</span>() * J;<span class="hljs-comment">//高斯牛顿方法，H*dx=b</span><br>      b += -J.<span class="hljs-built_in">transpose</span>() * e;<br>    &#125;<br>    Vector6d dx;<br>    dx = H.<span class="hljs-built_in">ldlt</span>().<span class="hljs-built_in">solve</span>(b);<span class="hljs-comment">//对H做LDLT分解，并求解dx</span><br>    cout &lt;&lt;<span class="hljs-string">&quot;dx:&quot;</span> &lt;&lt; endl &lt;&lt; dx &lt;&lt;endl;<br>    cout &lt;&lt;<span class="hljs-string">&quot;dx.norm():&quot;</span> &lt;&lt; endl &lt;&lt; dx.<span class="hljs-built_in">norm</span>() &lt;&lt;endl;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isnan</span>(dx[<span class="hljs-number">0</span>])) &#123;<br>      cout &lt;&lt; <span class="hljs-string">&quot;result is nan!&quot;</span> &lt;&lt; endl;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (iter &gt; <span class="hljs-number">0</span> &amp;&amp; cost &gt;= lastCost) &#123;<br>      <span class="hljs-comment">// cost increase, update is not good//发散的情况</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;cost: &quot;</span> &lt;&lt; cost &lt;&lt; <span class="hljs-string">&quot;, last cost: &quot;</span> &lt;&lt; lastCost &lt;&lt; endl;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// update your estimation</span><br>    pose = Sophus::SE3d::<span class="hljs-built_in">exp</span>(dx) * pose;<br>    lastCost = cost;<br>    cout &lt;&lt; <span class="hljs-string">&quot;iteration &quot;</span> &lt;&lt; iter &lt;&lt; <span class="hljs-string">&quot; cost=&quot;</span> &lt;&lt; cout.<span class="hljs-built_in">precision</span>(<span class="hljs-number">12</span>) &lt;&lt; cost &lt;&lt; endl;<br>    <span class="hljs-keyword">if</span> (dx.<span class="hljs-built_in">norm</span>() &lt; <span class="hljs-number">1e-6</span>) &#123;<br>      <span class="hljs-comment">// converge 当dx&lt;1e-6时停止迭代</span><br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  cout &lt;&lt; <span class="hljs-string">&quot;pose by g-n: \n&quot;</span> &lt;&lt; pose.<span class="hljs-built_in">matrix</span>() &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-四种算法总结"><a href="#2-5-四种算法总结" class="headerlink" title="2.5 四种算法总结"></a>2.5 四种算法总结</h3><p>每种算法用一句话概括：</p><ul><li>DLT：根据<script type="math/tex">n</script>个点的世界坐标和相机归一化平面坐标，最后一行用于消去深度，得到<script type="math/tex">2n</script>个约束方程，利用SVD求解超定方程并得到位姿矩阵的估计。</li><li>P3P：根据3个点的世界坐标和相机归一化平面坐标，利用余弦定理几何关系，得到3个点的相机坐标，将问题转化为3D-3D位姿估计并利用ICP求解，最后还需要一对点用于验证。</li><li>EPnP：根据<script type="math/tex">n</script>个点的世界坐标选择4个控制点并计算加权系数，通过相机模型和<script type="math/tex">n</script>个点的像素坐标求解4个控制点在相机坐标系下的坐标，进而得到<script type="math/tex">n</script>个点在相机坐标系下的坐标，将问题转化为3D-3D位姿估计并利用ICP求解。</li><li>BA：根据对应点的重投影误差构建非线性优化问题，利用李代数得到误差关于位姿的导数以指导优化方向，不断迭代求得所有对应点重投影误差之和最小的位姿估计。</li></ul><h2 id="3-一些数学"><a href="#3-一些数学" class="headerlink" title="3 一些数学"></a>3 一些数学</h2><h3 id="3-1-动机引入"><a href="#3-1-动机引入" class="headerlink" title="3.1 动机引入"></a>3.1 动机引入</h3><p>在计算机视觉中进行相机的位姿估计时，无论是2D-2D，3D-2D还是3D-3D，大多都有线性和非线性两种解法。线性的求解大多利用线性代数作为工具，其中最主要的还是<strong>SVD</strong>(奇异值分解)；非线性优化则大多需要求解误差关于位姿的导数，这时利用<strong>李代数</strong>将位姿估计变成无约束的优化问题，可以方便问题的求解。因此，在理解了算法的大致思想和工程应用之后，还是有必要在数学方面进行更加深入的学习和理解。</p><h3 id="3-2-关于SVD的一些理解"><a href="#3-2-关于SVD的一些理解" class="headerlink" title="3.2 关于SVD的一些理解"></a>3.2 关于SVD的一些理解</h3><h3 id="3-3-关于李群李代数的一些理解"><a href="#3-3-关于李群李代数的一些理解" class="headerlink" title="3.3 关于李群李代数的一些理解"></a>3.3 关于李群李代数的一些理解</h3><h3 id="3-4-关于g2o与图优化"><a href="#3-4-关于g2o与图优化" class="headerlink" title="3.4 关于g2o与图优化"></a>3.4 关于g2o与图优化</h3><h2 id="4-参考文献"><a href="#4-参考文献" class="headerlink" title="4 参考文献"></a>4 参考文献</h2><p>[1]《视觉SLAM14讲》</p><p>[2]《计算机视觉中的多视图几何》</p><p>[3] <a href="https://zhuanlan.zhihu.com/p/58648937?edition=yidianzixun">https://zhuanlan.zhihu.com/p/58648937?edition=yidianzixun</a> (一篇关于DLT的很详细的文章)</p><p>[4]<a href="https://www.cnblogs.com/mafuqiang/p/8302663.html">https://www.cnblogs.com/mafuqiang/p/8302663.html</a> (详细介绍了很多P3P求解中的细节)</p><p>[5]<a href="https://blog.csdn.net/jessecw79/article/details/82945918">https://blog.csdn.net/jessecw79/article/details/82945918</a> (关于EPnP的一篇很详细的文章)</p>]]></content>
    
    
    
    <tags>
      
      <tag>Algorithum</tag>
      
      <tag>SLAM</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
